var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@joint/core/dist/joint.js
var require_joint = __commonJS({
  "node_modules/@joint/core/dist/joint.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.joint = {}));
    })(exports, (function(exports2) {
      "use strict";
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
      }
      function unwrapExports(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function createCommonjsModule(fn2, module2) {
        return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
      }
      function getCjsExportFromNamespace(n) {
        return n && n["default"] || n;
      }
      var check = function(it) {
        return it && it.Math == Math && it;
      };
      var global_1 = (
        // eslint-disable-next-line no-undef
        check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || // eslint-disable-next-line no-new-func
        /* @__PURE__ */ (function() {
          return this;
        })() || Function("return this")()
      );
      var fails = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
      var descriptors = !fails(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      });
      "use strict";
      var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
      var f$4 = NASHORN_BUG ? function propertyIsEnumerable2(V3) {
        var descriptor = getOwnPropertyDescriptor$2(this, V3);
        return !!descriptor && descriptor.enumerable;
      } : nativePropertyIsEnumerable;
      var objectPropertyIsEnumerable = {
        f: f$4
      };
      var createPropertyDescriptor = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
      var toString = {}.toString;
      var classofRaw = function(it) {
        return toString.call(it).slice(8, -1);
      };
      var split = "".split;
      var indexedObject = fails(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classofRaw(it) == "String" ? split.call(it, "") : Object(it);
      } : Object;
      var requireObjectCoercible = function(it) {
        if (it == void 0) throw TypeError("Can't call method on " + it);
        return it;
      };
      var toIndexedObject = function(it) {
        return indexedObject(requireObjectCoercible(it));
      };
      var isObject$1 = function(it) {
        return typeof it === "object" ? it !== null : typeof it === "function";
      };
      var toPrimitive = function(input, PREFERRED_STRING) {
        if (!isObject$1(input)) return input;
        var fn2, val;
        if (PREFERRED_STRING && typeof (fn2 = input.toString) == "function" && !isObject$1(val = fn2.call(input))) return val;
        if (typeof (fn2 = input.valueOf) == "function" && !isObject$1(val = fn2.call(input))) return val;
        if (!PREFERRED_STRING && typeof (fn2 = input.toString) == "function" && !isObject$1(val = fn2.call(input))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
      var hasOwnProperty$1 = {}.hasOwnProperty;
      var has$2 = function(it, key) {
        return hasOwnProperty$1.call(it, key);
      };
      var document$2 = global_1.document;
      var EXISTS = isObject$1(document$2) && isObject$1(document$2.createElement);
      var documentCreateElement = function(it) {
        return EXISTS ? document$2.createElement(it) : {};
      };
      var ie8DomDefine = !descriptors && !fails(function() {
        return Object.defineProperty(documentCreateElement("div"), "a", {
          get: function() {
            return 7;
          }
        }).a != 7;
      });
      var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var f$3 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O, P) {
        O = toIndexedObject(O);
        P = toPrimitive(P, true);
        if (ie8DomDefine) try {
          return nativeGetOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
        if (has$2(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
      };
      var objectGetOwnPropertyDescriptor = {
        f: f$3
      };
      var anObject = function(it) {
        if (!isObject$1(it)) {
          throw TypeError(String(it) + " is not an object");
        }
        return it;
      };
      var nativeDefineProperty = Object.defineProperty;
      var f$2 = descriptors ? nativeDefineProperty : function defineProperty2(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (ie8DomDefine) try {
          return nativeDefineProperty(O, P, Attributes);
        } catch (error) {
        }
        if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported");
        if ("value" in Attributes) O[P] = Attributes.value;
        return O;
      };
      var objectDefineProperty = {
        f: f$2
      };
      var createNonEnumerableProperty = descriptors ? function(object, key, value) {
        return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
      var setGlobal = function(key, value) {
        try {
          createNonEnumerableProperty(global_1, key, value);
        } catch (error) {
          global_1[key] = value;
        }
        return value;
      };
      var SHARED = "__core-js_shared__";
      var store$1 = global_1[SHARED] || setGlobal(SHARED, {});
      var sharedStore = store$1;
      var functionToString = Function.toString;
      if (typeof sharedStore.inspectSource != "function") {
        sharedStore.inspectSource = function(it) {
          return functionToString.call(it);
        };
      }
      var inspectSource = sharedStore.inspectSource;
      var WeakMap$2 = global_1.WeakMap;
      var nativeWeakMap = typeof WeakMap$2 === "function" && /native code/.test(inspectSource(WeakMap$2));
      var isPure = false;
      var shared = createCommonjsModule(function(module2) {
        (module2.exports = function(key, value) {
          return sharedStore[key] || (sharedStore[key] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: "3.8.3",
          mode: isPure ? "pure" : "global",
          copyright: "Â© 2021 Denis Pushkarev (zloirock.ru)"
        });
      });
      var id = 0;
      var postfix = Math.random();
      var uid = function(key) {
        return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
      };
      var keys$1 = shared("keys");
      var sharedKey = function(key) {
        return keys$1[key] || (keys$1[key] = uid(key));
      };
      var hiddenKeys$1 = {};
      var WeakMap$1 = global_1.WeakMap;
      var set$1, get$1, has$1;
      var enforce = function(it) {
        return has$1(it) ? get$1(it) : set$1(it, {});
      };
      var getterFor = function(TYPE) {
        return function(it) {
          var state;
          if (!isObject$1(it) || (state = get$1(it)).type !== TYPE) {
            throw TypeError("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (nativeWeakMap) {
        var store = sharedStore.state || (sharedStore.state = new WeakMap$1());
        var wmget = store.get;
        var wmhas = store.has;
        var wmset = store.set;
        set$1 = function(it, metadata) {
          metadata.facade = it;
          wmset.call(store, it, metadata);
          return metadata;
        };
        get$1 = function(it) {
          return wmget.call(store, it) || {};
        };
        has$1 = function(it) {
          return wmhas.call(store, it);
        };
      } else {
        var STATE = sharedKey("state");
        hiddenKeys$1[STATE] = true;
        set$1 = function(it, metadata) {
          metadata.facade = it;
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get$1 = function(it) {
          return has$2(it, STATE) ? it[STATE] : {};
        };
        has$1 = function(it) {
          return has$2(it, STATE);
        };
      }
      var internalState = {
        set: set$1,
        get: get$1,
        has: has$1,
        enforce,
        getterFor
      };
      var internalState_1 = internalState.set;
      var internalState_2 = internalState.get;
      var internalState_3 = internalState.has;
      var internalState_4 = internalState.enforce;
      var internalState_5 = internalState.getterFor;
      var redefine = createCommonjsModule(function(module2) {
        var getInternalState2 = internalState.get;
        var enforceInternalState = internalState.enforce;
        var TEMPLATE = String(String).split("String");
        (module2.exports = function(O, key, value, options) {
          var unsafe = options ? !!options.unsafe : false;
          var simple = options ? !!options.enumerable : false;
          var noTargetGet = options ? !!options.noTargetGet : false;
          var state;
          if (typeof value == "function") {
            if (typeof key == "string" && !has$2(value, "name")) {
              createNonEnumerableProperty(value, "name", key);
            }
            state = enforceInternalState(value);
            if (!state.source) {
              state.source = TEMPLATE.join(typeof key == "string" ? key : "");
            }
          }
          if (O === global_1) {
            if (simple) O[key] = value;
            else setGlobal(key, value);
            return;
          } else if (!unsafe) {
            delete O[key];
          } else if (!noTargetGet && O[key]) {
            simple = true;
          }
          if (simple) O[key] = value;
          else createNonEnumerableProperty(O, key, value);
        })(Function.prototype, "toString", function toString2() {
          return typeof this == "function" && getInternalState2(this).source || inspectSource(this);
        });
      });
      var path = global_1;
      var aFunction$1 = function(variable) {
        return typeof variable == "function" ? variable : void 0;
      };
      var getBuiltIn = function(namespace, method) {
        return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
      };
      var ceil = Math.ceil;
      var floor$1 = Math.floor;
      var toInteger = function(argument) {
        return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);
      };
      var min$6 = Math.min;
      var toLength = function(argument) {
        return argument > 0 ? min$6(toInteger(argument), 9007199254740991) : 0;
      };
      var max$4 = Math.max;
      var min$5 = Math.min;
      var toAbsoluteIndex = function(index2, length2) {
        var integer = toInteger(index2);
        return integer < 0 ? max$4(integer + length2, 0) : min$5(integer, length2);
      };
      var createMethod$2 = function(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length2 = toLength(O.length);
          var index2 = toAbsoluteIndex(fromIndex, length2);
          var value;
          if (IS_INCLUDES && el != el) while (length2 > index2) {
            value = O[index2++];
            if (value != value) return true;
          }
          else for (; length2 > index2; index2++) {
            if ((IS_INCLUDES || index2 in O) && O[index2] === el) return IS_INCLUDES || index2 || 0;
          }
          return !IS_INCLUDES && -1;
        };
      };
      var arrayIncludes = {
        // `Array.prototype.includes` method
        // https://tc39.es/ecma262/#sec-array.prototype.includes
        includes: createMethod$2(true),
        // `Array.prototype.indexOf` method
        // https://tc39.es/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod$2(false)
      };
      var arrayIncludes_1 = arrayIncludes.includes;
      var arrayIncludes_2 = arrayIncludes.indexOf;
      var indexOf = arrayIncludes.indexOf;
      var objectKeysInternal = function(object, names) {
        var O = toIndexedObject(object);
        var i = 0;
        var result2 = [];
        var key;
        for (key in O) !has$2(hiddenKeys$1, key) && has$2(O, key) && result2.push(key);
        while (names.length > i) if (has$2(O, key = names[i++])) {
          ~indexOf(result2, key) || result2.push(key);
        }
        return result2;
      };
      var enumBugKeys = [
        "constructor",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "toLocaleString",
        "toString",
        "valueOf"
      ];
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      var f$1 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return objectKeysInternal(O, hiddenKeys);
      };
      var objectGetOwnPropertyNames = {
        f: f$1
      };
      var f = Object.getOwnPropertySymbols;
      var objectGetOwnPropertySymbols = {
        f
      };
      var ownKeys = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
        var keys2 = objectGetOwnPropertyNames.f(anObject(it));
        var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
        return getOwnPropertySymbols ? keys2.concat(getOwnPropertySymbols(it)) : keys2;
      };
      var copyConstructorProperties = function(target, source) {
        var keys2 = ownKeys(source);
        var defineProperty2 = objectDefineProperty.f;
        var getOwnPropertyDescriptor2 = objectGetOwnPropertyDescriptor.f;
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          if (!has$2(target, key)) defineProperty2(target, key, getOwnPropertyDescriptor2(source, key));
        }
      };
      var replacement = /#|\.prototype\./;
      var isForced = function(feature, detection) {
        var value = data$1[normalize(feature)];
        return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data$1 = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      var isForced_1 = isForced;
      var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
      var _export = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global_1;
        } else if (STATIC) {
          target = global_1[TARGET] || setGlobal(TARGET, {});
        } else {
          target = (global_1[TARGET] || {}).prototype;
        }
        if (target) for (key in source) {
          sourceProperty = source[key];
          if (options.noTargetGet) {
            descriptor = getOwnPropertyDescriptor$1(target, key);
            targetProperty = descriptor && descriptor.value;
          } else targetProperty = target[key];
          FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty === typeof targetProperty) continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          redefine(target, key, sourceProperty, options);
        }
      };
      var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function() {
        return !String(Symbol());
      });
      var useSymbolAsUid = nativeSymbol && !Symbol.sham && typeof Symbol.iterator == "symbol";
      var WellKnownSymbolsStore = shared("wks");
      var Symbol$1 = global_1.Symbol;
      var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
      var wellKnownSymbol = function(name) {
        if (!has$2(WellKnownSymbolsStore, name)) {
          if (nativeSymbol && has$2(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
          else WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
      var objectKeys = Object.keys || function keys2(O) {
        return objectKeysInternal(O, enumBugKeys);
      };
      var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys2 = objectKeys(Properties);
        var length2 = keys2.length;
        var index2 = 0;
        var key;
        while (length2 > index2) objectDefineProperty.f(O, key = keys2[index2++], Properties[key]);
        return O;
      };
      var html$1 = getBuiltIn("document", "documentElement");
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO$1 = sharedKey("IE_PROTO");
      var EmptyConstructor = function() {
      };
      var scriptTag = function(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html$1.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var NullProtoObject = function() {
        try {
          activeXDocument = document.domain && new ActiveXObject("htmlfile");
        } catch (error) {
        }
        NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
        var length2 = enumBugKeys.length;
        while (length2--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length2]];
        return NullProtoObject();
      };
      hiddenKeys$1[IE_PROTO$1] = true;
      var objectCreate = Object.create || function create(O, Properties) {
        var result2;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result2 = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result2[IE_PROTO$1] = O;
        } else result2 = NullProtoObject();
        return Properties === void 0 ? result2 : objectDefineProperties(result2, Properties);
      };
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype$1 = Array.prototype;
      if (ArrayPrototype$1[UNSCOPABLES] == void 0) {
        objectDefineProperty.f(ArrayPrototype$1, UNSCOPABLES, {
          configurable: true,
          value: objectCreate(null)
        });
      }
      var addToUnscopables = function(key) {
        ArrayPrototype$1[UNSCOPABLES][key] = true;
      };
      var defineProperty$1 = Object.defineProperty;
      var cache = {};
      var thrower = function(it) {
        throw it;
      };
      var arrayMethodUsesToLength = function(METHOD_NAME, options) {
        if (has$2(cache, METHOD_NAME)) return cache[METHOD_NAME];
        if (!options) options = {};
        var method = [][METHOD_NAME];
        var ACCESSORS = has$2(options, "ACCESSORS") ? options.ACCESSORS : false;
        var argument0 = has$2(options, 0) ? options[0] : thrower;
        var argument1 = has$2(options, 1) ? options[1] : void 0;
        return cache[METHOD_NAME] = !!method && !fails(function() {
          if (ACCESSORS && !descriptors) return true;
          var O = { length: -1 };
          if (ACCESSORS) defineProperty$1(O, 1, { enumerable: true, get: thrower });
          else O[1] = 1;
          method.call(O, argument0, argument1);
        });
      };
      "use strict";
      var $includes = arrayIncludes.includes;
      var USES_TO_LENGTH$2 = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
      _export({ target: "Array", proto: true, forced: !USES_TO_LENGTH$2 }, {
        includes: function includes2(el) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables("includes");
      var es_array_includes = {};
      var aFunction = function(it) {
        if (typeof it != "function") {
          throw TypeError(String(it) + " is not a function");
        }
        return it;
      };
      var functionBindContext = function(fn2, that, length2) {
        aFunction(fn2);
        if (that === void 0) return fn2;
        switch (length2) {
          case 0:
            return function() {
              return fn2.call(that);
            };
          case 1:
            return function(a) {
              return fn2.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn2.call(that, a, b);
            };
          case 3:
            return function(a, b, c) {
              return fn2.call(that, a, b, c);
            };
        }
        return function() {
          return fn2.apply(that, arguments);
        };
      };
      var call = Function.call;
      var entryUnbind = function(CONSTRUCTOR, METHOD, length2) {
        return functionBindContext(call, global_1[CONSTRUCTOR].prototype[METHOD], length2);
      };
      var includes$3 = entryUnbind("Array", "includes");
      var includes$2 = includes$3;
      var toObject = function(argument) {
        return Object(requireObjectCoercible(argument));
      };
      var isArray = Array.isArray || function isArray2(arg) {
        return classofRaw(arg) == "Array";
      };
      var SPECIES = wellKnownSymbol("species");
      var arraySpeciesCreate = function(originalArray, length2) {
        var C;
        if (isArray(originalArray)) {
          C = originalArray.constructor;
          if (typeof C == "function" && (C === Array || isArray(C.prototype))) C = void 0;
          else if (isObject$1(C)) {
            C = C[SPECIES];
            if (C === null) C = void 0;
          }
        }
        return new (C === void 0 ? Array : C)(length2 === 0 ? 0 : length2);
      };
      var push = [].push;
      var createMethod$1 = function(TYPE) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var IS_FILTER_OUT = TYPE == 7;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = indexedObject(O);
          var boundFunction = functionBindContext(callbackfn, that, 3);
          var length2 = toLength(self2.length);
          var index2 = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length2) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0;
          var value, result2;
          for (; length2 > index2; index2++) if (NO_HOLES || index2 in self2) {
            value = self2[index2];
            result2 = boundFunction(value, index2, O);
            if (TYPE) {
              if (IS_MAP) target[index2] = result2;
              else if (result2) switch (TYPE) {
                case 3:
                  return true;
                // some
                case 5:
                  return value;
                // find
                case 6:
                  return index2;
                // findIndex
                case 2:
                  push.call(target, value);
              }
              else switch (TYPE) {
                case 4:
                  return false;
                // every
                case 7:
                  push.call(target, value);
              }
            }
          }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      var arrayIteration = {
        // `Array.prototype.forEach` method
        // https://tc39.es/ecma262/#sec-array.prototype.foreach
        forEach: createMethod$1(0),
        // `Array.prototype.map` method
        // https://tc39.es/ecma262/#sec-array.prototype.map
        map: createMethod$1(1),
        // `Array.prototype.filter` method
        // https://tc39.es/ecma262/#sec-array.prototype.filter
        filter: createMethod$1(2),
        // `Array.prototype.some` method
        // https://tc39.es/ecma262/#sec-array.prototype.some
        some: createMethod$1(3),
        // `Array.prototype.every` method
        // https://tc39.es/ecma262/#sec-array.prototype.every
        every: createMethod$1(4),
        // `Array.prototype.find` method
        // https://tc39.es/ecma262/#sec-array.prototype.find
        find: createMethod$1(5),
        // `Array.prototype.findIndex` method
        // https://tc39.es/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod$1(6),
        // `Array.prototype.filterOut` method
        // https://github.com/tc39/proposal-array-filtering
        filterOut: createMethod$1(7)
      };
      var arrayIteration_1 = arrayIteration.forEach;
      var arrayIteration_2 = arrayIteration.map;
      var arrayIteration_3 = arrayIteration.filter;
      var arrayIteration_4 = arrayIteration.some;
      var arrayIteration_5 = arrayIteration.every;
      var arrayIteration_6 = arrayIteration.find;
      var arrayIteration_7 = arrayIteration.findIndex;
      var arrayIteration_8 = arrayIteration.filterOut;
      "use strict";
      var $find = arrayIteration.find;
      var FIND = "find";
      var SKIPS_HOLES$1 = true;
      var USES_TO_LENGTH$1 = arrayMethodUsesToLength(FIND);
      if (FIND in []) Array(1)[FIND](function() {
        SKIPS_HOLES$1 = false;
      });
      _export({ target: "Array", proto: true, forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$1 }, {
        find: function find2(callbackfn) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND);
      var es_array_find = {};
      var find$1 = entryUnbind("Array", "find");
      var find = find$1;
      var createMethod = function(CONVERT_TO_STRING) {
        return function($this, pos) {
          var S = String(requireObjectCoercible($this));
          var position2 = toInteger(pos);
          var size = S.length;
          var first, second;
          if (position2 < 0 || position2 >= size) return CONVERT_TO_STRING ? "" : void 0;
          first = S.charCodeAt(position2);
          return first < 55296 || first > 56319 || position2 + 1 === size || (second = S.charCodeAt(position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position2) : first : CONVERT_TO_STRING ? S.slice(position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
        };
      };
      var stringMultibyte = {
        // `String.prototype.codePointAt` method
        // https://tc39.es/ecma262/#sec-string.prototype.codepointat
        codeAt: createMethod(false),
        // `String.prototype.at` method
        // https://github.com/mathiasbynens/String.prototype.at
        charAt: createMethod(true)
      };
      var stringMultibyte_1 = stringMultibyte.codeAt;
      var stringMultibyte_2 = stringMultibyte.charAt;
      var correctPrototypeGetter = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
      var IE_PROTO = sharedKey("IE_PROTO");
      var ObjectPrototype = Object.prototype;
      var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function(O) {
        O = toObject(O);
        if (has$2(O, IE_PROTO)) return O[IE_PROTO];
        if (typeof O.constructor == "function" && O instanceof O.constructor) {
          return O.constructor.prototype;
        }
        return O instanceof Object ? ObjectPrototype : null;
      };
      "use strict";
      var ITERATOR$4 = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS$1 = false;
      var returnThis$2 = function() {
        return this;
      };
      var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
        else {
          PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
        }
      }
      var NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == void 0 || fails(function() {
        var test2 = {};
        return IteratorPrototype$2[ITERATOR$4].call(test2) !== test2;
      });
      if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};
      if ((!isPure || NEW_ITERATOR_PROTOTYPE) && !has$2(IteratorPrototype$2, ITERATOR$4)) {
        createNonEnumerableProperty(IteratorPrototype$2, ITERATOR$4, returnThis$2);
      }
      var iteratorsCore = {
        IteratorPrototype: IteratorPrototype$2,
        BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
      };
      var iteratorsCore_1 = iteratorsCore.IteratorPrototype;
      var iteratorsCore_2 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
      var defineProperty = objectDefineProperty.f;
      var TO_STRING_TAG$2 = wellKnownSymbol("toStringTag");
      var setToStringTag = function(it, TAG, STATIC) {
        if (it && !has$2(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
          defineProperty(it, TO_STRING_TAG$2, { configurable: true, value: TAG });
        }
      };
      var iterators = {};
      "use strict";
      var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
      var returnThis$1 = function() {
        return this;
      };
      var createIteratorConstructor = function(IteratorConstructor, NAME, next) {
        var TO_STRING_TAG2 = NAME + " Iterator";
        IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG2, false, true);
        iterators[TO_STRING_TAG2] = returnThis$1;
        return IteratorConstructor;
      };
      var aPossiblePrototype = function(it) {
        if (!isObject$1(it) && it !== null) {
          throw TypeError("Can't set " + String(it) + " as a prototype");
        }
        return it;
      };
      var objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
        var CORRECT_SETTER = false;
        var test2 = {};
        var setter;
        try {
          setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
          setter.call(test2, []);
          CORRECT_SETTER = test2 instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O, proto) {
          anObject(O);
          aPossiblePrototype(proto);
          if (CORRECT_SETTER) setter.call(O, proto);
          else O.__proto__ = proto;
          return O;
        };
      })() : void 0);
      "use strict";
      var IteratorPrototype = iteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = iteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR$3 = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function() {
        return this;
      };
      var defineIterator = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function(KIND) {
          if (KIND === DEFAULT && defaultIterator) return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys2() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values2() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG2 = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR$3] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods2, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!isPure && objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (objectSetPrototypeOf) {
                objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (typeof CurrentIteratorPrototype[ITERATOR$3] != "function") {
                createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$3, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG2, true, true);
            if (isPure) iterators[TO_STRING_TAG2] = returnThis;
          }
        }
        if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values2() {
            return nativeIterator.call(this);
          };
        }
        if ((!isPure || FORCED) && IterablePrototype[ITERATOR$3] !== defaultIterator) {
          createNonEnumerableProperty(IterablePrototype, ITERATOR$3, defaultIterator);
        }
        iterators[NAME] = defaultIterator;
        if (DEFAULT) {
          methods2 = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
          };
          if (FORCED) for (KEY in methods2) {
            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
              redefine(IterablePrototype, KEY, methods2[KEY]);
            }
          }
          else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods2);
        }
        return methods2;
      };
      "use strict";
      var charAt = stringMultibyte.charAt;
      var STRING_ITERATOR = "String Iterator";
      var setInternalState = internalState.set;
      var getInternalState = internalState.getterFor(STRING_ITERATOR);
      defineIterator(String, "String", function(iterated) {
        setInternalState(this, {
          type: STRING_ITERATOR,
          string: String(iterated),
          index: 0
        });
      }, function next() {
        var state = getInternalState(this);
        var string = state.string;
        var index2 = state.index;
        var point2;
        if (index2 >= string.length) return { value: void 0, done: true };
        point2 = charAt(string, index2);
        state.index += point2.length;
        return { value: point2, done: false };
      });
      var es_string_iterator = {};
      var iteratorClose = function(iterator) {
        var returnMethod = iterator["return"];
        if (returnMethod !== void 0) {
          return anObject(returnMethod.call(iterator)).value;
        }
      };
      var callWithSafeIterationClosing = function(iterator, fn2, value, ENTRIES2) {
        try {
          return ENTRIES2 ? fn2(anObject(value)[0], value[1]) : fn2(value);
        } catch (error) {
          iteratorClose(iterator);
          throw error;
        }
      };
      var ITERATOR$2 = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      var isArrayIteratorMethod = function(it) {
        return it !== void 0 && (iterators.Array === it || ArrayPrototype[ITERATOR$2] === it);
      };
      "use strict";
      var createProperty = function(object, key, value) {
        var propertyKey = toPrimitive(key);
        if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
        else object[propertyKey] = value;
      };
      var TO_STRING_TAG$1 = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG$1] = "z";
      var toStringTagSupport = String(test) === "[object z]";
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
        return arguments;
      })()) == "Arguments";
      var tryGet = function(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      var classof = toStringTagSupport ? classofRaw : function(it) {
        var O, tag, result2;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result2 = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result2;
      };
      var ITERATOR$1 = wellKnownSymbol("iterator");
      var getIteratorMethod = function(it) {
        if (it != void 0) return it[ITERATOR$1] || it["@@iterator"] || iterators[classof(it)];
      };
      "use strict";
      var arrayFrom = function from(arrayLike) {
        var O = toObject(arrayLike);
        var C = typeof this == "function" ? this : Array;
        var argumentsLength = arguments.length;
        var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
        var mapping = mapfn !== void 0;
        var iteratorMethod = getIteratorMethod(O);
        var index2 = 0;
        var length2, result2, step, iterator, next, value;
        if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
        if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
          iterator = iteratorMethod.call(O);
          next = iterator.next;
          result2 = new C();
          for (; !(step = next.call(iterator)).done; index2++) {
            value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
            createProperty(result2, index2, value);
          }
        } else {
          length2 = toLength(O.length);
          result2 = new C(length2);
          for (; length2 > index2; index2++) {
            value = mapping ? mapfn(O[index2], index2) : O[index2];
            createProperty(result2, index2, value);
          }
        }
        result2.length = index2;
        return result2;
      };
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        var called = 0;
        var iteratorWithReturn = {
          next: function() {
            return { done: !!called++ };
          },
          "return": function() {
            SAFE_CLOSING = true;
          }
        };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      var checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return {
              next: function() {
                return { done: ITERATION_SUPPORT = true };
              }
            };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
      var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
        Array.from(iterable);
      });
      _export({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
        from: arrayFrom
      });
      var es_array_from = {};
      var from_1$1 = path.Array.from;
      var from_1 = from_1$1;
      "use strict";
      var $findIndex = arrayIteration.findIndex;
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
      if (FIND_INDEX in []) Array(1)[FIND_INDEX](function() {
        SKIPS_HOLES = false;
      });
      _export({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
        findIndex: function findIndex2(callbackfn) {
          return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      addToUnscopables(FIND_INDEX);
      var es_array_findIndex = {};
      var findIndex$1 = entryUnbind("Array", "findIndex");
      var findIndex = findIndex$1;
      var base64 = createCommonjsModule(function(module2, exports3) {
        (function() {
          var object = true ? exports3 : this;
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          function InvalidCharacterError(message) {
            this.message = message;
          }
          InvalidCharacterError.prototype = new Error();
          InvalidCharacterError.prototype.name = "InvalidCharacterError";
          object.btoa || (object.btoa = function(input) {
            var str = String(input);
            for (
              var block, charCode, idx = 0, map = chars, output = "";
              // if the next str index does not exist:
              //   change the mapping table to "="
              //   check if d has no fractional digits
              str.charAt(idx | 0) || (map = "=", idx % 1);
              // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
              output += map.charAt(63 & block >> 8 - idx % 1 * 8)
            ) {
              charCode = str.charCodeAt(idx += 3 / 4);
              if (charCode > 255) {
                throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
              }
              block = block << 8 | charCode;
            }
            return output;
          });
          object.atob || (object.atob = function(input) {
            var str = String(input).replace(/=+$/, "");
            if (str.length % 4 == 1) {
              throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
            }
            for (
              var bc = 0, bs, buffer, idx = 0, output = "";
              // get next character
              // eslint-disable-next-line no-cond-assign
              buffer = str.charAt(idx++);
              // character found in table? initialize bit storage and add its ascii value;
              ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
              // convert the first 8 bits to one ascii character
              bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
            ) {
              buffer = chars.indexOf(buffer);
            }
            return output;
          });
        })();
      });
      _export({ target: "Number", stat: true }, {
        isNaN: function isNaN2(number) {
          return number != number;
        }
      });
      var es_number_isNan = {};
      var isNan$1 = path.Number.isNaN;
      var isNan = isNan$1;
      var globalIsFinite = global_1.isFinite;
      var numberIsFinite = Number.isFinite || function isFinite2(it) {
        return typeof it == "number" && globalIsFinite(it);
      };
      _export({ target: "Number", stat: true }, { isFinite: numberIsFinite });
      var es_number_isFinite = {};
      var _isFinite$1 = path.Number.isFinite;
      var _isFinite = _isFinite$1;
      var MATCH$1 = wellKnownSymbol("match");
      var isRegexp = function(it) {
        var isRegExp;
        return isObject$1(it) && ((isRegExp = it[MATCH$1]) !== void 0 ? !!isRegExp : classofRaw(it) == "RegExp");
      };
      var notARegexp = function(it) {
        if (isRegexp(it)) {
          throw TypeError("The method doesn't accept regular expressions");
        }
        return it;
      };
      var MATCH = wellKnownSymbol("match");
      var correctIsRegexpLogic = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (error1) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (error2) {
          }
        }
        return false;
      };
      "use strict";
      _export({ target: "String", proto: true, forced: !correctIsRegexpLogic("includes") }, {
        includes: function includes2(searchString) {
          return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : void 0);
        }
      });
      var es_string_includes = {};
      var includes$1 = entryUnbind("String", "includes");
      var includes = includes$1;
      "use strict";
      var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
      var nativeStartsWith = "".startsWith;
      var min$4 = Math.min;
      var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic("startsWith");
      var MDN_POLYFILL_BUG = !isPure && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
        var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
        return descriptor && !descriptor.writable;
      })();
      _export({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
        startsWith: function startsWith2(searchString) {
          var that = String(requireObjectCoercible(this));
          notARegexp(searchString);
          var index2 = toLength(min$4(arguments.length > 1 ? arguments[1] : void 0, that.length));
          var search = String(searchString);
          return nativeStartsWith ? nativeStartsWith.call(that, search, index2) : that.slice(index2, index2 + search.length) === search;
        }
      });
      var es_string_startsWith = {};
      var startsWith$1 = entryUnbind("String", "startsWith");
      var startsWith = startsWith$1;
      (function() {
        if (typeof Uint8Array !== "undefined" || typeof window === "undefined") {
          return;
        }
        function subarray(start, end) {
          return this.slice(start, end);
        }
        function set_(array, offset2) {
          if (arguments.length < 2) {
            offset2 = 0;
          }
          for (var i = 0, n = array.length; i < n; ++i, ++offset2) {
            this[offset2] = array[i] & 255;
          }
        }
        function TypedArray(arg1) {
          var result2;
          if (typeof arg1 === "number") {
            result2 = new Array(arg1);
            for (var i = 0; i < arg1; ++i) {
              result2[i] = 0;
            }
          } else {
            result2 = arg1.slice(0);
          }
          result2.subarray = subarray;
          result2.buffer = result2;
          result2.byteLength = result2.length;
          result2.set = set_;
          if (typeof arg1 === "object" && arg1.buffer) {
            result2.buffer = arg1.buffer;
          }
          return result2;
        }
        window.Uint8Array = TypedArray;
        window.Uint32Array = TypedArray;
        window.Int32Array = TypedArray;
      })();
      const {
        round: round$4,
        floor,
        PI: PI$1
      } = Math;
      const scale = {
        // Return the `value` from the `domain` interval scaled to the `range` interval.
        linear: function(domain, range, value) {
          var domainSpan = domain[1] - domain[0];
          var rangeSpan = range[1] - range[0];
          return (value - domain[0]) / domainSpan * rangeSpan + range[0] || 0;
        }
      };
      const normalizeAngle = function(angle) {
        return angle % 360 + (angle < 0 ? 360 : 0);
      };
      const snapToGrid$1 = function(value, gridSize) {
        return gridSize * round$4(value / gridSize);
      };
      const toDeg = function(rad) {
        return 180 * rad / PI$1 % 360;
      };
      const toRad = function(deg, over360) {
        over360 = over360 || false;
        deg = over360 ? deg : deg % 360;
        return deg * PI$1 / 180;
      };
      const random = function(min2, max2) {
        if (max2 === void 0) {
          max2 = min2 === void 0 ? 1 : min2;
          min2 = 0;
        } else if (max2 < min2) {
          const temp = min2;
          min2 = max2;
          max2 = temp;
        }
        return floor(Math.random() * (max2 - min2 + 1) + min2);
      };
      const {
        cos: cos$2,
        sin: sin$2,
        atan2: atan2$1
      } = Math;
      const bearing = function(p, q) {
        var lat1 = toRad(p.y);
        var lat2 = toRad(q.y);
        var lon1 = p.x;
        var lon2 = q.x;
        var dLon = toRad(lon2 - lon1);
        var y = sin$2(dLon) * cos$2(lat2);
        var x = cos$2(lat1) * sin$2(lat2) - sin$2(lat1) * cos$2(lat2) * cos$2(dLon);
        var brng = toDeg(atan2$1(y, x));
        var bearings = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
        var index2 = brng - 22.5;
        if (index2 < 0) index2 += 360;
        index2 = parseInt(index2 / 45);
        return bearings[index2];
      };
      const squaredLength = function(start, end) {
        var x0 = start.x;
        var y0 = start.y;
        var x1 = end.x;
        var y1 = end.y;
        return (x0 -= x1) * x0 + (y0 -= y1) * y0;
      };
      const length = function(start, end) {
        return Math.sqrt(squaredLength(start, end));
      };
      const types = {
        Point: 1,
        Line: 2,
        Ellipse: 3,
        Rect: 4,
        Polyline: 5,
        Polygon: 6,
        Curve: 7,
        Path: 8
      };
      const {
        abs: abs$2,
        cos: cos$1,
        sin: sin$1,
        sqrt: sqrt$2,
        min: min$3,
        max: max$3,
        atan2,
        round: round$3,
        pow: pow$3,
        PI
      } = Math;
      const Point = function(x, y) {
        if (!(this instanceof Point)) {
          return new Point(x, y);
        }
        if (typeof x === "string") {
          var xy = x.split(x.indexOf("@") === -1 ? " " : "@");
          x = parseFloat(xy[0]);
          y = parseFloat(xy[1]);
        } else if (Object(x) === x) {
          y = x.y;
          x = x.x;
        }
        this.x = x === void 0 ? 0 : x;
        this.y = y === void 0 ? 0 : y;
      };
      Point.fromPolar = function(distance, angle, origin) {
        origin = new Point(origin);
        var x = abs$2(distance * cos$1(angle));
        var y = abs$2(distance * sin$1(angle));
        var deg = normalizeAngle(toDeg(angle));
        if (deg < 90) {
          y = -y;
        } else if (deg < 180) {
          x = -x;
          y = -y;
        } else if (deg < 270) {
          x = -x;
        }
        return new Point(origin.x + x, origin.y + y);
      };
      Point.random = function(x1, x2, y1, y2) {
        return new Point(random(x1, x2), random(y1, y2));
      };
      Point.prototype = {
        type: types.Point,
        chooseClosest: function(points) {
          var n = points.length;
          if (n === 1) return new Point(points[0]);
          var closest2 = null;
          var minSqrDistance = Infinity;
          for (var i = 0; i < n; i++) {
            var p = new Point(points[i]);
            var sqrDistance = this.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
              closest2 = p;
              minSqrDistance = sqrDistance;
            }
          }
          return closest2;
        },
        // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,
        // otherwise return point itself.
        // (see Squeak Smalltalk, Point>>adhereTo:)
        adhereToRect: function(r) {
          if (r.containsPoint(this)) {
            return this;
          }
          this.x = min$3(max$3(this.x, r.x), r.x + r.width);
          this.y = min$3(max$3(this.y, r.y), r.y + r.height);
          return this;
        },
        // Compute the angle between vector from me to p1 and the vector from me to p2.
        // ordering of points p1 and p2 is important!
        // theta function's angle convention:
        // returns angles between 0 and 180 when the angle is counterclockwise
        // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones
        // returns NaN if any of the points p1, p2 is coincident with this point
        angleBetween: function(p1, p2) {
          var angleBetween = this.equals(p1) || this.equals(p2) ? NaN : this.theta(p2) - this.theta(p1);
          if (angleBetween < 0) {
            angleBetween += 360;
          }
          return angleBetween;
        },
        // Return the bearing between me and the given point.
        bearing: function(point2) {
          return bearing(this, point2);
        },
        // Returns change in angle from my previous position (-dx, -dy) to my new position
        // relative to ref point.
        changeInAngle: function(dx, dy, ref) {
          return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);
        },
        clone: function() {
          return new Point(this);
        },
        // Returns the cross product of this point relative to two other points
        // this point is the common point
        // point p1 lies on the first vector, point p2 lies on the second vector
        // watch out for the ordering of points p1 and p2!
        // positive result indicates a clockwise ("right") turn from first to second vector
        // negative result indicates a counterclockwise ("left") turn from first to second vector
        // zero indicates that the first and second vector are collinear
        // note that the above directions are reversed from the usual answer on the Internet
        // that is because we are in a left-handed coord system (because the y-axis points downward)
        cross: function(p1, p2) {
          return p1 && p2 ? (p2.x - this.x) * (p1.y - this.y) - (p2.y - this.y) * (p1.x - this.x) : NaN;
        },
        difference: function(dx, dy) {
          if (Object(dx) === dx) {
            dy = dx.y;
            dx = dx.x;
          }
          return new Point(this.x - (dx || 0), this.y - (dy || 0));
        },
        // Returns distance between me and point `p`.
        distance: function(p) {
          return length(this, p);
        },
        // Returns the dot product of this point with given other point
        dot: function(p) {
          return p ? this.x * p.x + this.y * p.y : NaN;
        },
        equals: function(p) {
          return !!p && this.x === p.x && this.y === p.y;
        },
        // Linear interpolation
        lerp: function(p, t) {
          var x = this.x;
          var y = this.y;
          return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);
        },
        magnitude: function() {
          return sqrt$2(this.x * this.x + this.y * this.y) || 0.01;
        },
        // Returns a manhattan (taxi-cab) distance between me and point `p`.
        manhattanDistance: function(p) {
          return abs$2(p.x - this.x) + abs$2(p.y - this.y);
        },
        // Move point on line starting from ref ending at me by
        // distance distance.
        move: function(ref, distance) {
          var theta = toRad(new Point(ref).theta(this));
          var offset2 = this.offset(cos$1(theta) * distance, -sin$1(theta) * distance);
          return offset2;
        },
        // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.
        normalize: function(length2) {
          var scale2 = (length2 || 1) / this.magnitude();
          return this.scale(scale2, scale2);
        },
        // Offset me by the specified amount.
        offset: function(dx, dy) {
          if (Object(dx) === dx) {
            dy = dx.y;
            dx = dx.x;
          }
          this.x += dx || 0;
          this.y += dy || 0;
          return this;
        },
        // Returns a point that is the reflection of me with
        // the center of inversion in ref point.
        reflection: function(ref) {
          return new Point(ref).move(this, this.distance(ref));
        },
        // Rotate point by angle around origin.
        // Angle is flipped because this is a left-handed coord system (y-axis points downward).
        rotate: function(origin, angle) {
          if (angle === 0) return this;
          origin = origin || new Point(0, 0);
          angle = toRad(normalizeAngle(-angle));
          var cosAngle = cos$1(angle);
          var sinAngle = sin$1(angle);
          var x = cosAngle * (this.x - origin.x) - sinAngle * (this.y - origin.y) + origin.x;
          var y = sinAngle * (this.x - origin.x) + cosAngle * (this.y - origin.y) + origin.y;
          this.x = x;
          this.y = y;
          return this;
        },
        round: function(precision) {
          let f2 = 1;
          if (precision) {
            switch (precision) {
              case 1:
                f2 = 10;
                break;
              case 2:
                f2 = 100;
                break;
              case 3:
                f2 = 1e3;
                break;
              default:
                f2 = pow$3(10, precision);
                break;
            }
          }
          this.x = round$3(this.x * f2) / f2;
          this.y = round$3(this.y * f2) / f2;
          return this;
        },
        // Scale point with origin.
        scale: function(sx, sy, origin) {
          origin = origin && new Point(origin) || new Point(0, 0);
          this.x = origin.x + sx * (this.x - origin.x);
          this.y = origin.y + sy * (this.y - origin.y);
          return this;
        },
        snapToGrid: function(gx, gy) {
          this.x = snapToGrid$1(this.x, gx);
          this.y = snapToGrid$1(this.y, gy || gx);
          return this;
        },
        squaredDistance: function(p) {
          return squaredLength(this, p);
        },
        // Compute the angle between me and `p` and the x axis.
        // (cartesian-to-polar coordinates conversion)
        // Return theta angle in degrees.
        theta: function(p) {
          p = new Point(p);
          var y = -(p.y - this.y);
          var x = p.x - this.x;
          var rad = atan2(y, x);
          if (rad < 0) {
            rad = 2 * PI + rad;
          }
          return 180 * rad / PI;
        },
        toJSON: function() {
          return {
            x: this.x,
            y: this.y
          };
        },
        // Converts rectangular to polar coordinates.
        // An origin can be specified, otherwise it's 0@0.
        toPolar: function(o) {
          o = o && new Point(o) || new Point(0, 0);
          var x = this.x;
          var y = this.y;
          this.x = sqrt$2((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y));
          this.y = toRad(o.theta(new Point(x, y)));
          return this;
        },
        toString: function() {
          return this.x + "@" + this.y;
        },
        serialize: function() {
          return this.x + "," + this.y;
        },
        update: function(x, y) {
          if (Object(x) === x) {
            y = x.y;
            x = x.x;
          }
          this.x = x || 0;
          this.y = y || 0;
          return this;
        },
        // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.
        // Returns NaN if p is at 0,0.
        vectorAngle: function(p) {
          var zero = new Point(0, 0);
          return zero.angleBetween(this, p);
        }
      };
      Point.prototype.translate = Point.prototype.offset;
      const point = Point;
      const {
        max: max$2,
        min: min$2
      } = Math;
      const Line = function(p1, p2) {
        if (!(this instanceof Line)) {
          return new Line(p1, p2);
        }
        if (p1 instanceof Line) {
          return new Line(p1.start, p1.end);
        }
        this.start = new Point(p1);
        this.end = new Point(p2);
      };
      Line.prototype = {
        type: types.Line,
        // @returns the angle of incline of the line.
        angle: function() {
          var horizontalPoint = new Point(this.start.x + 1, this.start.y);
          return this.start.angleBetween(this.end, horizontalPoint);
        },
        bbox: function() {
          var left2 = min$2(this.start.x, this.end.x);
          var top2 = min$2(this.start.y, this.end.y);
          var right2 = max$2(this.start.x, this.end.x);
          var bottom2 = max$2(this.start.y, this.end.y);
          return new Rect(left2, top2, right2 - left2, bottom2 - top2);
        },
        // @return the bearing (cardinal direction) of the line. For example N, W, or SE.
        // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.
        bearing: function() {
          return bearing(this.start, this.end);
        },
        clone: function() {
          return new Line(this.start, this.end);
        },
        // @return {point} the closest point on the line to point `p`
        closestPoint: function(p) {
          return this.pointAt(this.closestPointNormalizedLength(p));
        },
        closestPointLength: function(p) {
          return this.closestPointNormalizedLength(p) * this.length();
        },
        // @return {number} the normalized length of the closest point on the line to point `p`
        closestPointNormalizedLength: function(p) {
          var product = this.vector().dot(new Line(this.start, p).vector());
          var cpNormalizedLength = min$2(1, max$2(0, product / this.squaredLength()));
          if (cpNormalizedLength !== cpNormalizedLength) return 0;
          return cpNormalizedLength;
        },
        closestPointTangent: function(p) {
          return this.tangentAt(this.closestPointNormalizedLength(p));
        },
        // Returns `true` if the point lies on the line.
        containsPoint: function(p) {
          var start = this.start;
          var end = this.end;
          if (start.cross(p, end) !== 0) return false;
          var length2 = this.length();
          if (new Line(start, p).length() > length2) return false;
          if (new Line(p, end).length() > length2) return false;
          return true;
        },
        // Divides the line into two at requested `ratio` between 0 and 1.
        divideAt: function(ratio) {
          var dividerPoint = this.pointAt(ratio);
          return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
        },
        // Divides the line into two at requested `length`.
        divideAtLength: function(length2) {
          var dividerPoint = this.pointAtLength(length2);
          return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];
        },
        equals: function(l) {
          return !!l && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;
        },
        // @return {point} Point where I'm intersecting a line.
        // @return [point] Points where I'm intersecting a rectangle.
        // @see Squeak Smalltalk, LineSegment>>intersectionWith:
        intersect: function(shape, opt) {
          if (shape && shape.intersectionWithLine) {
            var intersection2 = shape.intersectionWithLine(this, opt);
            if (intersection2 && shape instanceof Line) {
              intersection2 = intersection2[0];
            }
            return intersection2;
          }
          return null;
        },
        intersectionWithLine: function(line2) {
          var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);
          var pt2Dir = new Point(line2.end.x - line2.start.x, line2.end.y - line2.start.y);
          var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;
          var deltaPt = new Point(line2.start.x - this.start.x, line2.start.y - this.start.y);
          var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;
          var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;
          if (det === 0 || alpha * det < 0 || beta * det < 0) {
            return null;
          }
          if (det > 0) {
            if (alpha > det || beta > det) {
              return null;
            }
          } else {
            if (alpha < det || beta < det) {
              return null;
            }
          }
          return [new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det)];
        },
        isDifferentiable: function() {
          return !this.start.equals(this.end);
        },
        // @return {double} length of the line
        length: function() {
          return length(this.start, this.end);
        },
        // @return {point} my midpoint
        midpoint: function() {
          return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
        },
        parallel: function(distance) {
          const l = this.clone();
          if (!this.isDifferentiable()) return l;
          const {
            start,
            end
          } = l;
          const eRef = start.clone().rotate(end, 270);
          const sRef = end.clone().rotate(start, 90);
          start.move(sRef, distance);
          end.move(eRef, distance);
          return l;
        },
        // @return {point} my point at 't' <0,1>
        pointAt: function(t) {
          var start = this.start;
          var end = this.end;
          if (t <= 0) return start.clone();
          if (t >= 1) return end.clone();
          return start.lerp(end, t);
        },
        pointAtLength: function(length2) {
          var start = this.start;
          var end = this.end;
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          var lineLength = this.length();
          if (length2 >= lineLength) return fromStart ? end.clone() : start.clone();
          return this.pointAt((fromStart ? length2 : lineLength - length2) / lineLength);
        },
        // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.
        pointOffset: function(p) {
          p = new Point(p);
          var start = this.start;
          var end = this.end;
          var determinant2 = (end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x);
          return determinant2 / this.length();
        },
        rotate: function(origin, angle) {
          this.start.rotate(origin, angle);
          this.end.rotate(origin, angle);
          return this;
        },
        round: function(precision) {
          this.start.round(precision);
          this.end.round(precision);
          return this;
        },
        scale: function(sx, sy, origin) {
          this.start.scale(sx, sy, origin);
          this.end.scale(sx, sy, origin);
          return this;
        },
        // @return {number} scale the line so that it has the requested length
        setLength: function(length2) {
          var currentLength = this.length();
          if (!currentLength) return this;
          var scaleFactor = length2 / currentLength;
          return this.scale(scaleFactor, scaleFactor, this.start);
        },
        // @return {integer} length without sqrt
        // @note for applications where the exact length is not necessary (e.g. compare only)
        squaredLength: function() {
          return squaredLength(this.start, this.end);
        },
        tangentAt: function(t) {
          if (!this.isDifferentiable()) return null;
          var start = this.start;
          var end = this.end;
          var tangentStart = this.pointAt(t);
          var tangentLine = new Line(start, end);
          tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
          return tangentLine;
        },
        tangentAtLength: function(length2) {
          if (!this.isDifferentiable()) return null;
          var start = this.start;
          var end = this.end;
          var tangentStart = this.pointAtLength(length2);
          var tangentLine = new Line(start, end);
          tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);
          return tangentLine;
        },
        toString: function() {
          return this.start.toString() + " " + this.end.toString();
        },
        serialize: function() {
          return this.start.serialize() + " " + this.end.serialize();
        },
        translate: function(tx, ty) {
          this.start.translate(tx, ty);
          this.end.translate(tx, ty);
          return this;
        },
        // @return vector {point} of the line
        vector: function() {
          return new Point(this.end.x - this.start.x, this.end.y - this.start.y);
        }
      };
      Line.prototype.intersection = Line.prototype.intersect;
      const line$1 = Line;
      const {
        sqrt: sqrt$1,
        round: round$2,
        pow: pow$2
      } = Math;
      const Ellipse$1 = function(c, a, b) {
        if (!(this instanceof Ellipse$1)) {
          return new Ellipse$1(c, a, b);
        }
        if (c instanceof Ellipse$1) {
          return new Ellipse$1(new Point(c.x, c.y), c.a, c.b);
        }
        c = new Point(c);
        this.x = c.x;
        this.y = c.y;
        this.a = a;
        this.b = b;
      };
      Ellipse$1.fromRect = function(rect2) {
        rect2 = new Rect(rect2);
        return new Ellipse$1(rect2.center(), rect2.width / 2, rect2.height / 2);
      };
      Ellipse$1.prototype = {
        type: types.Ellipse,
        bbox: function() {
          return new Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);
        },
        /**
         * @returns {g.Point}
         */
        center: function() {
          return new Point(this.x, this.y);
        },
        clone: function() {
          return new Ellipse$1(this);
        },
        /**
         * @param {g.Point} p
         * @returns {boolean}
         */
        containsPoint: function(p) {
          return this.normalizedDistance(p) <= 1;
        },
        equals: function(ellipse2) {
          return !!ellipse2 && ellipse2.x === this.x && ellipse2.y === this.y && ellipse2.a === this.a && ellipse2.b === this.b;
        },
        // inflate by dx and dy
        // @param dx {delta_x} representing additional size to x
        // @param dy {delta_y} representing additional size to y -
        // dy param is not required -> in that case y is sized by dx
        inflate: function(dx, dy) {
          if (dx === void 0) {
            dx = 0;
          }
          if (dy === void 0) {
            dy = dx;
          }
          this.a += 2 * dx;
          this.b += 2 * dy;
          return this;
        },
        intersectionWithLine: function(line2) {
          var intersections = [];
          var a1 = line2.start;
          var a2 = line2.end;
          var rx = this.a;
          var ry = this.b;
          var dir = line2.vector();
          var diff2 = a1.difference(new Point(this));
          var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));
          var mDiff = new Point(diff2.x / (rx * rx), diff2.y / (ry * ry));
          var a = dir.dot(mDir);
          var b = dir.dot(mDiff);
          var c = diff2.dot(mDiff) - 1;
          var d = b * b - a * c;
          if (d < 0) {
            return null;
          } else if (d > 0) {
            var root = sqrt$1(d);
            var ta = (-b - root) / a;
            var tb = (-b + root) / a;
            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {
              return null;
            } else {
              if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));
              if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));
            }
          } else {
            var t = -b / a;
            if (0 <= t && t <= 1) {
              intersections.push(a1.lerp(a2, t));
            } else {
              return null;
            }
          }
          return intersections;
        },
        // Find point on me where line from my center to
        // point p intersects my boundary.
        // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.
        intersectionWithLineFromCenterToPoint: function(p, angle) {
          p = new Point(p);
          if (angle) p.rotate(new Point(this.x, this.y), angle);
          var dx = p.x - this.x;
          var dy = p.y - this.y;
          var result2;
          if (dx === 0) {
            result2 = this.bbox().pointNearestToPoint(p);
            if (angle) return result2.rotate(new Point(this.x, this.y), -angle);
            return result2;
          }
          var m = dy / dx;
          var mSquared = m * m;
          var aSquared = this.a * this.a;
          var bSquared = this.b * this.b;
          var x = sqrt$1(1 / (1 / aSquared + mSquared / bSquared));
          x = dx < 0 ? -x : x;
          var y = m * x;
          result2 = new Point(this.x + x, this.y + y);
          if (angle) return result2.rotate(new Point(this.x, this.y), -angle);
          return result2;
        },
        /**
         * @param {g.Point} point
         * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside
         */
        normalizedDistance: function(point2) {
          var x0 = point2.x;
          var y0 = point2.y;
          var a = this.a;
          var b = this.b;
          var x = this.x;
          var y = this.y;
          return (x0 - x) * (x0 - x) / (a * a) + (y0 - y) * (y0 - y) / (b * b);
        },
        round: function(precision) {
          let f2 = 1;
          if (precision) {
            switch (precision) {
              case 1:
                f2 = 10;
                break;
              case 2:
                f2 = 100;
                break;
              case 3:
                f2 = 1e3;
                break;
              default:
                f2 = pow$2(10, precision);
                break;
            }
          }
          this.x = round$2(this.x * f2) / f2;
          this.y = round$2(this.y * f2) / f2;
          this.a = round$2(this.a * f2) / f2;
          this.b = round$2(this.b * f2) / f2;
          return this;
        },
        /** Compute angle between tangent and x axis
         * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.
         * @returns {number} angle between tangent and x axis
         */
        tangentTheta: function(p) {
          var refPointDelta = 30;
          var x0 = p.x;
          var y0 = p.y;
          var a = this.a;
          var b = this.b;
          var center2 = this.bbox().center();
          var m = center2.x;
          var n = center2.y;
          var q1 = x0 > center2.x + a / 2;
          var q3 = x0 < center2.x - a / 2;
          var y, x;
          if (q1 || q3) {
            y = x0 > center2.x ? y0 - refPointDelta : y0 + refPointDelta;
            x = a * a / (x0 - m) - a * a * (y0 - n) * (y - n) / (b * b * (x0 - m)) + m;
          } else {
            x = y0 > center2.y ? x0 + refPointDelta : x0 - refPointDelta;
            y = b * b / (y0 - n) - b * b * (x0 - m) * (x - m) / (a * a * (y0 - n)) + n;
          }
          return new Point(x, y).theta(p);
        },
        toString: function() {
          return new Point(this.x, this.y).toString() + " " + this.a + " " + this.b;
        }
      };
      const ellipse$1 = Ellipse$1;
      const {
        abs: abs$1,
        cos,
        sin,
        min: min$1,
        max: max$1,
        round: round$1,
        pow: pow$1
      } = Math;
      const Rect = function(x, y, w, h) {
        if (!(this instanceof Rect)) {
          return new Rect(x, y, w, h);
        }
        if (Object(x) === x) {
          y = x.y;
          w = x.width;
          h = x.height;
          x = x.x;
        }
        this.x = x === void 0 ? 0 : x;
        this.y = y === void 0 ? 0 : y;
        this.width = w === void 0 ? 0 : w;
        this.height = h === void 0 ? 0 : h;
      };
      Rect.fromEllipse = function(e) {
        e = new Ellipse$1(e);
        return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);
      };
      Rect.fromPointUnion = function(...points) {
        if (points.length === 0) return null;
        const p = new Point();
        let minX, minY, maxX, maxY;
        minX = minY = Infinity;
        maxX = maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
          p.update(points[i]);
          const x = p.x;
          const y = p.y;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
        return new Rect(minX, minY, maxX - minX, maxY - minY);
      };
      Rect.fromRectUnion = function(...rects) {
        if (rects.length === 0) return null;
        const r = new Rect();
        let minX, minY, maxX, maxY;
        minX = minY = Infinity;
        maxX = maxY = -Infinity;
        for (let i = 0; i < rects.length; i++) {
          r.update(rects[i]);
          const x = r.x;
          const y = r.y;
          const mX = x + r.width;
          const mY = y + r.height;
          if (x < minX) minX = x;
          if (mX > maxX) maxX = mX;
          if (y < minY) minY = y;
          if (mY > maxY) maxY = mY;
        }
        return new Rect(minX, minY, maxX - minX, maxY - minY);
      };
      Rect.prototype = {
        type: types.Rect,
        // Find my bounding box when I'm rotated with the center of rotation in the center of me.
        // @return r {rectangle} representing a bounding box
        bbox: function(angle) {
          return this.clone().rotateAroundCenter(angle);
        },
        rotateAroundCenter: function(angle) {
          if (!angle) return this;
          const {
            width: width2,
            height: height2
          } = this;
          const theta = toRad(angle);
          const st = abs$1(sin(theta));
          const ct = abs$1(cos(theta));
          const w = width2 * ct + height2 * st;
          const h = width2 * st + height2 * ct;
          this.x += (width2 - w) / 2;
          this.y += (height2 - h) / 2;
          this.width = w;
          this.height = h;
          return this;
        },
        bottomLeft: function() {
          return new Point(this.x, this.y + this.height);
        },
        bottomLine: function() {
          return new Line(this.bottomLeft(), this.bottomRight());
        },
        bottomMiddle: function() {
          return new Point(this.x + this.width / 2, this.y + this.height);
        },
        center: function() {
          return new Point(this.x + this.width / 2, this.y + this.height / 2);
        },
        clone: function() {
          return new Rect(this);
        },
        // @return {bool} true if point p is inside me.
        // @param {bool} strict If true, the point has to be strictly inside (not on the border).
        containsPoint: function(p, opt) {
          let x, y;
          if (!p || typeof p === "string") {
            ({
              x,
              y
            } = new Point(p));
          } else {
            ({
              x = 0,
              y = 0
            } = p);
          }
          return opt && opt.strict ? x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
        },
        // @return {bool} true if rectangle `r` is inside me.
        containsRect: function(r) {
          var r0 = new Rect(this).normalize();
          var r1 = new Rect(r).normalize();
          var w0 = r0.width;
          var h0 = r0.height;
          var w1 = r1.width;
          var h1 = r1.height;
          if (!w0 || !h0 || !w1 || !h1) {
            return false;
          }
          var x0 = r0.x;
          var y0 = r0.y;
          var x1 = r1.x;
          var y1 = r1.y;
          w1 += x1;
          w0 += x0;
          h1 += y1;
          h0 += y0;
          return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;
        },
        corner: function() {
          return new Point(this.x + this.width, this.y + this.height);
        },
        // @return {boolean} true if rectangles are equal.
        equals: function(r) {
          var mr = new Rect(this).normalize();
          var nr = new Rect(r).normalize();
          return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;
        },
        // inflate by dx and dy, recompute origin [x, y]
        // @param dx {delta_x} representing additional size to x
        // @param dy {delta_y} representing additional size to y -
        // dy param is not required -> in that case y is sized by dx
        inflate: function(dx, dy) {
          if (dx === void 0) {
            dx = 0;
          }
          if (dy === void 0) {
            dy = dx;
          }
          this.x -= dx;
          this.y -= dy;
          this.width += 2 * dx;
          this.height += 2 * dy;
          return this;
        },
        // @return {rect} if rectangles intersect, {null} if not.
        intersect: function(r) {
          var myOrigin = this.origin();
          var myCorner = this.corner();
          var rOrigin = r.origin();
          var rCorner = r.corner();
          if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) return null;
          var x = max$1(myOrigin.x, rOrigin.x);
          var y = max$1(myOrigin.y, rOrigin.y);
          return new Rect(x, y, min$1(myCorner.x, rCorner.x) - x, min$1(myCorner.y, rCorner.y) - y);
        },
        intersectionWithLine: function(line2) {
          var r = this;
          var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];
          var points = [];
          var dedupeArr = [];
          var pt, i;
          var n = rectLines.length;
          for (i = 0; i < n; i++) {
            pt = line2.intersect(rectLines[i]);
            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {
              points.push(pt);
              dedupeArr.push(pt.toString());
            }
          }
          return points.length > 0 ? points : null;
        },
        // Find point on my boundary where line starting
        // from my center ending in point p intersects me.
        // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.
        intersectionWithLineFromCenterToPoint: function(p, angle) {
          p = new Point(p);
          var center2 = new Point(this.x + this.width / 2, this.y + this.height / 2);
          var result2;
          if (angle) p.rotate(center2, angle);
          var sides = [this.topLine(), this.rightLine(), this.bottomLine(), this.leftLine()];
          var connector = new Line(center2, p);
          for (var i = sides.length - 1; i >= 0; --i) {
            var intersection2 = sides[i].intersection(connector);
            if (intersection2 !== null) {
              result2 = intersection2;
              break;
            }
          }
          if (result2 && angle) result2.rotate(center2, -angle);
          return result2;
        },
        leftLine: function() {
          return new Line(this.topLeft(), this.bottomLeft());
        },
        leftMiddle: function() {
          return new Point(this.x, this.y + this.height / 2);
        },
        maxRectScaleToFit: function(rect2, origin) {
          rect2 = new Rect(rect2);
          origin || (origin = rect2.center());
          var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;
          var ox = origin.x;
          var oy = origin.y;
          sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;
          var p1 = rect2.topLeft();
          if (p1.x < ox) {
            sx1 = (this.x - ox) / (p1.x - ox);
          }
          if (p1.y < oy) {
            sy1 = (this.y - oy) / (p1.y - oy);
          }
          var p2 = rect2.bottomRight();
          if (p2.x > ox) {
            sx2 = (this.x + this.width - ox) / (p2.x - ox);
          }
          if (p2.y > oy) {
            sy2 = (this.y + this.height - oy) / (p2.y - oy);
          }
          var p3 = rect2.topRight();
          if (p3.x > ox) {
            sx3 = (this.x + this.width - ox) / (p3.x - ox);
          }
          if (p3.y < oy) {
            sy3 = (this.y - oy) / (p3.y - oy);
          }
          var p4 = rect2.bottomLeft();
          if (p4.x < ox) {
            sx4 = (this.x - ox) / (p4.x - ox);
          }
          if (p4.y > oy) {
            sy4 = (this.y + this.height - oy) / (p4.y - oy);
          }
          return {
            sx: min$1(sx1, sx2, sx3, sx4),
            sy: min$1(sy1, sy2, sy3, sy4)
          };
        },
        maxRectUniformScaleToFit: function(rect2, origin) {
          var scale2 = this.maxRectScaleToFit(rect2, origin);
          return min$1(scale2.sx, scale2.sy);
        },
        // Move and expand me.
        // @param r {rectangle} representing deltas
        moveAndExpand: function(r) {
          this.x += r.x || 0;
          this.y += r.y || 0;
          this.width += r.width || 0;
          this.height += r.height || 0;
          return this;
        },
        moveAroundPoint: function(origin, angle) {
          const newCenter = this.center().rotate(origin, angle);
          this.x = newCenter.x - this.width / 2;
          this.y = newCenter.y - this.height / 2;
          return this;
        },
        // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.
        // If width < 0 the function swaps the left and right corners,
        // and it swaps the top and bottom corners if height < 0
        // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized
        normalize: function() {
          var newx = this.x;
          var newy = this.y;
          var newwidth = this.width;
          var newheight = this.height;
          if (this.width < 0) {
            newx = this.x + this.width;
            newwidth = -this.width;
          }
          if (this.height < 0) {
            newy = this.y + this.height;
            newheight = -this.height;
          }
          this.x = newx;
          this.y = newy;
          this.width = newwidth;
          this.height = newheight;
          return this;
        },
        // Offset me by the specified amount.
        offset: function(dx, dy) {
          return Point.prototype.offset.call(this, dx, dy);
        },
        origin: function() {
          return new Point(this.x, this.y);
        },
        // @return {point} a point on my boundary nearest to the given point.
        // @see Squeak Smalltalk, Rectangle>>pointNearestTo:
        pointNearestToPoint: function(point2) {
          point2 = new Point(point2);
          if (this.containsPoint(point2)) {
            var side = this.sideNearestToPoint(point2);
            switch (side) {
              case "right":
                return new Point(this.x + this.width, point2.y);
              case "left":
                return new Point(this.x, point2.y);
              case "bottom":
                return new Point(point2.x, this.y + this.height);
              case "top":
                return new Point(point2.x, this.y);
            }
          }
          return point2.adhereToRect(this);
        },
        rightLine: function() {
          return new Line(this.topRight(), this.bottomRight());
        },
        rightMiddle: function() {
          return new Point(this.x + this.width, this.y + this.height / 2);
        },
        round: function(precision) {
          let f2 = 1;
          if (precision) {
            switch (precision) {
              case 1:
                f2 = 10;
                break;
              case 2:
                f2 = 100;
                break;
              case 3:
                f2 = 1e3;
                break;
              default:
                f2 = pow$1(10, precision);
                break;
            }
          }
          this.x = round$1(this.x * f2) / f2;
          this.y = round$1(this.y * f2) / f2;
          this.width = round$1(this.width * f2) / f2;
          this.height = round$1(this.height * f2) / f2;
          return this;
        },
        // Scale rectangle with origin.
        scale: function(sx, sy, origin) {
          origin = this.origin().scale(sx, sy, origin);
          this.x = origin.x;
          this.y = origin.y;
          this.width *= sx;
          this.height *= sy;
          return this;
        },
        // @return {string} (left|right|top|bottom) side which is nearest to point
        // @see Squeak Smalltalk, Rectangle>>sideNearestTo:
        sideNearestToPoint: function(point2) {
          point2 = new Point(point2);
          var distToLeft = point2.x - this.x;
          var distToRight = this.x + this.width - point2.x;
          var distToTop = point2.y - this.y;
          var distToBottom = this.y + this.height - point2.y;
          var closest2 = distToLeft;
          var side = "left";
          if (distToRight < closest2) {
            closest2 = distToRight;
            side = "right";
          }
          if (distToTop < closest2) {
            closest2 = distToTop;
            side = "top";
          }
          if (distToBottom < closest2) {
            side = "bottom";
          }
          return side;
        },
        snapToGrid: function(gx, gy) {
          var origin = this.origin().snapToGrid(gx, gy);
          var corner = this.corner().snapToGrid(gx, gy);
          this.x = origin.x;
          this.y = origin.y;
          this.width = corner.x - origin.x;
          this.height = corner.y - origin.y;
          return this;
        },
        toJSON: function() {
          return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
          };
        },
        topLine: function() {
          return new Line(this.topLeft(), this.topRight());
        },
        topMiddle: function() {
          return new Point(this.x + this.width / 2, this.y);
        },
        topRight: function() {
          return new Point(this.x + this.width, this.y);
        },
        toString: function() {
          return this.origin().toString() + " " + this.corner().toString();
        },
        // @return {rect} representing the union of both rectangles.
        union: function(rect2) {
          return Rect.fromRectUnion(this, rect2);
        },
        update: function(x, y, w, h) {
          if (Object(x) === x) {
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x;
          }
          this.x = x || 0;
          this.y = y || 0;
          this.width = w || 0;
          this.height = h || 0;
          return this;
        }
      };
      Rect.prototype.bottomRight = Rect.prototype.corner;
      Rect.prototype.topLeft = Rect.prototype.origin;
      Rect.prototype.translate = Rect.prototype.offset;
      const rect = Rect;
      function parsePoints(svgString) {
        const trimmedString = svgString.trim();
        if (trimmedString === "") return [];
        const points = [];
        const coords = trimmedString.split(/\b\s*,\s*|,\s*|\s+/);
        const numCoords = coords.length;
        for (let i = 0; i < numCoords; i += 2) {
          points.push({
            x: +coords[i],
            y: +coords[i + 1]
          });
        }
        return points;
      }
      function clonePoints(points) {
        const numPoints = points.length;
        if (numPoints === 0) return [];
        const newPoints = [];
        for (let i = 0; i < numPoints; i++) {
          const point2 = points[i].clone();
          newPoints.push(point2);
        }
        return newPoints;
      }
      function convexHull(points) {
        const {
          abs: abs2
        } = Math;
        var i;
        var n;
        var numPoints = points.length;
        if (numPoints === 0) return [];
        var startPoint;
        for (i = 0; i < numPoints; i++) {
          if (startPoint === void 0) {
            startPoint = points[i];
          } else if (points[i].y < startPoint.y) {
            startPoint = points[i];
          } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {
            startPoint = points[i];
          }
        }
        var sortedPointRecords = [];
        for (i = 0; i < numPoints; i++) {
          var angle = startPoint.theta(points[i]);
          if (angle === 0) {
            angle = 360;
          }
          var entry = [points[i], i, angle];
          sortedPointRecords.push(entry);
        }
        sortedPointRecords.sort(function(record1, record2) {
          var sortOutput = record1[2] - record2[2];
          if (sortOutput === 0) {
            sortOutput = record2[1] - record1[1];
          }
          return sortOutput;
        });
        if (sortedPointRecords.length > 2) {
          var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];
          sortedPointRecords.unshift(startPointRecord);
        }
        var insidePoints = {};
        var hullPointRecords = [];
        var currentPointRecord;
        var currentPoint;
        var lastHullPointRecord;
        var lastHullPoint;
        var secondLastHullPointRecord;
        var secondLastHullPoint;
        while (sortedPointRecords.length !== 0) {
          currentPointRecord = sortedPointRecords.pop();
          currentPoint = currentPointRecord[0];
          if (insidePoints.hasOwnProperty(currentPointRecord[0] + "@@" + currentPointRecord[1])) {
            continue;
          }
          var correctTurnFound = false;
          while (!correctTurnFound) {
            if (hullPointRecords.length < 2) {
              hullPointRecords.push(currentPointRecord);
              correctTurnFound = true;
            } else {
              lastHullPointRecord = hullPointRecords.pop();
              lastHullPoint = lastHullPointRecord[0];
              secondLastHullPointRecord = hullPointRecords.pop();
              secondLastHullPoint = secondLastHullPointRecord[0];
              var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);
              if (crossProduct < 0) {
                hullPointRecords.push(secondLastHullPointRecord);
                hullPointRecords.push(lastHullPointRecord);
                hullPointRecords.push(currentPointRecord);
                correctTurnFound = true;
              } else if (crossProduct === 0) {
                var THRESHOLD = 1e-10;
                var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);
                if (abs2(angleBetween - 180) < THRESHOLD) {
                  insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                  hullPointRecords.push(secondLastHullPointRecord);
                } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {
                  insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                  hullPointRecords.push(secondLastHullPointRecord);
                } else if (abs2((angleBetween + 1) % 360 - 1) < THRESHOLD) {
                  hullPointRecords.push(secondLastHullPointRecord);
                  sortedPointRecords.push(lastHullPointRecord);
                }
              } else {
                insidePoints[lastHullPointRecord[0] + "@@" + lastHullPointRecord[1]] = lastHullPoint;
                hullPointRecords.push(secondLastHullPointRecord);
              }
            }
          }
        }
        if (hullPointRecords.length > 2) {
          hullPointRecords.pop();
        }
        var lowestHullIndex;
        var indexOfLowestHullIndexRecord = -1;
        n = hullPointRecords.length;
        for (i = 0; i < n; i++) {
          var currentHullIndex = hullPointRecords[i][1];
          if (lowestHullIndex === void 0 || currentHullIndex < lowestHullIndex) {
            lowestHullIndex = currentHullIndex;
            indexOfLowestHullIndexRecord = i;
          }
        }
        var hullPointRecordsReordered = [];
        if (indexOfLowestHullIndexRecord > 0) {
          var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);
          var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);
          hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);
        } else {
          hullPointRecordsReordered = hullPointRecords;
        }
        var hullPoints = [];
        n = hullPointRecordsReordered.length;
        for (i = 0; i < n; i++) {
          hullPoints.push(hullPointRecordsReordered[i][0]);
        }
        return hullPoints;
      }
      const Polyline$1 = function(points) {
        if (!(this instanceof Polyline$1)) {
          return new Polyline$1(points);
        }
        if (typeof points === "string") {
          return new Polyline$1.parse(points);
        }
        this.points = Array.isArray(points) ? points.map(Point) : [];
      };
      Polyline$1.parse = function(svgString) {
        return new Polyline$1(parsePoints(svgString));
      };
      Polyline$1.fromRect = function(rect2) {
        return new Polyline$1([rect2.topLeft(), rect2.topRight(), rect2.bottomRight(), rect2.bottomLeft(), rect2.topLeft()]);
      };
      Polyline$1.prototype = {
        type: types.Polyline,
        bbox: function() {
          var x1 = Infinity;
          var x2 = -Infinity;
          var y1 = Infinity;
          var y2 = -Infinity;
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return null;
          for (var i = 0; i < numPoints; i++) {
            var point2 = points[i];
            var x = point2.x;
            var y = point2.y;
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;
          }
          return new Rect(x1, y1, x2 - x1, y2 - y1);
        },
        clone: function() {
          return new Polyline$1(clonePoints(this.points));
        },
        closestPoint: function(p) {
          var cpLength = this.closestPointLength(p);
          return this.pointAtLength(cpLength);
        },
        closestPointLength: function(p) {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return 0;
          if (numPoints === 1) return 0;
          var cpLength;
          var minSqrDistance = Infinity;
          var length2 = 0;
          var n = numPoints - 1;
          for (var i = 0; i < n; i++) {
            var line2 = new Line(points[i], points[i + 1]);
            var lineLength = line2.length();
            var cpNormalizedLength = line2.closestPointNormalizedLength(p);
            var cp = line2.pointAt(cpNormalizedLength);
            var sqrDistance = cp.squaredDistance(p);
            if (sqrDistance < minSqrDistance) {
              minSqrDistance = sqrDistance;
              cpLength = length2 + cpNormalizedLength * lineLength;
            }
            length2 += lineLength;
          }
          return cpLength;
        },
        closestPointNormalizedLength: function(p) {
          var cpLength = this.closestPointLength(p);
          if (cpLength === 0) return 0;
          var length2 = this.length();
          if (length2 === 0) return 0;
          return cpLength / length2;
        },
        closestPointTangent: function(p) {
          var cpLength = this.closestPointLength(p);
          return this.tangentAtLength(cpLength);
        },
        // Returns `true` if the area surrounded by the polyline contains the point `p`.
        // Implements the even-odd SVG algorithm (self-intersections are "outside").
        // (Uses horizontal rays to the right of `p` to look for intersections.)
        // Closes open polylines (always imagines a final closing segment).
        containsPoint: function(p) {
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return false;
          var x = p.x;
          var y = p.y;
          var startIndex = numPoints - 1;
          var endIndex = 0;
          var numIntersections = 0;
          var segment = new Line();
          var ray = new Line();
          var rayEnd = new Point();
          for (; endIndex < numPoints; endIndex++) {
            var start = points[startIndex];
            var end = points[endIndex];
            if (p.equals(start)) return true;
            segment.start = start;
            segment.end = end;
            if (segment.containsPoint(p)) return true;
            if (y <= start.y && y > end.y || y > start.y && y <= end.y) {
              var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;
              if (xDifference >= 0) {
                rayEnd.x = x + xDifference;
                rayEnd.y = y;
                ray.start = p;
                ray.end = rayEnd;
                if (segment.intersect(ray)) {
                  numIntersections++;
                }
              }
            }
            startIndex = endIndex;
          }
          return numIntersections % 2 === 1;
        },
        close: function() {
          const {
            start,
            end,
            points
          } = this;
          if (start && end && !start.equals(end)) {
            points.push(start.clone());
          }
          return this;
        },
        lengthPoints: function() {
          return this.points;
        },
        convexHull: function() {
          return new Polyline$1(convexHull(this.points));
        },
        // Checks whether two polylines are exactly the same.
        // If `p` is undefined or null, returns false.
        equals: function(p) {
          if (!p) return false;
          var points = this.points;
          var otherPoints = p.points;
          var numPoints = points.length;
          if (otherPoints.length !== numPoints) return false;
          for (var i = 0; i < numPoints; i++) {
            var point2 = points[i];
            var otherPoint = p.points[i];
            if (!point2.equals(otherPoint)) return false;
          }
          return true;
        },
        intersectionWithLine: function(l) {
          var line2 = new Line(l);
          var intersections = [];
          var points = this.lengthPoints();
          var l2 = new Line();
          for (var i = 0, n = points.length - 1; i < n; i++) {
            l2.start = points[i];
            l2.end = points[i + 1];
            var int = line2.intersectionWithLine(l2);
            if (int) intersections.push(int[0]);
          }
          return intersections.length > 0 ? intersections : null;
        },
        isDifferentiable: function() {
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return false;
          var line2 = new Line();
          var n = numPoints - 1;
          for (var i = 0; i < n; i++) {
            line2.start = points[i];
            line2.end = points[i + 1];
            if (line2.isDifferentiable()) return true;
          }
          return false;
        },
        length: function() {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return 0;
          var length2 = 0;
          var n = numPoints - 1;
          for (var i = 0; i < n; i++) {
            length2 += points[i].distance(points[i + 1]);
          }
          return length2;
        },
        pointAt: function(ratio) {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return null;
          if (numPoints === 1) return points[0].clone();
          if (ratio <= 0) return points[0].clone();
          if (ratio >= 1) return points[numPoints - 1].clone();
          var polylineLength = this.length();
          var length2 = polylineLength * ratio;
          return this.pointAtLength(length2);
        },
        pointAtLength: function(length2) {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return null;
          if (numPoints === 1) return points[0].clone();
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          var l = 0;
          var n = numPoints - 1;
          for (var i = 0; i < n; i++) {
            var index2 = fromStart ? i : n - 1 - i;
            var a = points[index2];
            var b = points[index2 + 1];
            var line2 = new Line(a, b);
            var d = a.distance(b);
            if (length2 <= l + d) {
              return line2.pointAtLength((fromStart ? 1 : -1) * (length2 - l));
            }
            l += d;
          }
          var lastPoint = fromStart ? points[numPoints - 1] : points[0];
          return lastPoint.clone();
        },
        round: function(precision) {
          var points = this.points;
          var numPoints = points.length;
          for (var i = 0; i < numPoints; i++) {
            points[i].round(precision);
          }
          return this;
        },
        scale: function(sx, sy, origin) {
          var points = this.points;
          var numPoints = points.length;
          for (var i = 0; i < numPoints; i++) {
            points[i].scale(sx, sy, origin);
          }
          return this;
        },
        simplify: function(opt = {}) {
          const points = this.points;
          if (points.length < 3) return this;
          const threshold = opt.threshold || 1e-10;
          let currentIndex = 0;
          while (points[currentIndex + 2]) {
            const firstIndex = currentIndex;
            const middleIndex = currentIndex + 1;
            const lastIndex = currentIndex + 2;
            const firstPoint = points[firstIndex];
            const middlePoint = points[middleIndex];
            const lastPoint = points[lastIndex];
            const chord = new Line(firstPoint, lastPoint);
            const closestPoint = chord.closestPoint(middlePoint);
            const closestPointDistance = closestPoint.distance(middlePoint);
            if (closestPointDistance <= threshold) {
              points.splice(middleIndex, 1);
            } else {
              currentIndex += 1;
            }
          }
          return this;
        },
        tangentAt: function(ratio) {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return null;
          if (numPoints === 1) return null;
          if (ratio < 0) ratio = 0;
          if (ratio > 1) ratio = 1;
          var polylineLength = this.length();
          var length2 = polylineLength * ratio;
          return this.tangentAtLength(length2);
        },
        tangentAtLength: function(length2) {
          var points = this.lengthPoints();
          var numPoints = points.length;
          if (numPoints === 0) return null;
          if (numPoints === 1) return null;
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          var lastValidLine;
          var l = 0;
          var n = numPoints - 1;
          for (var i = 0; i < n; i++) {
            var index2 = fromStart ? i : n - 1 - i;
            var a = points[index2];
            var b = points[index2 + 1];
            var line2 = new Line(a, b);
            var d = a.distance(b);
            if (line2.isDifferentiable()) {
              if (length2 <= l + d) {
                return line2.tangentAtLength((fromStart ? 1 : -1) * (length2 - l));
              }
              lastValidLine = line2;
            }
            l += d;
          }
          if (lastValidLine) {
            var ratio = fromStart ? 1 : 0;
            return lastValidLine.tangentAt(ratio);
          }
          return null;
        },
        toString: function() {
          return this.points + "";
        },
        translate: function(tx, ty) {
          var points = this.points;
          var numPoints = points.length;
          for (var i = 0; i < numPoints; i++) {
            points[i].translate(tx, ty);
          }
          return this;
        },
        // Return svgString that can be used to recreate this line.
        serialize: function() {
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return "";
          var output = "";
          for (var i = 0; i < numPoints; i++) {
            var point2 = points[i];
            output += point2.x + "," + point2.y + " ";
          }
          return output.trim();
        }
      };
      Object.defineProperty(Polyline$1.prototype, "start", {
        // Getter for the first point of the polyline.
        configurable: true,
        enumerable: true,
        get: function() {
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return null;
          return this.points[0];
        }
      });
      Object.defineProperty(Polyline$1.prototype, "end", {
        // Getter for the last point of the polyline.
        configurable: true,
        enumerable: true,
        get: function() {
          var points = this.points;
          var numPoints = points.length;
          if (numPoints === 0) return null;
          return this.points[numPoints - 1];
        }
      });
      const {
        abs,
        sqrt,
        min,
        max,
        pow
      } = Math;
      const Curve = function(p1, p2, p3, p4) {
        if (!(this instanceof Curve)) {
          return new Curve(p1, p2, p3, p4);
        }
        if (p1 instanceof Curve) {
          return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);
        }
        this.start = new Point(p1);
        this.controlPoint1 = new Point(p2);
        this.controlPoint2 = new Point(p3);
        this.end = new Point(p4);
      };
      Curve.throughPoints = /* @__PURE__ */ (function() {
        function getCurveControlPoints(knots) {
          var firstControlPoints = [];
          var secondControlPoints = [];
          var n = knots.length - 1;
          var i;
          if (n == 1) {
            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints];
          }
          var rhs = [];
          for (i = 1; i < n - 1; i++) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
          }
          rhs[0] = knots[0].x + 2 * knots[1].x;
          rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;
          var x = getFirstControlPoints(rhs);
          for (i = 1; i < n - 1; ++i) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
          }
          rhs[0] = knots[0].y + 2 * knots[1].y;
          rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;
          var y = getFirstControlPoints(rhs);
          for (i = 0; i < n; i++) {
            firstControlPoints.push(new Point(x[i], y[i]));
            if (i < n - 1) {
              secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            } else {
              secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
            }
          }
          return [firstControlPoints, secondControlPoints];
        }
        function getFirstControlPoints(rhs) {
          var n = rhs.length;
          var x = [];
          var tmp = [];
          var b = 2;
          x[0] = rhs[0] / b;
          for (var i = 1; i < n; i++) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
          }
          for (i = 1; i < n; i++) {
            x[n - i - 1] -= tmp[n - i] * x[n - i];
          }
          return x;
        }
        return function(points) {
          if (!points || Array.isArray(points) && points.length < 2) {
            throw new Error("At least 2 points are required");
          }
          var controlPoints = getCurveControlPoints(points);
          var curves = [];
          var n = controlPoints[0].length;
          for (var i = 0; i < n; i++) {
            var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);
            var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);
            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));
          }
          return curves;
        };
      })();
      Curve.prototype = {
        type: types.Curve,
        // Returns a bbox that tightly envelops the curve.
        bbox: function() {
          var start = this.start;
          var controlPoint1 = this.controlPoint1;
          var controlPoint2 = this.controlPoint2;
          var end = this.end;
          var x0 = start.x;
          var y0 = start.y;
          var x1 = controlPoint1.x;
          var y1 = controlPoint1.y;
          var x2 = controlPoint2.x;
          var y2 = controlPoint2.y;
          var x3 = end.x;
          var y3 = end.y;
          var points = new Array();
          var tvalues = new Array();
          var bounds = [new Array(), new Array()];
          var a, b, c, t;
          var t1, t2;
          var b2ac, sqrtb2ac;
          for (var i = 0; i < 2; ++i) {
            if (i === 0) {
              b = 6 * x0 - 12 * x1 + 6 * x2;
              a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
              c = 3 * x1 - 3 * x0;
            } else {
              b = 6 * y0 - 12 * y1 + 6 * y2;
              a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
              c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
              if (abs(b) < 1e-12) {
                continue;
              }
              t = -c / b;
              if (0 < t && t < 1) tvalues.push(t);
              continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = sqrt(b2ac);
            if (b2ac < 0) continue;
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) tvalues.push(t1);
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) tvalues.push(t2);
          }
          var j = tvalues.length;
          var jlen = j;
          var mt;
          var x, y;
          while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[0][j] = x;
            y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
            bounds[1][j] = y;
            points[j] = {
              X: x,
              Y: y
            };
          }
          tvalues[jlen] = 0;
          tvalues[jlen + 1] = 1;
          points[jlen] = {
            X: x0,
            Y: y0
          };
          points[jlen + 1] = {
            X: x3,
            Y: y3
          };
          bounds[0][jlen] = x0;
          bounds[1][jlen] = y0;
          bounds[0][jlen + 1] = x3;
          bounds[1][jlen + 1] = y3;
          tvalues.length = jlen + 2;
          bounds[0].length = jlen + 2;
          bounds[1].length = jlen + 2;
          points.length = jlen + 2;
          var left2 = min.apply(null, bounds[0]);
          var top2 = min.apply(null, bounds[1]);
          var right2 = max.apply(null, bounds[0]);
          var bottom2 = max.apply(null, bounds[1]);
          return new Rect(left2, top2, right2 - left2, bottom2 - top2);
        },
        clone: function() {
          return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
        },
        // Returns the point on the curve closest to point `p`
        closestPoint: function(p, opt) {
          return this.pointAtT(this.closestPointT(p, opt));
        },
        closestPointLength: function(p, opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var localOpt = {
            precision,
            subdivisions
          };
          return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);
        },
        closestPointNormalizedLength: function(p, opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var localOpt = {
            precision,
            subdivisions
          };
          var cpLength = this.closestPointLength(p, localOpt);
          if (!cpLength) return 0;
          var length2 = this.length(localOpt);
          if (length2 === 0) return 0;
          return cpLength / length2;
        },
        // Returns `t` of the point on the curve closest to point `p`
        closestPointT: function(p, opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var investigatedSubdivision;
          var investigatedSubdivisionStartT;
          var investigatedSubdivisionEndT;
          var distFromStart;
          var distFromEnd;
          var chordLength;
          var minSumDist;
          var n = subdivisions.length;
          var subdivisionSize = n ? 1 / n : 0;
          for (var i = 0; i < n; i++) {
            var currentSubdivision = subdivisions[i];
            var startDist = currentSubdivision.start.distance(p);
            var endDist = currentSubdivision.end.distance(p);
            var sumDist = startDist + endDist;
            if (!minSumDist || sumDist < minSumDist) {
              investigatedSubdivision = currentSubdivision;
              investigatedSubdivisionStartT = i * subdivisionSize;
              investigatedSubdivisionEndT = (i + 1) * subdivisionSize;
              distFromStart = startDist;
              distFromEnd = endDist;
              chordLength = currentSubdivision.start.distance(currentSubdivision.end);
              minSumDist = sumDist;
            }
          }
          var precisionRatio = pow(10, -precision);
          while (true) {
            var startPrecisionRatio = distFromStart ? abs(distFromStart - distFromEnd) / distFromStart : 0;
            var endPrecisionRatio = distFromEnd ? abs(distFromStart - distFromEnd) / distFromEnd : 0;
            var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio;
            var hasMinimalStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;
            var hasMinimalEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;
            var hasMinimalDistance = hasMinimalStartDistance || hasMinimalEndDistance;
            if (hasRequiredPrecision || hasMinimalDistance) {
              return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;
            }
            var divided = investigatedSubdivision.divide(0.5);
            subdivisionSize /= 2;
            var startDist1 = divided[0].start.distance(p);
            var endDist1 = divided[0].end.distance(p);
            var sumDist1 = startDist1 + endDist1;
            var startDist2 = divided[1].start.distance(p);
            var endDist2 = divided[1].end.distance(p);
            var sumDist2 = startDist2 + endDist2;
            if (sumDist1 <= sumDist2) {
              investigatedSubdivision = divided[0];
              investigatedSubdivisionEndT -= subdivisionSize;
              distFromStart = startDist1;
              distFromEnd = endDist1;
            } else {
              investigatedSubdivision = divided[1];
              investigatedSubdivisionStartT += subdivisionSize;
              distFromStart = startDist2;
              distFromEnd = endDist2;
            }
          }
        },
        closestPointTangent: function(p, opt) {
          return this.tangentAtT(this.closestPointT(p, opt));
        },
        // Returns `true` if the area surrounded by the curve contains the point `p`.
        // Implements the even-odd algorithm (self-intersections are "outside").
        // Closes open curves (always imagines a closing segment).
        // Precision may be adjusted by passing an `opt` object.
        containsPoint: function(p, opt) {
          var polyline = this.toPolyline(opt);
          return polyline.containsPoint(p);
        },
        // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
        // For a function that uses `t`, use Curve.divideAtT().
        divideAt: function(ratio, opt) {
          if (ratio <= 0) return this.divideAtT(0);
          if (ratio >= 1) return this.divideAtT(1);
          var t = this.tAt(ratio, opt);
          return this.divideAtT(t);
        },
        // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
        divideAtLength: function(length2, opt) {
          var t = this.tAtLength(length2, opt);
          return this.divideAtT(t);
        },
        // Divides the curve into two at point defined by `t` between 0 and 1.
        // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).
        // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau
        divideAtT: function(t) {
          var start = this.start;
          var controlPoint1 = this.controlPoint1;
          var controlPoint2 = this.controlPoint2;
          var end = this.end;
          if (t <= 0) {
            return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];
          }
          if (t >= 1) {
            return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];
          }
          var dividerPoints = this.getSkeletonPoints(t);
          var startControl1 = dividerPoints.startControlPoint1;
          var startControl2 = dividerPoints.startControlPoint2;
          var divider = dividerPoints.divider;
          var dividerControl1 = dividerPoints.dividerControlPoint1;
          var dividerControl2 = dividerPoints.dividerControlPoint2;
          return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];
        },
        // Returns the distance between the curve's start and end points.
        endpointDistance: function() {
          return this.start.distance(this.end);
        },
        // Checks whether two curves are exactly the same.
        equals: function(c) {
          return !!c && this.start.x === c.start.x && this.start.y === c.start.y && this.controlPoint1.x === c.controlPoint1.x && this.controlPoint1.y === c.controlPoint1.y && this.controlPoint2.x === c.controlPoint2.x && this.controlPoint2.y === c.controlPoint2.y && this.end.x === c.end.x && this.end.y === c.end.y;
        },
        // Returns five helper points necessary for curve division.
        getSkeletonPoints: function(t) {
          var start = this.start;
          var control1 = this.controlPoint1;
          var control2 = this.controlPoint2;
          var end = this.end;
          if (t <= 0) {
            return {
              startControlPoint1: start.clone(),
              startControlPoint2: start.clone(),
              divider: start.clone(),
              dividerControlPoint1: control1.clone(),
              dividerControlPoint2: control2.clone()
            };
          }
          if (t >= 1) {
            return {
              startControlPoint1: control1.clone(),
              startControlPoint2: control2.clone(),
              divider: end.clone(),
              dividerControlPoint1: end.clone(),
              dividerControlPoint2: end.clone()
            };
          }
          var midpoint1 = new Line(start, control1).pointAt(t);
          var midpoint2 = new Line(control1, control2).pointAt(t);
          var midpoint3 = new Line(control2, end).pointAt(t);
          var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);
          var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);
          var divider = new Line(subControl1, subControl2).pointAt(t);
          var output = {
            startControlPoint1: midpoint1,
            startControlPoint2: subControl1,
            divider,
            dividerControlPoint1: subControl2,
            dividerControlPoint2: midpoint3
          };
          return output;
        },
        // Returns a list of curves whose flattened length is better than `opt.precision`.
        // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%
        // (Observed difference is not real precision, but close enough as long as special cases are covered)
        // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)
        // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)
        // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)
        // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)
        // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)
        // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)
        // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)
        getSubdivisions: function(opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var start = this.start;
          var control1 = this.controlPoint1;
          var control2 = this.controlPoint2;
          var end = this.end;
          var subdivisions = [new Curve(start, control1, control2, end)];
          if (precision === 0) return subdivisions;
          var isPoint = !this.isDifferentiable();
          if (isPoint) return subdivisions;
          var previousLength = this.endpointDistance();
          var precisionRatio = pow(10, -precision);
          var minIterations = 2;
          var isLine = control1.cross(start, end) === 0 && control2.cross(start, end) === 0;
          if (isLine) {
            minIterations = 2 * precision;
          }
          var iteration = 0;
          while (true) {
            iteration += 1;
            var newSubdivisions = [];
            var numSubdivisions = subdivisions.length;
            for (var i = 0; i < numSubdivisions; i++) {
              var currentSubdivision = subdivisions[i];
              var divided = currentSubdivision.divide(0.5);
              newSubdivisions.push(divided[0], divided[1]);
            }
            var length2 = 0;
            var numNewSubdivisions = newSubdivisions.length;
            for (var j = 0; j < numNewSubdivisions; j++) {
              var currentNewSubdivision = newSubdivisions[j];
              length2 += currentNewSubdivision.endpointDistance();
            }
            if (iteration >= minIterations) {
              var observedPrecisionRatio = length2 !== 0 ? (length2 - previousLength) / length2 : 0;
              if (observedPrecisionRatio < precisionRatio) {
                return newSubdivisions;
              }
            }
            subdivisions = newSubdivisions;
            previousLength = length2;
          }
        },
        isDifferentiable: function() {
          var start = this.start;
          var control1 = this.controlPoint1;
          var control2 = this.controlPoint2;
          var end = this.end;
          return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
        },
        // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.
        length: function(opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var length2 = 0;
          var n = subdivisions.length;
          for (var i = 0; i < n; i++) {
            var currentSubdivision = subdivisions[i];
            length2 += currentSubdivision.endpointDistance();
          }
          return length2;
        },
        // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)
        lengthAtT: function(t, opt) {
          if (t <= 0) return 0;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subCurve = this.divide(t)[0];
          var subCurveLength = subCurve.length({
            precision
          });
          return subCurveLength;
        },
        // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
        // Mirrors Line.pointAt() function.
        // For a function that tracks `t`, use Curve.pointAtT().
        pointAt: function(ratio, opt) {
          if (ratio <= 0) return this.start.clone();
          if (ratio >= 1) return this.end.clone();
          var t = this.tAt(ratio, opt);
          return this.pointAtT(t);
        },
        // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
        pointAtLength: function(length2, opt) {
          var t = this.tAtLength(length2, opt);
          return this.pointAtT(t);
        },
        // Returns the point at provided `t` between 0 and 1.
        // `t` does not track distance along curve as it does in Line objects.
        // Non-linear relationship, speeds up and slows down as curve warps!
        // For linear length-based solution, use Curve.pointAt().
        pointAtT: function(t) {
          if (t <= 0) return this.start.clone();
          if (t >= 1) return this.end.clone();
          return this.getSkeletonPoints(t).divider;
        },
        // Default precision
        PRECISION: 3,
        round: function(precision) {
          this.start.round(precision);
          this.controlPoint1.round(precision);
          this.controlPoint2.round(precision);
          this.end.round(precision);
          return this;
        },
        scale: function(sx, sy, origin) {
          this.start.scale(sx, sy, origin);
          this.controlPoint1.scale(sx, sy, origin);
          this.controlPoint2.scale(sx, sy, origin);
          this.end.scale(sx, sy, origin);
          return this;
        },
        // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
        tangentAt: function(ratio, opt) {
          if (!this.isDifferentiable()) return null;
          if (ratio < 0) ratio = 0;
          else if (ratio > 1) ratio = 1;
          var t = this.tAt(ratio, opt);
          return this.tangentAtT(t);
        },
        // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.
        tangentAtLength: function(length2, opt) {
          if (!this.isDifferentiable()) return null;
          var t = this.tAtLength(length2, opt);
          return this.tangentAtT(t);
        },
        // Returns a tangent line at requested `t`.
        tangentAtT: function(t) {
          if (!this.isDifferentiable()) return null;
          if (t < 0) t = 0;
          else if (t > 1) t = 1;
          var skeletonPoints = this.getSkeletonPoints(t);
          var p1 = skeletonPoints.startControlPoint2;
          var p2 = skeletonPoints.dividerControlPoint1;
          var tangentStart = skeletonPoints.divider;
          var tangentLine = new Line(p1, p2);
          tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);
          return tangentLine;
        },
        // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
        tAt: function(ratio, opt) {
          if (ratio <= 0) return 0;
          if (ratio >= 1) return 1;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var localOpt = {
            precision,
            subdivisions
          };
          var curveLength = this.length(localOpt);
          var length2 = curveLength * ratio;
          return this.tAtLength(length2, localOpt);
        },
        // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
        // Uses `precision` to approximate length within `precision` (always underestimates)
        // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated
        // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper
        // - Precision 0 (chooses one of the two endpoints) - 0 levels
        // - Precision 1 (chooses one of 5 points, <10% error) - 1 level
        // - Precision 2 (<1% error) - 3 levels
        // - Precision 3 (<0.1% error) - 7 levels
        // - Precision 4 (<0.01% error) - 15 levels
        tAtLength: function(length2, opt) {
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var localOpt = {
            precision,
            subdivisions
          };
          var investigatedSubdivision;
          var investigatedSubdivisionStartT;
          var investigatedSubdivisionEndT;
          var baselinePointDistFromStart;
          var baselinePointDistFromEnd;
          var l = 0;
          var n = subdivisions.length;
          var subdivisionSize = 1 / n;
          for (var i = 0; i < n; i++) {
            var index2 = fromStart ? i : n - 1 - i;
            var currentSubdivision = subdivisions[i];
            var d = currentSubdivision.endpointDistance();
            if (length2 <= l + d) {
              investigatedSubdivision = currentSubdivision;
              investigatedSubdivisionStartT = index2 * subdivisionSize;
              investigatedSubdivisionEndT = (index2 + 1) * subdivisionSize;
              baselinePointDistFromStart = fromStart ? length2 - l : d + l - length2;
              baselinePointDistFromEnd = fromStart ? d + l - length2 : length2 - l;
              break;
            }
            l += d;
          }
          if (!investigatedSubdivision) return fromStart ? 1 : 0;
          var curveLength = this.length(localOpt);
          var precisionRatio = pow(10, -precision);
          while (true) {
            var observedPrecisionRatio;
            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromStart / curveLength : 0;
            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;
            observedPrecisionRatio = curveLength !== 0 ? baselinePointDistFromEnd / curveLength : 0;
            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;
            var newBaselinePointDistFromStart;
            var newBaselinePointDistFromEnd;
            var divided = investigatedSubdivision.divide(0.5);
            subdivisionSize /= 2;
            var baseline1Length = divided[0].endpointDistance();
            var baseline2Length = divided[1].endpointDistance();
            if (baselinePointDistFromStart <= baseline1Length) {
              investigatedSubdivision = divided[0];
              investigatedSubdivisionEndT -= subdivisionSize;
              newBaselinePointDistFromStart = baselinePointDistFromStart;
              newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;
            } else {
              investigatedSubdivision = divided[1];
              investigatedSubdivisionStartT += subdivisionSize;
              newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;
              newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;
            }
            baselinePointDistFromStart = newBaselinePointDistFromStart;
            baselinePointDistFromEnd = newBaselinePointDistFromEnd;
          }
        },
        // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
        // Flattened length is no more than 10^(-precision) away from real curve length.
        toPoints: function(opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var subdivisions = opt.subdivisions === void 0 ? this.getSubdivisions({
            precision
          }) : opt.subdivisions;
          var points = [subdivisions[0].start.clone()];
          var n = subdivisions.length;
          for (var i = 0; i < n; i++) {
            var currentSubdivision = subdivisions[i];
            points.push(currentSubdivision.end.clone());
          }
          return points;
        },
        // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.
        // Flattened length is no more than 10^(-precision) away from real curve length.
        toPolyline: function(opt) {
          return new Polyline$1(this.toPoints(opt));
        },
        toString: function() {
          return this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
        },
        translate: function(tx, ty) {
          this.start.translate(tx, ty);
          this.controlPoint1.translate(tx, ty);
          this.controlPoint2.translate(tx, ty);
          this.end.translate(tx, ty);
          return this;
        }
      };
      Curve.prototype.divide = Curve.prototype.divideAtT;
      function extend$1(obj) {
        var i;
        var n;
        var args = [];
        n = arguments.length;
        for (i = 1; i < n; i++) {
          args.push(arguments[i]);
        }
        if (!obj) throw new Error("Missing a parent object.");
        var child = Object.create(obj);
        n = args.length;
        for (i = 0; i < n; i++) {
          var src = args[i];
          var inheritedProperty;
          var key;
          for (key in src) {
            if (src.hasOwnProperty(key)) {
              delete child[key];
              inheritedProperty = Object.getOwnPropertyDescriptor(src, key);
              Object.defineProperty(child, key, inheritedProperty);
            }
          }
        }
        return child;
      }
      const Path$1 = function(arg) {
        if (!(this instanceof Path$1)) {
          return new Path$1(arg);
        }
        if (typeof arg === "string") {
          return new Path$1.parse(arg);
        }
        this.segments = [];
        var i;
        var n;
        if (!arg) {
        } else if (Array.isArray(arg) && arg.length !== 0) {
          arg = arg.reduce(function(acc, val) {
            return acc.concat(val);
          }, []);
          n = arg.length;
          if (arg[0].isSegment) {
            for (i = 0; i < n; i++) {
              var segment = arg[i];
              this.appendSegment(segment);
            }
          } else {
            var previousObj = null;
            for (i = 0; i < n; i++) {
              var obj = arg[i];
              if (!(obj instanceof Line || obj instanceof Curve)) {
                throw new Error("Cannot construct a path segment from the provided object.");
              }
              if (i === 0) this.appendSegment(Path$1.createSegment("M", obj.start));
              if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path$1.createSegment("M", obj.start));
              if (obj instanceof Line) {
                this.appendSegment(Path$1.createSegment("L", obj.end));
              } else if (obj instanceof Curve) {
                this.appendSegment(Path$1.createSegment("C", obj.controlPoint1, obj.controlPoint2, obj.end));
              }
              previousObj = obj;
            }
          }
        } else if (arg.isSegment) {
          this.appendSegment(arg);
        } else if (arg instanceof Line) {
          this.appendSegment(Path$1.createSegment("M", arg.start));
          this.appendSegment(Path$1.createSegment("L", arg.end));
        } else if (arg instanceof Curve) {
          this.appendSegment(Path$1.createSegment("M", arg.start));
          this.appendSegment(Path$1.createSegment("C", arg.controlPoint1, arg.controlPoint2, arg.end));
        } else if (arg instanceof Polyline$1) {
          if (!(arg.points && arg.points.length !== 0)) return;
          n = arg.points.length;
          for (i = 0; i < n; i++) {
            var point2 = arg.points[i];
            if (i === 0) this.appendSegment(Path$1.createSegment("M", point2));
            else this.appendSegment(Path$1.createSegment("L", point2));
          }
        } else {
          throw new Error("Cannot construct a path from the provided object.");
        }
      };
      Path$1.parse = function(pathData) {
        if (!pathData) return new Path$1();
        var path2 = new Path$1();
        var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g;
        var commands = pathData.match(commandRe);
        var numCommands = commands.length;
        for (var i = 0; i < numCommands; i++) {
          var command = commands[i];
          var argRe = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g;
          var args = command.match(argRe);
          var segment = Path$1.createSegment.apply(this, args);
          path2.appendSegment(segment);
        }
        return path2;
      };
      Path$1.createSegment = function(type) {
        if (!type) throw new Error("Type must be provided.");
        var segmentConstructor = Path$1.segmentTypes[type];
        if (!segmentConstructor) throw new Error(type + " is not a recognized path segment type.");
        var args = [];
        var n = arguments.length;
        for (var i = 1; i < n; i++) {
          args.push(arguments[i]);
        }
        return applyToNew(segmentConstructor, args);
      };
      Path$1.prototype = {
        type: types.Path,
        // Accepts one segment or an array of segments as argument.
        // Throws an error if argument is not a segment or an array of segments.
        appendSegment: function(arg) {
          var segments = this.segments;
          var numSegments = segments.length;
          var currentSegment;
          var previousSegment = numSegments !== 0 ? segments[numSegments - 1] : null;
          var nextSegment = null;
          if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.push(currentSegment);
          } else {
            arg = arg.reduce(function(acc, val) {
              return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            var n = arg.length;
            for (var i = 0; i < n; i++) {
              var currentArg = arg[i];
              currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
              segments.push(currentSegment);
              previousSegment = currentSegment;
            }
          }
        },
        // Returns the bbox of the path.
        // If path has no segments, returns null.
        // If path has only invisible segments, returns bbox of the end point of last segment.
        bbox: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          var bbox2;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            if (segment.isVisible) {
              var segmentBBox = segment.bbox();
              bbox2 = bbox2 ? bbox2.union(segmentBBox) : segmentBBox;
            }
          }
          if (bbox2) return bbox2;
          var lastSegment = segments[numSegments - 1];
          return new Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);
        },
        // Returns a new path that is a clone of this path.
        clone: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          var path2 = new Path$1();
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i].clone();
            path2.appendSegment(segment);
          }
          return path2;
        },
        closestPoint: function(p, opt) {
          var t = this.closestPointT(p, opt);
          if (!t) return null;
          return this.pointAtT(t);
        },
        closestPointLength: function(p, opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var t = this.closestPointT(p, localOpt);
          if (!t) return 0;
          return this.lengthAtT(t, localOpt);
        },
        closestPointNormalizedLength: function(p, opt) {
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var cpLength = this.closestPointLength(p, localOpt);
          if (cpLength === 0) return 0;
          var length2 = this.length(localOpt);
          if (length2 === 0) return 0;
          return cpLength / length2;
        },
        // Private function.
        closestPointT: function(p, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var closestPointT;
          var minSquaredDistance = Infinity;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            if (segment.isVisible) {
              var segmentClosestPointT = segment.closestPointT(p, {
                precision,
                subdivisions
              });
              var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
              var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();
              if (squaredDistance < minSquaredDistance) {
                closestPointT = {
                  segmentIndex: i,
                  value: segmentClosestPointT
                };
                minSquaredDistance = squaredDistance;
              }
            }
          }
          if (closestPointT) return closestPointT;
          return {
            segmentIndex: numSegments - 1,
            value: 1
          };
        },
        closestPointTangent: function(p, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var closestPointTangent;
          var minSquaredDistance = Infinity;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            if (segment.isDifferentiable()) {
              var segmentClosestPointT = segment.closestPointT(p, {
                precision,
                subdivisions
              });
              var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);
              var squaredDistance = new Line(segmentClosestPoint, p).squaredLength();
              if (squaredDistance < minSquaredDistance) {
                closestPointTangent = segment.tangentAtT(segmentClosestPointT);
                minSquaredDistance = squaredDistance;
              }
            }
          }
          if (closestPointTangent) return closestPointTangent;
          return null;
        },
        // Returns `true` if the area surrounded by the path contains the point `p`.
        // Implements the even-odd algorithm (self-intersections are "outside").
        // Closes open paths (always imagines a final closing segment).
        // Precision may be adjusted by passing an `opt` object.
        containsPoint: function(p, opt) {
          var polylines = this.toPolylines(opt);
          if (!polylines) return false;
          var numPolylines = polylines.length;
          var numIntersections = 0;
          for (var i = 0; i < numPolylines; i++) {
            var polyline = polylines[i];
            if (polyline.containsPoint(p)) {
              numIntersections++;
            }
          }
          return numIntersections % 2 === 1;
        },
        // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.
        divideAt: function(ratio, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          if (ratio < 0) ratio = 0;
          if (ratio > 1) ratio = 1;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var pathLength = this.length(localOpt);
          var length2 = pathLength * ratio;
          return this.divideAtLength(length2, localOpt);
        },
        // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.
        divideAtLength: function(length2, opt) {
          var numSegments = this.segments.length;
          if (numSegments === 0) return null;
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var i;
          var segment;
          var l = 0;
          var divided;
          var dividedSegmentIndex;
          var lastValidSegment;
          var lastValidSegmentIndex;
          var t;
          for (i = 0; i < numSegments; i++) {
            var index2 = fromStart ? i : numSegments - 1 - i;
            segment = this.getSegment(index2);
            var subdivisions = segmentSubdivisions[index2];
            var d = segment.length({
              precision,
              subdivisions
            });
            if (segment.isDifferentiable()) {
              lastValidSegment = segment;
              lastValidSegmentIndex = index2;
              if (length2 <= l + d) {
                dividedSegmentIndex = index2;
                divided = segment.divideAtLength((fromStart ? 1 : -1) * (length2 - l), {
                  precision,
                  subdivisions
                });
                break;
              }
            }
            l += d;
          }
          if (!lastValidSegment) {
            return null;
          }
          if (!divided) {
            dividedSegmentIndex = lastValidSegmentIndex;
            t = fromStart ? 1 : 0;
            divided = lastValidSegment.divideAtT(t);
          }
          var pathCopy = this.clone();
          pathCopy.replaceSegment(dividedSegmentIndex, divided);
          var divisionStartIndex = dividedSegmentIndex;
          var divisionMidIndex = dividedSegmentIndex + 1;
          var divisionEndIndex = dividedSegmentIndex + 2;
          if (!divided[0].isDifferentiable()) {
            pathCopy.removeSegment(divisionStartIndex);
            divisionMidIndex -= 1;
            divisionEndIndex -= 1;
          }
          var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;
          pathCopy.insertSegment(divisionMidIndex, Path$1.createSegment("M", movetoEnd));
          divisionEndIndex += 1;
          if (!divided[1].isDifferentiable()) {
            pathCopy.removeSegment(divisionEndIndex - 1);
            divisionEndIndex -= 1;
          }
          var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;
          for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {
            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);
            segment = pathCopy.getSegment(i);
            if (segment.type === "Z" && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {
              var convertedSegment = Path$1.createSegment("L", originalSegment.end);
              pathCopy.replaceSegment(i, convertedSegment);
            }
          }
          var firstPath = new Path$1(pathCopy.segments.slice(0, divisionMidIndex));
          var secondPath = new Path$1(pathCopy.segments.slice(divisionMidIndex));
          return [firstPath, secondPath];
        },
        // Checks whether two paths are exactly the same.
        // If `p` is undefined or null, returns false.
        equals: function(p) {
          if (!p) return false;
          var segments = this.segments;
          var otherSegments = p.segments;
          var numSegments = segments.length;
          if (otherSegments.length !== numSegments) return false;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            var otherSegment = otherSegments[i];
            if (segment.type !== otherSegment.type || !segment.equals(otherSegment)) return false;
          }
          return true;
        },
        // Accepts negative indices.
        // Throws an error if path has no segments.
        // Throws an error if index is out of range.
        getSegment: function(index2) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) throw new Error("Path has no segments.");
          if (index2 < 0) index2 = numSegments + index2;
          if (index2 >= numSegments || index2 < 0) throw new Error("Index out of range.");
          return segments[index2];
        },
        // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.
        getSegmentSubdivisions: function(opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = [];
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            var subdivisions = segment.getSubdivisions({
              precision
            });
            segmentSubdivisions.push(subdivisions);
          }
          return segmentSubdivisions;
        },
        // Returns an array of subpaths of this path.
        // Invalid paths are validated first.
        // Returns `[]` if path has no segments.
        getSubpaths: function() {
          const validatedPath = this.clone().validate();
          const segments = validatedPath.segments;
          const numSegments = segments.length;
          const subpaths = [];
          for (let i = 0; i < numSegments; i++) {
            const segment = segments[i];
            if (segment.isSubpathStart) {
              subpaths.push(new Path$1(segment));
            } else {
              subpaths[subpaths.length - 1].appendSegment(segment);
            }
          }
          return subpaths;
        },
        // Insert `arg` at given `index`.
        // `index = 0` means insert at the beginning.
        // `index = segments.length` means insert at the end.
        // Accepts negative indices, from `-1` to `-(segments.length + 1)`.
        // Accepts one segment or an array of segments as argument.
        // Throws an error if index is out of range.
        // Throws an error if argument is not a segment or an array of segments.
        insertSegment: function(index2, arg) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (index2 < 0) index2 = numSegments + index2 + 1;
          if (index2 > numSegments || index2 < 0) throw new Error("Index out of range.");
          var currentSegment;
          var previousSegment = null;
          var nextSegment = null;
          if (numSegments !== 0) {
            if (index2 >= 1) {
              previousSegment = segments[index2 - 1];
              nextSegment = previousSegment.nextSegment;
            } else {
              nextSegment = segments[0];
            }
          }
          if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.splice(index2, 0, currentSegment);
          } else {
            arg = arg.reduce(function(acc, val) {
              return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            var n = arg.length;
            for (var i = 0; i < n; i++) {
              var currentArg = arg[i];
              currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
              segments.splice(index2 + i, 0, currentSegment);
              previousSegment = currentSegment;
            }
          }
        },
        intersectionWithLine: function(line2, opt) {
          var intersection2 = null;
          var polylines = this.toPolylines(opt);
          if (!polylines) return null;
          for (var i = 0, n = polylines.length; i < n; i++) {
            var polyline = polylines[i];
            var polylineIntersection = line2.intersect(polyline);
            if (polylineIntersection) {
              intersection2 || (intersection2 = []);
              if (Array.isArray(polylineIntersection)) {
                Array.prototype.push.apply(intersection2, polylineIntersection);
              } else {
                intersection2.push(polylineIntersection);
              }
            }
          }
          return intersection2;
        },
        isDifferentiable: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            if (segment.isDifferentiable()) return true;
          }
          return false;
        },
        // Checks whether current path segments are valid.
        // Note that d is allowed to be empty - should disable rendering of the path.
        isValid: function() {
          var segments = this.segments;
          var isValid = segments.length === 0 || segments[0].type === "M";
          return isValid;
        },
        // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.
        // If path has no segments, returns 0.
        length: function(opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return 0;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var length2 = 0;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            var subdivisions = segmentSubdivisions[i];
            length2 += segment.length({
              subdivisions
            });
          }
          return length2;
        },
        // Private function.
        lengthAtT: function(t, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return 0;
          var segmentIndex = t.segmentIndex;
          if (segmentIndex < 0) return 0;
          var tValue = t.value;
          if (segmentIndex >= numSegments) {
            segmentIndex = numSegments - 1;
            tValue = 1;
          } else if (tValue < 0) tValue = 0;
          else if (tValue > 1) tValue = 1;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var subdivisions;
          var length2 = 0;
          for (var i = 0; i < segmentIndex; i++) {
            var segment = segments[i];
            subdivisions = segmentSubdivisions[i];
            length2 += segment.length({
              precisison: precision,
              subdivisions
            });
          }
          segment = segments[segmentIndex];
          subdivisions = segmentSubdivisions[segmentIndex];
          length2 += segment.lengthAtT(tValue, {
            precisison: precision,
            subdivisions
          });
          return length2;
        },
        // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
        pointAt: function(ratio, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          if (ratio <= 0) return this.start.clone();
          if (ratio >= 1) return this.end.clone();
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var pathLength = this.length(localOpt);
          var length2 = pathLength * ratio;
          return this.pointAtLength(length2, localOpt);
        },
        // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
        // Accepts negative length.
        pointAtLength: function(length2, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          if (length2 === 0) return this.start.clone();
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var lastVisibleSegment;
          var l = 0;
          for (var i = 0; i < numSegments; i++) {
            var index2 = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index2];
            var subdivisions = segmentSubdivisions[index2];
            var d = segment.length({
              precision,
              subdivisions
            });
            if (segment.isVisible) {
              if (length2 <= l + d) {
                return segment.pointAtLength((fromStart ? 1 : -1) * (length2 - l), {
                  precision,
                  subdivisions
                });
              }
              lastVisibleSegment = segment;
            }
            l += d;
          }
          if (lastVisibleSegment) return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;
          var lastSegment = segments[numSegments - 1];
          return lastSegment.end.clone();
        },
        // Private function.
        pointAtT: function(t) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          var segmentIndex = t.segmentIndex;
          if (segmentIndex < 0) return segments[0].pointAtT(0);
          if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);
          var tValue = t.value;
          if (tValue < 0) tValue = 0;
          else if (tValue > 1) tValue = 1;
          return segments[segmentIndex].pointAtT(tValue);
        },
        // Default precision
        PRECISION: 3,
        // Helper method for adding segments.
        prepareSegment: function(segment, previousSegment, nextSegment) {
          segment.previousSegment = previousSegment;
          segment.nextSegment = nextSegment;
          if (previousSegment) previousSegment.nextSegment = segment;
          if (nextSegment) nextSegment.previousSegment = segment;
          var updateSubpathStart = segment;
          if (segment.isSubpathStart) {
            segment.subpathStartSegment = segment;
            updateSubpathStart = nextSegment;
          }
          if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);
          return segment;
        },
        // Remove the segment at `index`.
        // Accepts negative indices, from `-1` to `-segments.length`.
        // Throws an error if path has no segments.
        // Throws an error if index is out of range.
        removeSegment: function(index2) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) throw new Error("Path has no segments.");
          if (index2 < 0) index2 = numSegments + index2;
          if (index2 >= numSegments || index2 < 0) throw new Error("Index out of range.");
          var removedSegment = segments.splice(index2, 1)[0];
          var previousSegment = removedSegment.previousSegment;
          var nextSegment = removedSegment.nextSegment;
          if (previousSegment) previousSegment.nextSegment = nextSegment;
          if (nextSegment) nextSegment.previousSegment = previousSegment;
          if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
        },
        // Replace the segment at `index` with `arg`.
        // Accepts negative indices, from `-1` to `-segments.length`.
        // Accepts one segment or an array of segments as argument.
        // Throws an error if path has no segments.
        // Throws an error if index is out of range.
        // Throws an error if argument is not a segment or an array of segments.
        replaceSegment: function(index2, arg) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) throw new Error("Path has no segments.");
          if (index2 < 0) index2 = numSegments + index2;
          if (index2 >= numSegments || index2 < 0) throw new Error("Index out of range.");
          var currentSegment;
          var replacedSegment = segments[index2];
          var previousSegment = replacedSegment.previousSegment;
          var nextSegment = replacedSegment.nextSegment;
          var updateSubpathStart = replacedSegment.isSubpathStart;
          if (!Array.isArray(arg)) {
            if (!arg || !arg.isSegment) throw new Error("Segment required.");
            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);
            segments.splice(index2, 1, currentSegment);
            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false;
          } else {
            arg = arg.reduce(function(acc, val) {
              return acc.concat(val);
            }, []);
            if (!arg[0].isSegment) throw new Error("Segments required.");
            segments.splice(index2, 1);
            var n = arg.length;
            for (var i = 0; i < n; i++) {
              var currentArg = arg[i];
              currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);
              segments.splice(index2 + i, 0, currentSegment);
              previousSegment = currentSegment;
              if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false;
            }
          }
          if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);
        },
        round: function(precision) {
          var segments = this.segments;
          var numSegments = segments.length;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            segment.round(precision);
          }
          return this;
        },
        scale: function(sx, sy, origin) {
          var segments = this.segments;
          var numSegments = segments.length;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            segment.scale(sx, sy, origin);
          }
          return this;
        },
        segmentAt: function(ratio, opt) {
          var index2 = this.segmentIndexAt(ratio, opt);
          if (!index2) return null;
          return this.getSegment(index2);
        },
        // Accepts negative length.
        segmentAtLength: function(length2, opt) {
          var index2 = this.segmentIndexAtLength(length2, opt);
          if (!index2) return null;
          return this.getSegment(index2);
        },
        segmentIndexAt: function(ratio, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          if (ratio < 0) ratio = 0;
          if (ratio > 1) ratio = 1;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var pathLength = this.length(localOpt);
          var length2 = pathLength * ratio;
          return this.segmentIndexAtLength(length2, localOpt);
        },
        // Accepts negative length.
        segmentIndexAtLength: function(length2, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var lastVisibleSegmentIndex = null;
          var l = 0;
          for (var i = 0; i < numSegments; i++) {
            var index2 = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index2];
            var subdivisions = segmentSubdivisions[index2];
            var d = segment.length({
              precision,
              subdivisions
            });
            if (segment.isVisible) {
              if (length2 <= l + d) return index2;
              lastVisibleSegmentIndex = index2;
            }
            l += d;
          }
          return lastVisibleSegmentIndex;
        },
        // Returns a string that can be used to reconstruct the path.
        // Additional error checking compared to toString (must start with M segment).
        serialize: function() {
          if (!this.isValid()) throw new Error("Invalid path segments.");
          return this.toString();
        },
        // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
        tangentAt: function(ratio, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          if (ratio < 0) ratio = 0;
          if (ratio > 1) ratio = 1;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var localOpt = {
            precision,
            segmentSubdivisions
          };
          var pathLength = this.length(localOpt);
          var length2 = pathLength * ratio;
          return this.tangentAtLength(length2, localOpt);
        },
        // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.
        // Accepts negative length.
        tangentAtLength: function(length2, opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          var fromStart = true;
          if (length2 < 0) {
            fromStart = false;
            length2 = -length2;
          }
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var lastValidSegment;
          var l = 0;
          for (var i = 0; i < numSegments; i++) {
            var index2 = fromStart ? i : numSegments - 1 - i;
            var segment = segments[index2];
            var subdivisions = segmentSubdivisions[index2];
            var d = segment.length({
              precision,
              subdivisions
            });
            if (segment.isDifferentiable()) {
              if (length2 <= l + d) {
                return segment.tangentAtLength((fromStart ? 1 : -1) * (length2 - l), {
                  precision,
                  subdivisions
                });
              }
              lastValidSegment = segment;
            }
            l += d;
          }
          if (lastValidSegment) {
            var t = fromStart ? 1 : 0;
            return lastValidSegment.tangentAtT(t);
          }
          return null;
        },
        // Private function.
        tangentAtT: function(t) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          var segmentIndex = t.segmentIndex;
          if (segmentIndex < 0) return segments[0].tangentAtT(0);
          if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);
          var tValue = t.value;
          if (tValue < 0) tValue = 0;
          else if (tValue > 1) tValue = 1;
          return segments[segmentIndex].tangentAtT(tValue);
        },
        toPoints: function(opt) {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          opt = opt || {};
          var precision = opt.precision === void 0 ? this.PRECISION : opt.precision;
          var segmentSubdivisions = opt.segmentSubdivisions === void 0 ? this.getSegmentSubdivisions({
            precision
          }) : opt.segmentSubdivisions;
          var points = [];
          var partialPoints = [];
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            if (segment.isVisible) {
              var currentSegmentSubdivisions = segmentSubdivisions[i];
              if (currentSegmentSubdivisions.length > 0) {
                var subdivisionPoints = currentSegmentSubdivisions.map(function(curve2) {
                  return curve2.start;
                });
                Array.prototype.push.apply(partialPoints, subdivisionPoints);
              } else {
                partialPoints.push(segment.start);
              }
            } else if (partialPoints.length > 0) {
              partialPoints.push(segments[i - 1].end);
              points.push(partialPoints);
              partialPoints = [];
            }
          }
          if (partialPoints.length > 0) {
            partialPoints.push(this.end);
            points.push(partialPoints);
          }
          return points;
        },
        toPolylines: function(opt) {
          var polylines = [];
          var points = this.toPoints(opt);
          if (!points) return null;
          for (var i = 0, n = points.length; i < n; i++) {
            polylines.push(new Polyline$1(points[i]));
          }
          return polylines;
        },
        toString: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          var pathData = "";
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            pathData += segment.serialize() + " ";
          }
          return pathData.trim();
        },
        translate: function(tx, ty) {
          var segments = this.segments;
          var numSegments = segments.length;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            segment.translate(tx, ty);
          }
          return this;
        },
        // Helper method for updating subpath start of segments, starting with the one provided.
        updateSubpathStartSegment: function(segment) {
          var previousSegment = segment.previousSegment;
          while (segment && !segment.isSubpathStart) {
            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment;
            else segment.subpathStartSegment = null;
            previousSegment = segment;
            segment = segment.nextSegment;
          }
        },
        // If the path is not valid, insert M 0 0 at the beginning.
        // Path with no segments is considered valid, so nothing is inserted.
        validate: function() {
          if (!this.isValid()) this.insertSegment(0, Path$1.createSegment("M", 0, 0));
          return this;
        }
      };
      Object.defineProperty(Path$1.prototype, "start", {
        // Getter for the first visible endpoint of the path.
        configurable: true,
        enumerable: true,
        get: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          for (var i = 0; i < numSegments; i++) {
            var segment = segments[i];
            if (segment.isVisible) return segment.start;
          }
          return segments[numSegments - 1].end;
        }
      });
      Object.defineProperty(Path$1.prototype, "end", {
        // Getter for the last visible endpoint of the path.
        configurable: true,
        enumerable: true,
        get: function() {
          var segments = this.segments;
          var numSegments = segments.length;
          if (numSegments === 0) return null;
          for (var i = numSegments - 1; i >= 0; i--) {
            var segment = segments[i];
            if (segment.isVisible) return segment.end;
          }
          return segments[numSegments - 1].end;
        }
      });
      function applyToNew(constructor, argsArray) {
        argsArray.unshift(null);
        return new (Function.prototype.bind.apply(constructor, argsArray))();
      }
      var segmentPrototype = {
        // virtual
        bbox: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        clone: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        closestPoint: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        closestPointLength: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        closestPointNormalizedLength: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.
        closestPointT: function(p) {
          if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);
          throw new Error("Neither closestPointT() nor closestPointNormalizedLength() function is implemented.");
        },
        // virtual
        closestPointTangent: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        divideAt: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        divideAtLength: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // Redirect calls to divideAt() function if divideAtT() is not defined for segment.
        divideAtT: function(t) {
          if (this.divideAt) return this.divideAt(t);
          throw new Error("Neither divideAtT() nor divideAt() function is implemented.");
        },
        // virtual
        equals: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        getSubdivisions: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        isDifferentiable: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        isSegment: true,
        isSubpathStart: false,
        // true for Moveto segments
        isVisible: true,
        // false for Moveto segments
        // virtual
        length: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // Return a fraction of result of length() function if lengthAtT() is not defined for segment.
        lengthAtT: function(t) {
          if (t <= 0) return 0;
          var length2 = this.length();
          if (t >= 1) return length2;
          return length2 * t;
        },
        nextSegment: null,
        // needed for subpath start segment updating
        // virtual
        pointAt: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        pointAtLength: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // Redirect calls to pointAt() function if pointAtT() is not defined for segment.
        pointAtT: function(t) {
          if (this.pointAt) return this.pointAt(t);
          throw new Error("Neither pointAtT() nor pointAt() function is implemented.");
        },
        previousSegment: null,
        // needed to get segment start property
        // virtual
        round: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        subpathStartSegment: null,
        // needed to get Closepath segment end property
        // virtual
        scale: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        serialize: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        tangentAt: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        tangentAtLength: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.
        tangentAtT: function(t) {
          if (this.tangentAt) return this.tangentAt(t);
          throw new Error("Neither tangentAtT() nor tangentAt() function is implemented.");
        },
        // virtual
        toString: function() {
          throw new Error("Declaration missing for virtual function.");
        },
        // virtual
        translate: function() {
          throw new Error("Declaration missing for virtual function.");
        }
      };
      Object.defineProperty(segmentPrototype, "end", {
        configurable: true,
        enumerable: true,
        writable: true
      });
      Object.defineProperty(segmentPrototype, "start", {
        // get a reference to the end point of previous segment
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.previousSegment) throw new Error("Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)");
          return this.previousSegment.end;
        }
      });
      Object.defineProperty(segmentPrototype, "type", {
        configurable: true,
        enumerable: true,
        get: function() {
          throw new Error("Bad segment declaration. No type specified.");
        }
      });
      var Lineto = function() {
        var args = [];
        var n = arguments.length;
        for (var i = 0; i < n; i++) {
          args.push(arguments[i]);
        }
        if (!(this instanceof Lineto)) {
          return applyToNew(Lineto, args);
        }
        if (n === 0) {
          throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).");
        }
        var outputArray;
        if (args[0] instanceof Line) {
          if (n === 1) {
            this.end = args[0].end.clone();
            return this;
          } else {
            throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + n + " lines provided).");
          }
        } else if (typeof args[0] === "string" || typeof args[0] === "number") {
          if (n === 2) {
            this.end = new Point(+args[0], +args[1]);
            return this;
          } else if (n < 2) {
            throw new Error("Lineto constructor expects a line, 1 point, or 2 coordinates (" + n + " coordinates provided).");
          } else {
            var segmentCoords;
            outputArray = [];
            for (i = 0; i < n; i += 2) {
              segmentCoords = args.slice(i, i + 2);
              outputArray.push(applyToNew(Lineto, segmentCoords));
            }
            return outputArray;
          }
        } else {
          if (n === 1) {
            this.end = new Point(args[0]);
            return this;
          } else {
            var segmentPoint;
            outputArray = [];
            for (i = 0; i < n; i += 1) {
              segmentPoint = args[i];
              outputArray.push(new Lineto(segmentPoint));
            }
            return outputArray;
          }
        }
      };
      var linetoPrototype = {
        clone: function() {
          return new Lineto(this.end);
        },
        divideAt: function(ratio) {
          var line2 = new Line(this.start, this.end);
          var divided = line2.divideAt(ratio);
          return [new Lineto(divided[0]), new Lineto(divided[1])];
        },
        divideAtLength: function(length2) {
          var line2 = new Line(this.start, this.end);
          var divided = line2.divideAtLength(length2);
          return [new Lineto(divided[0]), new Lineto(divided[1])];
        },
        getSubdivisions: function() {
          return [];
        },
        isDifferentiable: function() {
          if (!this.previousSegment) return false;
          return !this.start.equals(this.end);
        },
        round: function(precision) {
          this.end.round(precision);
          return this;
        },
        scale: function(sx, sy, origin) {
          this.end.scale(sx, sy, origin);
          return this;
        },
        serialize: function() {
          var end = this.end;
          return this.type + " " + end.x + " " + end.y;
        },
        toString: function() {
          return this.type + " " + this.start + " " + this.end;
        },
        translate: function(tx, ty) {
          this.end.translate(tx, ty);
          return this;
        }
      };
      Object.defineProperty(linetoPrototype, "type", {
        configurable: true,
        enumerable: true,
        value: "L"
      });
      Lineto.prototype = extend$1(segmentPrototype, Line.prototype, linetoPrototype);
      var Curveto = function() {
        var args = [];
        var n = arguments.length;
        for (var i = 0; i < n; i++) {
          args.push(arguments[i]);
        }
        if (!(this instanceof Curveto)) {
          return applyToNew(Curveto, args);
        }
        if (n === 0) {
          throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).");
        }
        var outputArray;
        if (args[0] instanceof Curve) {
          if (n === 1) {
            this.controlPoint1 = args[0].controlPoint1.clone();
            this.controlPoint2 = args[0].controlPoint2.clone();
            this.end = args[0].end.clone();
            return this;
          } else {
            throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " curves provided).");
          }
        } else if (typeof args[0] === "string" || typeof args[0] === "number") {
          if (n === 6) {
            this.controlPoint1 = new Point(+args[0], +args[1]);
            this.controlPoint2 = new Point(+args[2], +args[3]);
            this.end = new Point(+args[4], +args[5]);
            return this;
          } else if (n < 6) {
            throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " coordinates provided).");
          } else {
            var segmentCoords;
            outputArray = [];
            for (i = 0; i < n; i += 6) {
              segmentCoords = args.slice(i, i + 6);
              outputArray.push(applyToNew(Curveto, segmentCoords));
            }
            return outputArray;
          }
        } else {
          if (n === 3) {
            this.controlPoint1 = new Point(args[0]);
            this.controlPoint2 = new Point(args[1]);
            this.end = new Point(args[2]);
            return this;
          } else if (n < 3) {
            throw new Error("Curveto constructor expects a curve, 3 points, or 6 coordinates (" + n + " points provided).");
          } else {
            var segmentPoints;
            outputArray = [];
            for (i = 0; i < n; i += 3) {
              segmentPoints = args.slice(i, i + 3);
              outputArray.push(applyToNew(Curveto, segmentPoints));
            }
            return outputArray;
          }
        }
      };
      var curvetoPrototype = {
        clone: function() {
          return new Curveto(this.controlPoint1, this.controlPoint2, this.end);
        },
        divideAt: function(ratio, opt) {
          var curve2 = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
          var divided = curve2.divideAt(ratio, opt);
          return [new Curveto(divided[0]), new Curveto(divided[1])];
        },
        divideAtLength: function(length2, opt) {
          var curve2 = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
          var divided = curve2.divideAtLength(length2, opt);
          return [new Curveto(divided[0]), new Curveto(divided[1])];
        },
        divideAtT: function(t) {
          var curve2 = new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);
          var divided = curve2.divideAtT(t);
          return [new Curveto(divided[0]), new Curveto(divided[1])];
        },
        isDifferentiable: function() {
          if (!this.previousSegment) return false;
          var start = this.start;
          var control1 = this.controlPoint1;
          var control2 = this.controlPoint2;
          var end = this.end;
          return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));
        },
        round: function(precision) {
          this.controlPoint1.round(precision);
          this.controlPoint2.round(precision);
          this.end.round(precision);
          return this;
        },
        scale: function(sx, sy, origin) {
          this.controlPoint1.scale(sx, sy, origin);
          this.controlPoint2.scale(sx, sy, origin);
          this.end.scale(sx, sy, origin);
          return this;
        },
        serialize: function() {
          var c1 = this.controlPoint1;
          var c2 = this.controlPoint2;
          var end = this.end;
          return this.type + " " + c1.x + " " + c1.y + " " + c2.x + " " + c2.y + " " + end.x + " " + end.y;
        },
        toString: function() {
          return this.type + " " + this.start + " " + this.controlPoint1 + " " + this.controlPoint2 + " " + this.end;
        },
        translate: function(tx, ty) {
          this.controlPoint1.translate(tx, ty);
          this.controlPoint2.translate(tx, ty);
          this.end.translate(tx, ty);
          return this;
        }
      };
      Object.defineProperty(curvetoPrototype, "type", {
        configurable: true,
        enumerable: true,
        value: "C"
      });
      Curveto.prototype = extend$1(segmentPrototype, Curve.prototype, curvetoPrototype);
      var Moveto = function() {
        var args = [];
        var n = arguments.length;
        for (var i = 0; i < n; i++) {
          args.push(arguments[i]);
        }
        if (!(this instanceof Moveto)) {
          return applyToNew(Moveto, args);
        }
        if (n === 0) {
          throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).");
        }
        var outputArray;
        if (args[0] instanceof Line) {
          if (n === 1) {
            this.end = args[0].end.clone();
            return this;
          } else {
            throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " lines provided).");
          }
        } else if (args[0] instanceof Curve) {
          if (n === 1) {
            this.end = args[0].end.clone();
            return this;
          } else {
            throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " curves provided).");
          }
        } else if (typeof args[0] === "string" || typeof args[0] === "number") {
          if (n === 2) {
            this.end = new Point(+args[0], +args[1]);
            return this;
          } else if (n < 2) {
            throw new Error("Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (" + n + " coordinates provided).");
          } else {
            var segmentCoords;
            outputArray = [];
            for (i = 0; i < n; i += 2) {
              segmentCoords = args.slice(i, i + 2);
              if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));
              else outputArray.push(applyToNew(Lineto, segmentCoords));
            }
            return outputArray;
          }
        } else {
          if (n === 1) {
            this.end = new Point(args[0]);
            return this;
          } else {
            var segmentPoint;
            outputArray = [];
            for (i = 0; i < n; i += 1) {
              segmentPoint = args[i];
              if (i === 0) outputArray.push(new Moveto(segmentPoint));
              else outputArray.push(new Lineto(segmentPoint));
            }
            return outputArray;
          }
        }
      };
      var movetoPrototype = {
        bbox: function() {
          return null;
        },
        clone: function() {
          return new Moveto(this.end);
        },
        closestPoint: function() {
          return this.end.clone();
        },
        closestPointNormalizedLength: function() {
          return 0;
        },
        closestPointLength: function() {
          return 0;
        },
        closestPointT: function() {
          return 1;
        },
        closestPointTangent: function() {
          return null;
        },
        divideAt: function() {
          return [this.clone(), this.clone()];
        },
        divideAtLength: function() {
          return [this.clone(), this.clone()];
        },
        equals: function(m) {
          return this.end.equals(m.end);
        },
        getSubdivisions: function() {
          return [];
        },
        isDifferentiable: function() {
          return false;
        },
        isSubpathStart: true,
        isVisible: false,
        length: function() {
          return 0;
        },
        lengthAtT: function() {
          return 0;
        },
        pointAt: function() {
          return this.end.clone();
        },
        pointAtLength: function() {
          return this.end.clone();
        },
        pointAtT: function() {
          return this.end.clone();
        },
        round: function(precision) {
          this.end.round(precision);
          return this;
        },
        scale: function(sx, sy, origin) {
          this.end.scale(sx, sy, origin);
          return this;
        },
        serialize: function() {
          var end = this.end;
          return this.type + " " + end.x + " " + end.y;
        },
        tangentAt: function() {
          return null;
        },
        tangentAtLength: function() {
          return null;
        },
        tangentAtT: function() {
          return null;
        },
        toString: function() {
          return this.type + " " + this.end;
        },
        translate: function(tx, ty) {
          this.end.translate(tx, ty);
          return this;
        }
      };
      Object.defineProperty(movetoPrototype, "start", {
        configurable: true,
        enumerable: true,
        get: function() {
          throw new Error("Illegal access. Moveto segments should not need a start property.");
        }
      });
      Object.defineProperty(movetoPrototype, "type", {
        configurable: true,
        enumerable: true,
        value: "M"
      });
      Moveto.prototype = extend$1(segmentPrototype, movetoPrototype);
      var Closepath = function() {
        var args = [];
        var n = arguments.length;
        for (var i = 0; i < n; i++) {
          args.push(arguments[i]);
        }
        if (!(this instanceof Closepath)) {
          return applyToNew(Closepath, args);
        }
        if (n > 0) {
          throw new Error("Closepath constructor expects no arguments.");
        }
        return this;
      };
      var closepathPrototype = {
        clone: function() {
          return new Closepath();
        },
        divideAt: function(ratio) {
          var line2 = new Line(this.start, this.end);
          var divided = line2.divideAt(ratio);
          return [
            // if we didn't actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),
            new Lineto(divided[1])
          ];
        },
        divideAtLength: function(length2) {
          var line2 = new Line(this.start, this.end);
          var divided = line2.divideAtLength(length2);
          return [
            // if we didn't actually cut into the segment, first divided part can stay as Z
            divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone(),
            new Lineto(divided[1])
          ];
        },
        getSubdivisions: function() {
          return [];
        },
        isDifferentiable: function() {
          if (!this.previousSegment || !this.subpathStartSegment) return false;
          return !this.start.equals(this.end);
        },
        round: function() {
          return this;
        },
        scale: function() {
          return this;
        },
        serialize: function() {
          return this.type;
        },
        toString: function() {
          return this.type + " " + this.start + " " + this.end;
        },
        translate: function() {
          return this;
        }
      };
      Object.defineProperty(closepathPrototype, "end", {
        // get a reference to the end point of subpath start segment
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.subpathStartSegment) throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)");
          return this.subpathStartSegment.end;
        }
      });
      Object.defineProperty(closepathPrototype, "type", {
        configurable: true,
        enumerable: true,
        value: "Z"
      });
      Closepath.prototype = extend$1(segmentPrototype, Line.prototype, closepathPrototype);
      var segmentTypes = Path$1.segmentTypes = {
        L: Lineto,
        C: Curveto,
        M: Moveto,
        Z: Closepath,
        z: Closepath
      };
      Path$1.regexSupportedData = new RegExp("^[\\s\\d" + Object.keys(segmentTypes).join("") + ",.]*$");
      Path$1.isDataSupported = function(data2) {
        if (typeof data2 !== "string") return false;
        return this.regexSupportedData.test(data2);
      };
      const bezier = {
        // Cubic Bezier curve path through points.
        // @deprecated
        // @param {array} points Array of points through which the smooth line will go.
        // @return {array} SVG Path commands as an array
        curveThroughPoints: function(points) {
          console.warn("deprecated");
          return new Path$1(Curve.throughPoints(points)).serialize();
        },
        // Get open-ended Bezier Spline Control Points.
        // @deprecated
        // @param knots Input Knot Bezier spline points (At least two points!).
        // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.
        // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.
        getCurveControlPoints: function(knots) {
          console.warn("deprecated");
          var firstControlPoints = [];
          var secondControlPoints = [];
          var n = knots.length - 1;
          var i;
          if (n == 1) {
            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);
            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);
            return [firstControlPoints, secondControlPoints];
          }
          var rhs = [];
          for (i = 1; i < n - 1; i++) {
            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;
          }
          rhs[0] = knots[0].x + 2 * knots[1].x;
          rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2;
          var x = this.getFirstControlPoints(rhs);
          for (i = 1; i < n - 1; ++i) {
            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;
          }
          rhs[0] = knots[0].y + 2 * knots[1].y;
          rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2;
          var y = this.getFirstControlPoints(rhs);
          for (i = 0; i < n; i++) {
            firstControlPoints.push(new Point(x[i], y[i]));
            if (i < n - 1) {
              secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));
            } else {
              secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));
            }
          }
          return [firstControlPoints, secondControlPoints];
        },
        // Divide a Bezier curve into two at point defined by value 't' <0,1>.
        // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867
        // @deprecated
        // @param control points (start, control start, control end, end)
        // @return a function that accepts t and returns 2 curves.
        getCurveDivider: function(p0, p1, p2, p3) {
          console.warn("deprecated");
          var curve2 = new Curve(p0, p1, p2, p3);
          return function divideCurve(t) {
            var divided = curve2.divide(t);
            return [{
              p0: divided[0].start,
              p1: divided[0].controlPoint1,
              p2: divided[0].controlPoint2,
              p3: divided[0].end
            }, {
              p0: divided[1].start,
              p1: divided[1].controlPoint1,
              p2: divided[1].controlPoint2,
              p3: divided[1].end
            }];
          };
        },
        // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.
        // @deprecated
        // @param rhs Right hand side vector.
        // @return Solution vector.
        getFirstControlPoints: function(rhs) {
          console.warn("deprecated");
          var n = rhs.length;
          var x = [];
          var tmp = [];
          var b = 2;
          x[0] = rhs[0] / b;
          for (var i = 1; i < n; i++) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4 : 3.5) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
          }
          for (i = 1; i < n; i++) {
            x[n - i - 1] -= tmp[n - i] * x[n - i];
          }
          return x;
        },
        // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on
        // a parametric curve x = x(t)/w(t), y = y(t)/w(t), ï¬nd the parameter value t
        // which corresponds to that point.
        // @deprecated
        // @param control points (start, control start, control end, end)
        // @return a function that accepts a point and returns t.
        getInversionSolver: function(p0, p1, p2, p3) {
          console.warn("deprecated");
          var curve2 = new Curve(p0, p1, p2, p3);
          return function solveInversion(p) {
            return curve2.closestPointT(p);
          };
        }
      };
      const Polygon$1 = function(points) {
        if (!(this instanceof Polygon$1)) {
          return new Polygon$1(points);
        }
        if (typeof points === "string") {
          return new Polygon$1.parse(points);
        }
        this.points = Array.isArray(points) ? points.map(Point) : [];
      };
      Polygon$1.parse = function(svgString) {
        return new Polygon$1(parsePoints(svgString));
      };
      Polygon$1.fromRect = function(rect2) {
        return new Polygon$1([rect2.topLeft(), rect2.topRight(), rect2.bottomRight(), rect2.bottomLeft()]);
      };
      Polygon$1.prototype = extend$1(Polyline$1.prototype, {
        type: types.Polygon,
        clone: function() {
          return new Polygon$1(clonePoints(this.points));
        },
        convexHull: function() {
          return new Polygon$1(convexHull(this.points));
        },
        lengthPoints: function() {
          const {
            start,
            end,
            points
          } = this;
          if (points.length <= 1 || start.equals(end)) return points;
          return [...points, start.clone()];
        }
      });
      function exists(shape1, shape2, shape1opt, shape2opt) {
        switch (shape1.type) {
          case types.Line: {
            switch (shape2.type) {
              case types.Line: {
                return lineWithLine(shape1, shape2);
              }
            }
            break;
          }
          case types.Ellipse: {
            switch (shape2.type) {
              case types.Line: {
                return ellipseWithLine(shape1, shape2);
              }
              case types.Ellipse: {
                return ellipseWithEllipse(shape1, shape2);
              }
            }
            break;
          }
          case types.Rect: {
            switch (shape2.type) {
              case types.Line: {
                return rectWithLine(shape1, shape2);
              }
              case types.Ellipse: {
                return rectWithEllipse(shape1, shape2);
              }
              case types.Rect: {
                return rectWithRect(shape1, shape2);
              }
            }
            break;
          }
          case types.Polyline: {
            switch (shape2.type) {
              case types.Line: {
                return polylineWithLine(shape1, shape2);
              }
              case types.Ellipse: {
                return polylineWithEllipse(shape1, shape2);
              }
              case types.Rect: {
                return polylineWithRect(shape1, shape2);
              }
              case types.Polyline: {
                return polylineWithPolyline(shape1, shape2);
              }
            }
            break;
          }
          case types.Polygon: {
            switch (shape2.type) {
              case types.Line: {
                return polygonWithLine(shape1, shape2);
              }
              case types.Ellipse: {
                return polygonWithEllipse(shape1, shape2);
              }
              case types.Rect: {
                return polygonWithRect(shape1, shape2);
              }
              case types.Polyline: {
                return polygonWithPolyline(shape1, shape2);
              }
              case types.Polygon: {
                return polygonWithPolygon(shape1, shape2);
              }
            }
            break;
          }
          case types.Path: {
            switch (shape2.type) {
              case types.Line: {
                return pathWithLine(shape1, shape2, shape1opt);
              }
              case types.Ellipse: {
                return pathWithEllipse(shape1, shape2, shape1opt);
              }
              case types.Rect: {
                return pathWithRect(shape1, shape2, shape1opt);
              }
              case types.Polyline: {
                return pathWithPolyline(shape1, shape2, shape1opt);
              }
              case types.Polygon: {
                return pathWithPolygon(shape1, shape2, shape1opt);
              }
              case types.Path: {
                return pathWithPath(shape1, shape2, shape1opt, shape2opt);
              }
            }
            break;
          }
        }
        switch (shape2.type) {
          case types.Ellipse:
          case types.Rect:
          case types.Polyline:
          case types.Polygon:
          case types.Path: {
            return exists(shape2, shape1, shape2opt, shape1opt);
          }
          default: {
            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);
          }
        }
      }
      function lineWithLine(line1, line2) {
        const x1 = line1.start.x;
        const y1 = line1.start.y;
        const x2 = line1.end.x;
        const y2 = line1.end.y;
        const x3 = line2.start.x;
        const y3 = line2.start.y;
        const x4 = line2.end.x;
        const y4 = line2.end.y;
        const s1x = x2 - x1;
        const s1y = y2 - y1;
        const s2x = x4 - x3;
        const s2y = y4 - y3;
        const s3x = x1 - x3;
        const s3y = y1 - y3;
        const p = s1x * s2y - s2x * s1y;
        const s = (s1x * s3y - s1y * s3x) / p;
        const t = (s2x * s3y - s2y * s3x) / p;
        return s >= 0 && s <= 1 && t >= 0 && t <= 1;
      }
      function ellipseWithLine(ellipse2, line2) {
        const rex = ellipse2.a;
        const rey = ellipse2.b;
        const xe = ellipse2.x;
        const ye = ellipse2.y;
        const x1 = line2.start.x - xe;
        const x2 = line2.end.x - xe;
        const y1 = line2.start.y - ye;
        const y2 = line2.end.y - ye;
        const rex_2 = rex * rex;
        const rey_2 = rey * rey;
        const dx = x2 - x1;
        const dy = y2 - y1;
        const A = dx * dx / rex_2 + dy * dy / rey_2;
        const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;
        const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;
        const D = B * B - 4 * A * C;
        if (D === 0) {
          const t = -B / 2 / A;
          return t >= 0 && t <= 1;
        } else if (D > 0) {
          const sqrt2 = Math.sqrt(D);
          const t1 = (-B + sqrt2) / 2 / A;
          const t2 = (-B - sqrt2) / 2 / A;
          return t1 >= 0 && t1 <= 1 || t2 >= 0 && t2 <= 1;
        }
        return false;
      }
      function ellipseWithEllipse(ellipse1, ellipse2) {
        return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);
      }
      function rectWithLine(rect2, line2) {
        const {
          start,
          end
        } = line2;
        const {
          x,
          y,
          width: width2,
          height: height2
        } = rect2;
        if (start.x > x + width2 && end.x > x + width2 || start.x < x && end.x < x || start.y > y + height2 && end.y > y + height2 || start.y < y && end.y < y) {
          return false;
        }
        if (rect2.containsPoint(line2.start) || rect2.containsPoint(line2.end)) {
          return true;
        }
        return lineWithLine(rect2.topLine(), line2) || lineWithLine(rect2.rightLine(), line2) || lineWithLine(rect2.bottomLine(), line2) || lineWithLine(rect2.leftLine(), line2);
      }
      function rectWithEllipse(rect2, ellipse2) {
        if (!rectWithRect(rect2, Rect.fromEllipse(ellipse2))) return false;
        return polygonWithEllipse(Polygon$1.fromRect(rect2), ellipse2);
      }
      function rectWithRect(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
      }
      function polylineWithLine(polyline, line2) {
        return _polylineWithLine(polyline, line2, {
          interior: false
        });
      }
      function polylineWithEllipse(polyline, ellipse2) {
        return _polylineWithEllipse(polyline, ellipse2, {
          interior: false
        });
      }
      function polylineWithRect(polyline, rect2) {
        return _polylineWithRect(polyline, rect2, {
          interior: false
        });
      }
      function polylineWithPolyline(polyline1, polyline2) {
        return _polylineWithPolyline(polyline1, polyline2, {
          interior: false
        });
      }
      function polygonWithLine(polygon, line2) {
        return _polylineWithLine(polygon, line2, {
          interior: true
        });
      }
      function polygonWithEllipse(polygon, ellipse2) {
        return _polylineWithEllipse(polygon, ellipse2, {
          interior: true
        });
      }
      function polygonWithRect(polygon, rect2) {
        return _polylineWithRect(polygon, rect2, {
          interior: true
        });
      }
      function polygonWithPolyline(polygon, polyline) {
        return _polylineWithPolyline(polygon, polyline, {
          interior: true
        });
      }
      function polygonWithPolygon(polygon1, polygon2) {
        return _polylineWithPolygon(polygon1, polygon2, {
          interior: true
        });
      }
      function pathWithLine(path2, line2, pathOpt) {
        return path2.getSubpaths().some((subpath) => {
          const [polyline] = subpath.toPolylines(pathOpt);
          const {
            type
          } = subpath.getSegment(-1);
          if (type === "Z") {
            return polygonWithLine(polyline, line2);
          } else {
            return polylineWithLine(polyline, line2);
          }
        });
      }
      function pathWithEllipse(path2, ellipse2, pathOpt) {
        return path2.getSubpaths().some((subpath) => {
          const [polyline] = subpath.toPolylines(pathOpt);
          const {
            type
          } = subpath.getSegment(-1);
          if (type === "Z") {
            return polygonWithEllipse(polyline, ellipse2);
          } else {
            return polylineWithEllipse(polyline, ellipse2);
          }
        });
      }
      function pathWithRect(path2, rect2, pathOpt) {
        return pathWithPolygon(path2, Polygon$1.fromRect(rect2), pathOpt);
      }
      function pathWithPolyline(path2, polyline, pathOpt) {
        return _pathWithPolyline(path2, polyline, pathOpt, {
          interior: false
        });
      }
      function pathWithPolygon(path2, polygon, pathOpt) {
        return _pathWithPolyline(path2, polygon, pathOpt, {
          interior: true
        });
      }
      function pathWithPath(path1, path2, pathOpt1, pathOpt2) {
        return path1.getSubpaths().some((subpath) => {
          const [polyline1] = subpath.toPolylines(pathOpt1);
          const {
            type
          } = subpath.getSegment(-1);
          if (type === "Z") {
            return pathWithPolygon(path2, polyline1, pathOpt2);
          } else {
            return pathWithPolyline(path2, polyline1, pathOpt2);
          }
        });
      }
      function _polylineWithLine(polyline, line2, opt = {}) {
        const {
          interior = false
        } = opt;
        let thisPoints;
        if (interior) {
          if (polyline.containsPoint(line2.start)) {
            return true;
          }
          const {
            start,
            end,
            points
          } = polyline;
          thisPoints = end.equals(start) ? points : [...points, start];
        } else {
          thisPoints = polyline.points;
        }
        const {
          length: length2
        } = thisPoints;
        const segment = new Line();
        for (let i = 0; i < length2 - 1; i++) {
          segment.start = thisPoints[i];
          segment.end = thisPoints[i + 1];
          if (lineWithLine(line2, segment)) {
            return true;
          }
        }
        return false;
      }
      function _polylineWithEllipse(polyline, ellipse2, opt = {}) {
        const {
          start,
          end,
          points
        } = polyline;
        if (ellipse2.containsPoint(start)) {
          return true;
        }
        let thisPoints;
        const {
          interior = false
        } = opt;
        if (interior) {
          if (polyline.containsPoint(ellipse2.center())) {
            return true;
          }
          thisPoints = end.equals(start) ? points : [...points, start];
        } else {
          thisPoints = points;
        }
        const {
          length: length2
        } = thisPoints;
        const segment = new Line();
        for (let i = 0; i < length2 - 1; i++) {
          segment.start = thisPoints[i];
          segment.end = thisPoints[i + 1];
          if (ellipseWithLine(ellipse2, segment)) {
            return true;
          }
        }
        return false;
      }
      function _polylineWithRect(polyline, rect2, opt) {
        const polygon = Polygon$1.fromRect(rect2);
        return _polylineWithPolygon(polyline, polygon, opt);
      }
      function _pathWithPolyline(path2, polyline1, pathOpt, opt) {
        return path2.getSubpaths().some((subpath) => {
          const [polyline2] = subpath.toPolylines(pathOpt);
          const {
            type
          } = subpath.getSegment(-1);
          if (type === "Z") {
            return _polylineWithPolygon(polyline1, polyline2, opt);
          } else {
            return _polylineWithPolyline(polyline1, polyline2, opt);
          }
        });
      }
      function _polylineWithPolyline(polyline1, polyline2, opt = {}) {
        const {
          interior = false
        } = opt;
        let thisPolyline;
        if (interior) {
          const {
            start
          } = polyline2;
          if (polyline1.containsPoint(start)) {
            return true;
          }
          thisPolyline = polyline1.clone().close();
        } else {
          thisPolyline = polyline1;
        }
        const otherPoints = polyline2.points;
        const {
          length: length2
        } = otherPoints;
        const segment = new Line();
        for (let i = 0; i < length2 - 1; i++) {
          segment.start = otherPoints[i];
          segment.end = otherPoints[i + 1];
          if (polylineWithLine(thisPolyline, segment)) {
            return true;
          }
        }
        return false;
      }
      function _polylineWithPolygon(polyline, polygon, opt) {
        return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);
      }
      function _ellipsesIntersection(e1, w1, e2, w2) {
        const {
          cos: cos2,
          sin: sin2
        } = Math;
        const sinW1 = sin2(w1);
        const cosW1 = cos2(w1);
        const sinW2 = sin2(w2);
        const cosW2 = cos2(w2);
        const sinW1s = sinW1 * sinW1;
        const cosW1s = cosW1 * cosW1;
        const sinCos1 = sinW1 * cosW1;
        const sinW2s = sinW2 * sinW2;
        const cosW2s = cosW2 * cosW2;
        const sinCos2 = sinW2 * cosW2;
        const a1s = e1.a * e1.a;
        const b1s = e1.b * e1.b;
        const a2s = e2.a * e2.a;
        const b2s = e2.b * e2.b;
        const A1 = a1s * sinW1s + b1s * cosW1s;
        const A2 = a2s * sinW2s + b2s * cosW2s;
        const B1 = a1s * cosW1s + b1s * sinW1s;
        const B2 = a2s * cosW2s + b2s * sinW2s;
        let C1 = 2 * (b1s - a1s) * sinCos1;
        let C2 = 2 * (b2s - a2s) * sinCos2;
        let D1 = -2 * A1 * e1.x - C1 * e1.y;
        let D2 = -2 * A2 * e2.x - C2 * e2.y;
        let E1 = -C1 * e1.x - 2 * B1 * e1.y;
        let E2 = -C2 * e2.x - 2 * B2 * e2.y;
        const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;
        const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;
        C1 = C1 / 2;
        C2 = C2 / 2;
        D1 = D1 / 2;
        D2 = D2 / 2;
        E1 = E1 / 2;
        E2 = E2 / 2;
        const l3 = det3([[A1, C1, D1], [C1, B1, E1], [D1, E1, F1]]);
        const l0 = det3([[A2, C2, D2], [C2, B2, E2], [D2, E2, F2]]);
        const l2 = 0.33333333 * (det3([[A2, C1, D1], [C2, B1, E1], [D2, E1, F1]]) + det3([[A1, C2, D1], [C1, B2, E1], [D1, E2, F1]]) + det3([[A1, C1, D2], [C1, B1, E2], [D1, E1, F2]]));
        const l1 = 0.33333333 * (det3([[A1, C2, D2], [C1, B2, E2], [D1, E2, F2]]) + det3([[A2, C1, D2], [C2, B1, E2], [D2, E1, F2]]) + det3([[A2, C2, D1], [C2, B2, E1], [D2, E2, F1]]));
        const delta1 = det2([[l3, l2], [l2, l1]]);
        const delta2 = det2([[l3, l1], [l2, l0]]);
        const delta3 = det2([[l2, l1], [l1, l0]]);
        const dP = det2([[2 * delta1, delta2], [delta2, 2 * delta3]]);
        if (dP > 0 && (l1 > 0 || l2 > 0)) {
          return false;
        }
        return true;
      }
      function det2(m) {
        return m[0][0] * m[1][1] - m[0][1] * m[1][0];
      }
      function det3(m) {
        return m[0][0] * m[1][1] * m[2][2] - m[0][0] * m[1][2] * m[2][1] - m[0][1] * m[1][0] * m[2][2] + m[0][1] * m[1][2] * m[2][0] + m[0][2] * m[1][0] * m[2][1] - m[0][2] * m[1][1] * m[2][0];
      }
      var _intersection = {
        __proto__: null,
        ellipseWithEllipse,
        ellipseWithLine,
        exists,
        lineWithLine,
        pathWithEllipse,
        pathWithLine,
        pathWithPath,
        pathWithPolygon,
        pathWithPolyline,
        pathWithRect,
        polygonWithEllipse,
        polygonWithLine,
        polygonWithPolygon,
        polygonWithPolyline,
        polygonWithRect,
        polylineWithEllipse,
        polylineWithLine,
        polylineWithPolyline,
        polylineWithRect,
        rectWithEllipse,
        rectWithLine,
        rectWithRect
      };
      const intersection$1 = _intersection;
      var g2 = {
        __proto__: null,
        Curve,
        Ellipse: Ellipse$1,
        Line,
        Path: Path$1,
        Point,
        Polygon: Polygon$1,
        Polyline: Polyline$1,
        Rect,
        bezier,
        ellipse: ellipse$1,
        intersection: intersection$1,
        line: line$1,
        normalizeAngle,
        point,
        random,
        rect,
        scale,
        snapToGrid: snapToGrid$1,
        toDeg,
        toRad,
        types
      };
      const argsTag = "[object Arguments]";
      const arrayTag = "[object Array]";
      const boolTag = "[object Boolean]";
      const dateTag = "[object Date]";
      const errorTag = "[object Error]";
      const funcTag = "[object Function]";
      const mapTag = "[object Map]";
      const numberTag = "[object Number]";
      const nullTag = "[object Null]";
      const objectTag = "[object Object]";
      const regexpTag = "[object RegExp]";
      const setTag = "[object Set]";
      const stringTag = "[object String]";
      const symbolTag = "[object Symbol]";
      const undefinedTag = "[object Undefined]";
      const weakMapTag = "[object WeakMap]";
      const arrayBufferTag = "[object ArrayBuffer]";
      const dataViewTag = "[object DataView]";
      const float32Tag = "[object Float32Array]";
      const float64Tag = "[object Float64Array]";
      const int8Tag = "[object Int8Array]";
      const int16Tag = "[object Int16Array]";
      const int32Tag = "[object Int32Array]";
      const uint8Tag = "[object Uint8Array]";
      const uint8ClampedTag = "[object Uint8ClampedArray]";
      const uint16Tag = "[object Uint16Array]";
      const uint32Tag = "[object Uint32Array]";
      const CLONEABLE_TAGS = {
        [argsTag]: true,
        [arrayTag]: true,
        [arrayBufferTag]: true,
        [dataViewTag]: true,
        [boolTag]: true,
        [dateTag]: true,
        [float32Tag]: true,
        [float64Tag]: true,
        [int8Tag]: true,
        [int16Tag]: true,
        [int32Tag]: true,
        [mapTag]: true,
        [numberTag]: true,
        [objectTag]: true,
        [regexpTag]: true,
        [setTag]: true,
        [stringTag]: true,
        [symbolTag]: true,
        [uint8Tag]: true,
        [uint8ClampedTag]: true,
        [uint16Tag]: true,
        [uint32Tag]: true,
        [errorTag]: false,
        [funcTag]: false,
        [weakMapTag]: false
      };
      const rsAstralRange = "\\ud800-\\udfff";
      const rsComboMarksRange = "\\u0300-\\u036f";
      const reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      const rsComboSymbolsRange = "\\u20d0-\\u20ff";
      const rsComboMarksExtendedRange = "\\u1ab0-\\u1aff";
      const rsComboMarksSupplementRange = "\\u1dc0-\\u1dff";
      const rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;
      const rsDingbatRange = "\\u2700-\\u27bf";
      const rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      const rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      const rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      const rsPunctuationRange = "\\u2000-\\u206f";
      const rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      const rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      const rsVarRange = "\\ufe0e\\ufe0f";
      const rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      const rsApos = "['â]";
      const rsBreak = `[${rsBreakRange}]`;
      const rsCombo = `[${rsComboRange}]`;
      const rsDigit = "\\d";
      const rsDingbat = `[${rsDingbatRange}]`;
      const rsLower = `[${rsLowerRange}]`;
      const rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;
      const rsFitz = "\\ud83c[\\udffb-\\udfff]";
      const rsModifier = `(?:${rsCombo}|${rsFitz})`;
      const rsNonAstral = `[^${rsAstralRange}]`;
      const rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      const rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      const rsUpper = `[${rsUpperRange}]`;
      const rsZWJ = "\\u200d";
      const rsMiscLower = `(?:${rsLower}|${rsMisc})`;
      const rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;
      const rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;
      const rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;
      const reOptMod = `${rsModifier}?`;
      const rsOptVar = `[${rsVarRange}]?`;
      const rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join("|")})${rsOptVar + reOptMod})*`;
      const rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
      const rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
      const rsSeq = rsOptVar + reOptMod + rsOptJoin;
      const rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join("|")})${rsSeq}`;
      const reUnicodeWords = RegExp([`${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, "$"].join("|")})`, `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, "$"].join("|")})`, `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`, `${rsUpper}+${rsOptContrUpper}`, rsOrdUpper, rsOrdLower, `${rsDigit}+`, rsEmoji].join("|"), "g");
      const LARGE_ARRAY_SIZE = 200;
      const HASH_UNDEFINED = "__hash_undefined__";
      const reTypedTag = /^\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\]$/;
      const rsAstral = `[${rsAstralRange}]`;
      const rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;
      const rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join("|")})`;
      const reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, "g");
      const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      const reIsPlainProp = /^\w*$/;
      const charCodeOfDot = ".".charCodeAt(0);
      const reEscapeChar = /\\(\\)?/g;
      const rePropName = RegExp(
        // Match anything that isn't a dot or bracket.
        `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
        "g"
      );
      const reIsUint = /^(?:0|[1-9]\d*)$/;
      const hasUnicodeWord = RegExp.prototype.test.bind(/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/);
      const MAX_ARRAY_INDEX = 4294967295 - 1;
      const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      const hasUnicode = (string) => {
        return reUnicode.test(string);
      };
      const unicodeToArray = (string) => {
        return string.match(reUnicode) || [];
      };
      const asciiToArray = (string) => {
        return string.split("");
      };
      const stringToArray = (string) => {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      };
      const values = (object) => {
        if (object == null) {
          return [];
        }
        return keys(object).map((key) => object[key]);
      };
      const keys = (object) => {
        return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));
      };
      const baseKeys = (object) => {
        if (!isPrototype(object)) {
          return Object.keys(object);
        }
        var result2 = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      };
      const arrayLikeKeys = (value, inherited) => {
        const isArr = Array.isArray(value);
        const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;
        const isType = !isArr && !isArg && isTypedArray(value);
        const skipIndexes = isArr || isArg || isType;
        const length2 = value.length;
        const result2 = new Array(skipIndexes ? length2 : 0);
        let index2 = skipIndexes ? -1 : length2;
        while (++index2 < length2) {
          result2[index2] = `${index2}`;
        }
        for (const key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key === "length" || // Skip index properties.
          isIndex(key, length2)))) {
            result2.push(key);
          }
        }
        return result2;
      };
      const assocIndexOf = (array, key) => {
        let {
          length: length2
        } = array;
        while (length2--) {
          if (eq(array[length2][0], key)) {
            return length2;
          }
        }
        return -1;
      };
      const eq = (value, other) => {
        return value === other || value !== value && other !== other;
      };
      const isObjectLike = (value) => {
        return value != null && typeof value == "object";
      };
      const isIterateeCall = (value, index2, object) => {
        if (!isObject(object)) {
          return false;
        }
        const type = typeof index2;
        const isPossibleIteratee = type == "number" ? isArrayLike(object) && index2 > -1 && index2 < object.length : type == "string" && index2 in object;
        if (isPossibleIteratee) {
          return eq(object[index2], value);
        }
        return false;
      };
      const isSet = (value) => {
        return isObjectLike(value) && getTag(value) == setTag;
      };
      const isMap = (value) => {
        return isObjectLike(value) && getTag(value) == mapTag;
      };
      const isPrototype = (value) => {
        const Ctor = value && value.constructor;
        const proto = typeof Ctor === "function" && Ctor.prototype || Object.prototype;
        return value === proto;
      };
      const assignValue = (object, key, value) => {
        const objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          object[key] = value;
        }
      };
      const copyObject = (source, props2, object) => {
        let index2 = -1;
        const length2 = props2.length;
        while (++index2 < length2) {
          const key = props2[index2];
          assignValue(object, key, source[key]);
        }
        return object;
      };
      const isArrayLike = (value) => {
        return value != null && typeof value !== "function" && typeof value.length === "number" && value.length > -1 && value.length % 1 === 0;
      };
      const isSymbol = (value) => {
        return typeof value == "symbol" || isObjectLike(value) && getTag(value) === symbolTag;
      };
      const initCloneArray = (array) => {
        const length2 = array.length;
        let result2 = new array.constructor(length2);
        if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      };
      const copyArray = (source, array) => {
        let index2 = -1;
        const length2 = source.length;
        array || (array = new Array(length2));
        while (++index2 < length2) {
          array[index2] = source[index2];
        }
        return array;
      };
      const getTag = (value) => {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return Object.prototype.toString.call(value);
      };
      const cloneArrayBuffer = (arrayBuffer) => {
        const result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
        return result2;
      };
      const cloneTypedArray = (typedArray, isDeep) => {
        const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      };
      const cloneRegExp = (regexp) => {
        const result2 = new regexp.constructor(regexp.source, /\w*$/.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      };
      const initCloneObject = (object) => {
        return typeof object.constructor == "function" && !isPrototype(object) ? Object.create(Object.getPrototypeOf(object)) : {};
      };
      const getSymbols = (object) => {
        if (object == null) {
          return [];
        }
        object = Object(object);
        const symbols = Object.getOwnPropertySymbols(object);
        return symbols.filter((symbol) => propertyIsEnumerable.call(object, symbol));
      };
      const copySymbols = (source, object) => {
        return copyObject(source, getSymbols(source), object);
      };
      function cloneDataView(dataView, isDeep) {
        const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      const initCloneByTag = (object, tag, isDeep) => {
        const Constructor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Constructor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Constructor(object);
          case numberTag:
          case stringTag:
            return new Constructor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Constructor();
          case symbolTag:
            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};
        }
      };
      const isTypedArray = (value) => {
        return isObjectLike(value) && reTypedTag.test(getTag(value));
      };
      const getAllKeys = (object) => {
        const result2 = Object.keys(object);
        if (!Array.isArray(object) && object != null) {
          result2.push(...getSymbols(Object(object)));
        }
        return result2;
      };
      const getSymbolsIn = (object) => {
        const result2 = [];
        while (object) {
          result2.push(...getSymbols(object));
          object = Object.getPrototypeOf(Object(object));
        }
        return result2;
      };
      const getAllKeysIn = (object) => {
        const result2 = [];
        for (const key in object) {
          result2.push(key);
        }
        if (!Array.isArray(object)) {
          result2.push(...getSymbolsIn(object));
        }
        return result2;
      };
      const getMapData = ({
        __data__
      }, key) => {
        const data2 = __data__;
        return isKeyable(key) ? data2[typeof key === "string" ? "string" : "hash"] : data2.map;
      };
      const equalObjects = (object, other, equalFunc, stack) => {
        const objProps = getAllKeys(object);
        const objLength = objProps.length;
        const othProps = getAllKeys(other);
        const othLength = othProps.length;
        if (objLength != othLength) {
          return false;
        }
        let key;
        let index2 = objLength;
        while (index2--) {
          key = objProps[index2];
          if (!hasOwnProperty.call(other, key)) {
            return false;
          }
        }
        const objStacked = stack.get(object);
        const othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        let result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        let compared;
        let skipCtor;
        while (++index2 < objLength) {
          key = objProps[index2];
          const objValue = object[key];
          const othValue = other[key];
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          const objCtor = object.constructor;
          const othCtor = other.constructor;
          if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor === "function" && objCtor instanceof objCtor && typeof othCtor === "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      };
      const baseIsEqual = (value, other, stack) => {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, baseIsEqual, stack);
      };
      const baseIsEqualDeep = (object, other, equalFunc, stack) => {
        let objIsArr = Array.isArray(object);
        const othIsArr = Array.isArray(other);
        let objTag = objIsArr ? arrayTag : getTag(object);
        let othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        let objIsObj = objTag == objectTag;
        const othIsObj = othTag == objectTag;
        const isSameTag = objTag == othTag;
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, false, equalFunc, stack) : equalByTag(object, other, objTag, equalFunc, stack);
        }
        const objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__");
        const othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          const objUnwrapped = objIsWrapped ? object.value() : object;
          const othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, stack);
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, equalFunc, stack);
      };
      const equalArrays = (array, other, compareUnordered, equalFunc, stack) => {
        const isPartial = false;
        const arrLength = array.length;
        const othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        const arrStacked = stack.get(array);
        const othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        let index2 = -1;
        let result2 = true;
        const seen = compareUnordered ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          let compared;
          const arrValue = array[index2];
          const othValue = other[index2];
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!some(other, (othValue2, othIndex) => {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      };
      const some = (array, predicate) => {
        let index2 = -1;
        const length2 = array == null ? 0 : array.length;
        while (++index2 < length2) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      };
      const cacheHas = (cache2, key) => {
        return cache2.has(key);
      };
      const compareArrayBufferTag = (object, other, equalFunc, stack) => {
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {
          return false;
        }
        return true;
      };
      const equalByTag = (object, other, tag, equalFunc, stack) => {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
            return compareArrayBufferTag(object, other, equalFunc, stack);
          case arrayBufferTag:
            return compareArrayBufferTag(object, other, equalFunc, stack);
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == `${other}`;
          case mapTag:
            var convert = mapToArray;
          // Intentional fallthrough
          // eslint-disable-next-line no-fallthrough
          case setTag:
            convert || (convert = setToArray);
            if (object.size != other.size) {
              return false;
            }
            const stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            stack.set(object, other);
            const result2 = equalArrays(convert(object), convert(other), true, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);
        }
        return false;
      };
      const mapToArray = (map) => {
        let index2 = -1;
        let result2 = Array(map.size);
        map.forEach((value, key) => {
          result2[++index2] = [key, value];
        });
        return result2;
      };
      const setToArray = (set2) => {
        let index2 = -1;
        const result2 = new Array(set2.size);
        set2.forEach((value) => {
          result2[++index2] = value;
        });
        return result2;
      };
      const isKey = (value, object) => {
        if (Array.isArray(value)) {
          return false;
        }
        const type = typeof value;
        if (type === "number" || type === "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      };
      const stringToPath = (string) => {
        const result2 = [];
        if (string.charCodeAt(0) === charCodeOfDot) {
          result2.push("");
        }
        string.replace(rePropName, (match, expression, quote, subString) => {
          let key = match;
          if (quote) {
            key = subString.replace(reEscapeChar, "$1");
          } else if (expression) {
            key = expression.trim();
          }
          result2.push(key);
        });
        return result2;
      };
      const castPath = (path2, object) => {
        if (Array.isArray(path2)) {
          return path2;
        }
        return isKey(path2, object) ? [path2] : stringToPath(`${path2}`);
      };
      const get = (object, path2) => {
        path2 = castPath(path2, object);
        let index2 = 0;
        const length2 = path2.length;
        while (object != null && index2 < length2) {
          object = object[toKey(path2[index2])];
          index2++;
        }
        return index2 && index2 == length2 ? object : void 0;
      };
      function compareAscending(value, other) {
        if (value !== other) {
          const valIsDefined = value !== void 0;
          const valIsNull = value === null;
          const valIsReflexive = value === value;
          const valIsSymbol = isSymbol(value);
          const othIsDefined = other !== void 0;
          const othIsNull = other === null;
          const othIsReflexive = other === other;
          const othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        let index2 = -1;
        const objCriteria = object.criteria;
        const othCriteria = other.criteria;
        const length2 = objCriteria.length;
        const ordersLength = orders.length;
        while (++index2 < length2) {
          const order = index2 < ordersLength ? orders[index2] : null;
          const cmpFn = order && typeof order === "function" ? order : compareAscending;
          const result2 = cmpFn(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (order && typeof order !== "function") {
              return result2 * (order == "desc" ? -1 : 1);
            }
            return result2;
          }
        }
        return object.index - other.index;
      }
      const diff = (array, values2) => {
        let includes2 = (array2, value) => {
          const length2 = array2 == null ? 0 : array2.length;
          return !!length2 && array2.indexOf(value) > -1;
        };
        let isCommon = true;
        const result2 = [];
        const valuesLength = values2.length;
        if (!array.length) {
          return result2;
        }
        if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = (cache2, key) => cache2.has(key);
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer: for (let key in array) {
          let value = array[key];
          const computed = value;
          value = value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            let valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values2[valuesIndex] === computed) {
                continue outer;
              }
            }
            result2.push(value);
          } else if (!includes2(values2, computed)) {
            result2.push(value);
          }
        }
        return result2;
      };
      const intersect = (arrays) => {
        const includes2 = (array2, value) => {
          const length3 = array2 == null ? 0 : array2.length;
          return !!length3 && array2.indexOf(value) > -1;
        };
        const cacheHas2 = (cache2, key) => cache2.has(key);
        const length2 = arrays[0].length;
        const othLength = arrays.length;
        const caches = new Array(othLength);
        const result2 = [];
        let array;
        let maxLength = Infinity;
        let othIndex = othLength;
        while (othIndex--) {
          array = arrays[othIndex];
          maxLength = Math.min(array.length, maxLength);
          caches[othIndex] = length2 >= 120 && array.length >= 120 ? new SetCache(othIndex && array) : void 0;
        }
        array = arrays[0];
        let index2 = -1;
        const seen = caches[0];
        outer: while (++index2 < length2 && result2.length < maxLength) {
          let value = array[index2];
          const computed = value;
          value = value !== 0 ? value : 0;
          if (!(seen ? cacheHas2(seen, computed) : includes2(result2, computed))) {
            othIndex = othLength;
            while (--othIndex) {
              const cache2 = caches[othIndex];
              if (!(cache2 ? cacheHas2(cache2, computed) : includes2(arrays[othIndex], computed))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed);
            }
            result2.push(value);
          }
        }
        return result2;
      };
      const toKey = (value) => {
        if (typeof value === "string" || isSymbol(value)) {
          return value;
        }
        const result2 = `${value}`;
        return result2 == "0" && 1 / value == -Infinity ? "-0" : result2;
      };
      const baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {
        let result2;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== void 0) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        const isArr = Array.isArray(value);
        const tag = getTag(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          const isFunc = typeof value === "function";
          if (tag === objectTag || tag === argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, copyObject(value, Object.keys(value), result2)) : copySymbols(value, Object.assign(result2, value));
            }
          } else {
            if (isFunc || !CLONEABLE_TAGS[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        const stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isMap(value)) {
          value.forEach((subValue, key2) => {
            result2.set(key2, baseClone(subValue, isDeep, isFlat, isFull, customizer, key2, value, stack));
          });
          return result2;
        }
        if (isSet(value)) {
          value.forEach((subValue) => {
            result2.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));
          });
          return result2;
        }
        if (isTypedArray(value)) {
          return result2;
        }
        const keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        const props2 = isArr ? void 0 : keysFunc(value);
        (props2 || value).forEach((subValue, key2) => {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, isDeep, isFlat, isFull, customizer, key2, value, stack));
        });
        return result2;
      };
      const copySymbolsIn = (source, object) => {
        return copyObject(source, getSymbolsIn(source), object);
      };
      const parent = (object, path2) => {
        return path2.length < 2 ? object : get(object, path2.slice(0, -1));
      };
      const set = (object, path2, value) => {
        if (!isObject(object)) {
          return object;
        }
        path2 = castPath(path2, object);
        const length2 = path2.length;
        const lastIndex = length2 - 1;
        let index2 = -1;
        let nested = object;
        while (nested != null && ++index2 < length2) {
          const key = toKey(path2[index2]);
          let newValue = value;
          if (index2 != lastIndex) {
            const objValue = nested[key];
            newValue = void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      };
      const isIndex = (value, length2) => {
        const type = typeof value;
        length2 = length2 == null ? Number.MAX_SAFE_INTEGER : length2;
        return !!length2 && (type === "number" || type !== "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length2;
      };
      const unset = (object, path2) => {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        const lastSegment = path2[path2.length - 1];
        return object == null || delete object[toKey(lastSegment)];
      };
      const isKeyable = (value) => {
        const type = typeof value;
        return type === "string" || type === "number" || type === "symbol" || type === "boolean" ? value !== "__proto__" : value === null;
      };
      const keysIn = (object) => {
        const result2 = [];
        for (const key in object) {
          result2.push(key);
        }
        return result2;
      };
      const toPlainObject = (value) => {
        value = Object(value);
        const result2 = {};
        for (const key in value) {
          result2[key] = value[key];
        }
        return result2;
      };
      const safeGet = (object, key) => {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      };
      function createAssigner(assigner, isMerge = false) {
        return (object, ...sources) => {
          let index2 = -1;
          let length2 = sources.length;
          let customizer = length2 > 1 ? sources[length2 - 1] : void 0;
          const guard = length2 > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer === "function" ? (length2--, customizer) : isMerge ? (a, b) => {
            if (Array.isArray(a) && !Array.isArray(b)) {
              return b;
            }
          } : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length2 < 3 ? void 0 : customizer;
            length2 = 1;
          }
          object = Object(object);
          while (++index2 < length2) {
            const source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        };
      }
      const baseMerge = (object, source, srcIndex, customizer, stack) => {
        if (object === source) {
          return;
        }
        forIn(source, (srcValue, key) => {
          if (isObject(srcValue)) {
            stack || (stack = new Stack());
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            let newValue = customizer ? customizer(object[key], srcValue, `${key}`, object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        });
      };
      const baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {
        const objValue = safeGet(object, key);
        const srcValue = safeGet(source, key);
        const stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        let newValue = customizer ? customizer(objValue, srcValue, `${key}`, object, source, stack) : void 0;
        let isCommon = newValue === void 0;
        if (isCommon) {
          const isArr = Array.isArray(srcValue);
          const isTyped = !isArr && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isTyped) {
            if (Array.isArray(objValue)) {
              newValue = objValue;
            } else if (isObjectLike(objValue) && isArrayLike(objValue)) {
              newValue = copyArray(objValue);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (typeof objValue === "function" || !isObject(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      };
      const assignMergeValue = (object, key, value) => {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          assignValue(object, key, value);
        }
      };
      function baseFor(object, iteratee, keysFunc) {
        const iterable = Object(object);
        const props2 = keysFunc(object);
        let {
          length: length2
        } = props2;
        let index2 = -1;
        while (length2--) {
          const key = props2[++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      }
      const baseForOwn = (object, iteratee) => {
        return object && baseFor(object, iteratee, keys);
      };
      const baseEach = (collection, iteratee) => {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return baseForOwn(collection, iteratee);
        }
        const length2 = collection.length;
        const iterable = Object(collection);
        let index2 = -1;
        while (++index2 < length2) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
      function last(array) {
        const length2 = array == null ? 0 : array.length;
        return length2 ? array[length2 - 1] : void 0;
      }
      const createSet = Set && 1 / setToArray(/* @__PURE__ */ new Set([void 0, -0]))[1] == 1 / 0 ? (values2) => new Set(values2) : () => {
      };
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = iteratees.map((iteratee) => {
            if (Array.isArray(iteratee)) {
              return (value) => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
            return iteratee;
          });
        } else {
          iteratees = [(value) => value];
        }
        let criteriaIndex = -1;
        let eachIndex = -1;
        const result2 = isArrayLike(collection) ? new Array(collection.length) : [];
        baseEach(collection, (value) => {
          const criteria = iteratees.map((iteratee) => iteratee(value));
          result2[++eachIndex] = {
            criteria,
            index: ++criteriaIndex,
            value
          };
        });
        return baseSortBy(result2, (object, other) => compareMultiple(object, other, orders));
      }
      function baseSortBy(array, comparer) {
        let {
          length: length2
        } = array;
        array.sort(comparer);
        while (length2--) {
          array[length2] = array[length2].value;
        }
        return array;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return (object) => {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function hasIn(object, path2) {
        return object != null && hasPath(object, path2, baseHasIn);
      }
      function baseMatchesProperty(path2, srcValue) {
        if (isKey(path2) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path2), srcValue);
        }
        return (object) => {
          const objValue = get(object, path2);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue);
        };
      }
      function baseMatches(source) {
        const matchData = getMatchData(source);
        if (matchData.length === 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return (object) => object === source || baseIsMatch(object, source, matchData);
      }
      function getMatchData(object) {
        const result2 = keys(object);
        let length2 = result2.length;
        while (length2--) {
          const key = result2[length2];
          const value = object[key];
          result2[length2] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        let index2 = matchData.length;
        const length2 = index2;
        const noCustomizer = !customizer;
        if (object == null) {
          return !length2;
        }
        let data2;
        let result2;
        object = Object(object);
        while (index2--) {
          data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length2) {
          data2 = matchData[index2];
          const key = data2[0];
          const objValue = object[key];
          const srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            const stack = new Stack();
            if (customizer) {
              result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === void 0 ? baseIsEqual(srcValue, objValue, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function property(path2) {
        return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
      }
      function baseProperty(key) {
        return (object) => object == null ? void 0 : object[key];
      }
      function basePropertyDeep(path2) {
        return (object) => get(object, path2);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return (val) => val;
        }
        if (typeof value == "object") {
          return Array.isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function getIteratee() {
        const result2 = baseIteratee;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      const arrayReduce = (array, iteratee, accumulator, initAccum) => {
        let index2 = -1;
        const length2 = array == null ? 0 : array.length;
        if (initAccum && length2) {
          accumulator = array[++index2];
        }
        while (++index2 < length2) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      };
      const baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {
        eachFunc(collection, (value, index2, collection2) => {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      };
      function reduce(collection, iteratee, accumulator) {
        const func = Array.isArray(collection) ? arrayReduce : baseReduce;
        const initAccum = arguments.length < 3;
        return func(collection, iteratee, accumulator, initAccum, baseEach);
      }
      const isFlattenable = (value) => {
        return Array.isArray(value) || isArguments(value) || !!(value && value[Symbol.isConcatSpreadable]);
      };
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        let index2 = -1;
        const length2 = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length2) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              result2.push(...value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      const isArguments = (value) => {
        return isObjectLike(value) && getTag(value) == "[object Arguments]";
      };
      const basePick = (object, paths) => {
        return basePickBy(object, paths, (value, path2) => hasIn(object, path2));
      };
      const basePickBy = (object, paths, predicate) => {
        let index2 = -1;
        const length2 = paths.length;
        const result2 = {};
        while (++index2 < length2) {
          const path2 = paths[index2];
          const value = get(object, path2);
          if (predicate(value, path2)) {
            set(result2, castPath(path2, object), value);
          }
        }
        return result2;
      };
      const isLength = (value) => {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;
      };
      const baseHasIn = (object, key) => {
        return object != null && key in Object(object);
      };
      const hasPath = (object, path2, hasFunc) => {
        path2 = castPath(path2, object);
        var index2 = -1, length2 = path2.length, result2 = false;
        while (++index2 < length2) {
          var key = toKey(path2[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length2) {
          return result2;
        }
        length2 = object == null ? 0 : object.length;
        return !!length2 && isLength(length2) && isIndex(key, length2) && (Array.isArray(object) || isArguments(object));
      };
      const asciiWords = (string) => {
        return string.match(reAsciiWord);
      };
      const unicodeWords = (string) => {
        return string.match(reUnicodeWords);
      };
      const words = (string, pattern) => {
        if (pattern === void 0) {
          const result2 = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          return result2 || [];
        }
        return string.match(pattern) || [];
      };
      const castSlice = (array, start, end) => {
        const {
          length: length2
        } = array;
        end = end === void 0 ? length2 : end;
        return !start && end >= length2 ? array : array.slice(start, end);
      };
      const upperFirst = createCaseFirst("toUpperCase");
      function createCaseFirst(methodName) {
        return (string) => {
          if (!string) {
            return "";
          }
          const strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
          const chr = strSymbols ? strSymbols[0] : string[0];
          const trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function matches(source) {
        return baseMatches(baseClone(source, true));
      }
      class Stack {
        constructor(entries) {
          const data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        clear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        delete(key) {
          const data2 = this.__data__;
          const result2 = data2["delete"](key);
          this.size = data2.size;
          return result2;
        }
        get(key) {
          return this.__data__.get(key);
        }
        has(key) {
          return this.__data__.has(key);
        }
        set(key, value) {
          let data2 = this.__data__;
          if (data2 instanceof ListCache) {
            const pairs = data2.__data__;
            if (pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs);
          }
          data2.set(key, value);
          this.size = data2.size;
          return this;
        }
      }
      class ListCache {
        constructor(entries) {
          let index2 = -1;
          const length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            const entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        clear() {
          this.__data__ = [];
          this.size = 0;
        }
        delete(key) {
          const data2 = this.__data__;
          const index2 = assocIndexOf(data2, key);
          if (index2 < 0) {
            return false;
          }
          const lastIndex = data2.length - 1;
          if (index2 == lastIndex) {
            data2.pop();
          } else {
            data2.splice(index2, 1);
          }
          --this.size;
          return true;
        }
        get(key) {
          const data2 = this.__data__;
          const index2 = assocIndexOf(data2, key);
          return index2 < 0 ? void 0 : data2[index2][1];
        }
        has(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        set(key, value) {
          const data2 = this.__data__;
          const index2 = assocIndexOf(data2, key);
          if (index2 < 0) {
            ++this.size;
            data2.push([key, value]);
          } else {
            data2[index2][1] = value;
          }
          return this;
        }
      }
      class MapCache {
        constructor(entries) {
          let index2 = -1;
          const length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            const entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        clear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": /* @__PURE__ */ new Map(),
            "string": new Hash()
          };
        }
        delete(key) {
          const result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        get(key) {
          return getMapData(this, key).get(key);
        }
        has(key) {
          return getMapData(this, key).has(key);
        }
        set(key, value) {
          const data2 = getMapData(this, key);
          const size = data2.size;
          data2.set(key, value);
          this.size += data2.size == size ? 0 : 1;
          return this;
        }
      }
      class Hash {
        constructor(entries) {
          let index2 = -1;
          const length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            const entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        clear() {
          this.__data__ = /* @__PURE__ */ Object.create(null);
          this.size = 0;
        }
        delete(key) {
          const result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        get(key) {
          const data2 = this.__data__;
          const result2 = data2[key];
          return result2 === HASH_UNDEFINED ? void 0 : result2;
        }
        has(key) {
          const data2 = this.__data__;
          return data2[key] !== void 0;
        }
        set(key, value) {
          const data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
      }
      class SetCache {
        constructor(values2) {
          let index2 = -1;
          const length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length2) {
            this.add(values2[index2]);
          }
        }
        add(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        has(value) {
          return this.__data__.has(value);
        }
      }
      SetCache.prototype.push = SetCache.prototype.add;
      const isBoolean = function(value) {
        var toString2 = Object.prototype.toString;
        return value === true || value === false || !!value && typeof value === "object" && toString2.call(value) === boolTag;
      };
      const isObject = function(value) {
        return !!value && (typeof value === "object" || typeof value === "function");
      };
      const isNumber = function(value) {
        var toString2 = Object.prototype.toString;
        return typeof value === "number" || !!value && typeof value === "object" && toString2.call(value) === numberTag;
      };
      const isString = function(value) {
        var toString2 = Object.prototype.toString;
        return typeof value === "string" || !!value && typeof value === "object" && toString2.call(value) === stringTag;
      };
      const assign = createAssigner((object, source) => {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      const mixin = assign;
      const deepMixin = mixin;
      const supplement = (object, ...sources) => {
        let index2 = -1;
        let length2 = sources.length;
        const guard = length2 > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length2 = 1;
        }
        while (++index2 < length2) {
          const source = sources[index2];
          if (source == null) {
            continue;
          }
          const props2 = Object.keys(source);
          const propsLength = props2.length;
          let propsIndex = -1;
          while (++propsIndex < propsLength) {
            const key = props2[propsIndex];
            const value = object[key];
            if (value === void 0 || eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      };
      const defaults = supplement;
      const deepSupplement = function defaultsDeep2(...args) {
        args.push(void 0, customDefaultsMerge);
        return merge.apply(void 0, args);
      };
      const defaultsDeep = deepSupplement;
      const invoke = (collection, path2, ...args) => {
        let index2 = -1;
        const isFunc = typeof path2 === "function";
        const result2 = isArrayLike(collection) ? new Array(collection.length) : [];
        baseEach(collection, (value) => {
          result2[++index2] = isFunc ? path2.apply(value, args) : invokeProperty(value, path2, ...args);
        });
        return result2;
      };
      const invokeProperty = (object, path2, ...args) => {
        path2 = castPath(path2, object);
        object = parent(object, path2);
        const func = object == null ? object : object[toKey(last(path2))];
        return func == null ? void 0 : func.apply(object, args);
      };
      const sortedIndex = (array, value, iteratee) => {
        let low = 0;
        let high = array == null ? 0 : array.length;
        if (high == 0) {
          return 0;
        }
        iteratee = getIteratee(iteratee, 2);
        value = iteratee(value);
        const valIsNaN = value !== value;
        const valIsNull = value === null;
        const valIsSymbol = isSymbol(value);
        const valIsUndefined = value === void 0;
        while (low < high) {
          let setLow;
          const mid = Math.floor((low + high) / 2);
          const computed = iteratee(array[mid]);
          const othIsDefined = computed !== void 0;
          const othIsNull = computed === null;
          const othIsReflexive = computed === computed;
          const othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            setLow = othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && othIsDefined;
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && !othIsNull;
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return Math.min(high, MAX_ARRAY_INDEX);
      };
      const uniq = (array, iteratee) => {
        let index2 = -1;
        let includes2 = (array2, value) => {
          const length3 = array2 == null ? 0 : array2.length;
          return !!length3 && array2.indexOf(value) > -1;
        };
        iteratee = getIteratee(iteratee, 2);
        let isCommon = true;
        const {
          length: length2
        } = array;
        const result2 = [];
        let seen = result2;
        if (length2 >= LARGE_ARRAY_SIZE) {
          const set2 = iteratee ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = (cache2, key) => cache2.has(key);
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result2;
        }
        outer: while (++index2 < length2) {
          let value = array[index2];
          const computed = iteratee ? iteratee(value) : value;
          value = value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            let seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result2.push(value);
          } else if (!includes2(seen, computed)) {
            if (seen !== result2) {
              seen.push(computed);
            }
            result2.push(value);
          }
        }
        return result2;
      };
      const clone$1 = (value) => baseClone(value);
      const cloneDeep = (value) => baseClone(value, true);
      const isEmpty = (value) => {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (Array.isArray(value) || typeof value === "string" || typeof value.splice === "function" || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        const tag = getTag(value);
        if (tag == "[object Map]" || tag == "[object Set]") {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (const key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      };
      const isEqual = (object, other) => baseIsEqual(object, other);
      const isFunction = (value) => typeof value === "function";
      const isPlainObject = (value) => {
        if (!isObjectLike(value) || getTag(value) != "[object Object]") {
          return false;
        }
        if (Object.getPrototypeOf(value) === null) {
          return true;
        }
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
      };
      const toArray$1 = (value) => {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (Symbol.iterator && Symbol.iterator in Object(value)) {
          const iterator = value[Symbol.iterator]();
          let data2;
          const result2 = [];
          while (!(data2 = iterator.next()).done) {
            result2.push(data2.value);
          }
          return result2;
        }
        const tag = getTag(value);
        const func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      };
      function debounce(func, wait, opt) {
        if (typeof func !== "function") {
          throw new TypeError("Expected a function");
        }
        let lastArgs;
        let lastThis;
        let maxWait;
        let result2;
        let timerId;
        let lastCallTime;
        let lastInvokeTime = 0;
        let leading = false;
        let maxing = false;
        let trailing = true;
        const useRaf = !wait && wait !== 0 && window && typeof window.requestAnimationFrame === "function";
        wait = +wait || 0;
        if (isObject(opt)) {
          leading = !!opt.leading;
          maxing = "maxWait" in opt;
          maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;
          trailing = "trailing" in opt ? !!opt.trailing : trailing;
        }
        function invokeFunc(time) {
          const args = lastArgs;
          const thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function startTimer(pendingFunc, wait2) {
          if (useRaf) {
            window.cancelAnimationFrame(timerId);
            return window.requestAnimationFrame(pendingFunc);
          }
          return setTimeout(pendingFunc, wait2);
        }
        function cancelTimer(id2) {
          if (useRaf) {
            return window.cancelAnimationFrame(id2);
          }
          clearTimeout(id2);
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = startTimer(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          const timeSinceLastCall = time - lastCallTime;
          const timeSinceLastInvoke = time - lastInvokeTime;
          const timeWaiting = wait - timeSinceLastCall;
          return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          const timeSinceLastCall = time - lastCallTime;
          const timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          const time = Date.now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = startTimer(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result2;
        }
        function debounced(...args) {
          const time = Date.now();
          const isInvoking = shouldInvoke(time);
          lastArgs = args;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = startTimer(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = startTimer(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = () => {
          if (timerId !== void 0) {
            cancelTimer(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        };
        debounced.flush = () => timerId === void 0 ? result2 : trailingEdge(Date.now());
        debounced.pending = () => timerId !== void 0;
        return debounced;
      }
      const groupBy = (collection, iteratee) => {
        iteratee = getIteratee(iteratee, 2);
        return reduce(collection, (result2, value) => {
          const key = iteratee(value);
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            assignValue(result2, key, [value]);
          }
          return result2;
        }, {});
      };
      const sortBy = (collection, iteratees = []) => {
        if (collection == null) {
          return [];
        }
        const length2 = iteratees.length;
        if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        if (!Array.isArray(iteratees)) {
          iteratees = [getIteratee(iteratees, 2)];
        }
        return baseOrderBy(collection, iteratees.flat(1), []);
      };
      const flattenDeep = (array) => {
        const length2 = array == null ? 0 : array.length;
        return length2 ? baseFlatten(array, Infinity) : [];
      };
      const without = (array, ...values2) => isArrayLike(array) ? diff(array, values2) : [];
      const difference = (array, ...values2) => isObjectLike(array) && isArrayLike(array) ? diff(array, values2.flat(1)) : [];
      const intersection = (...arrays) => {
        const mapped = arrays.map((array) => isObjectLike(array) && isArrayLike(array) ? array : []);
        return mapped.length && mapped[0] === arrays[0] ? intersect(mapped) : [];
      };
      const union = (...arrays) => {
        const array = arrays.flat(1);
        return uniq(array);
      };
      const has = (object, key) => {
        if (object == null) {
          return false;
        }
        if (typeof key === "string") {
          key = key.split(".");
        }
        let index2 = -1;
        let value = object;
        while (++index2 < key.length) {
          if (!value || !hasOwnProperty.call(value, key[index2])) {
            return false;
          }
          value = value[key[index2]];
        }
        return true;
      };
      const result = (object, path2, defaultValue) => {
        path2 = castPath(path2, object);
        let index2 = -1;
        let length2 = path2.length;
        if (!length2) {
          length2 = 1;
          object = void 0;
        }
        while (++index2 < length2) {
          let value = object == null ? void 0 : object[toKey(path2[index2])];
          if (value === void 0) {
            index2 = length2;
            value = defaultValue;
          }
          object = typeof value === "function" ? value.call(object) : value;
        }
        return object;
      };
      const omit = (object, ...paths) => {
        let result2 = {};
        if (object == null) {
          return result2;
        }
        let isDeep = false;
        paths = paths.flat(1).map((path2) => {
          path2 = castPath(path2, object);
          isDeep || (isDeep = path2.length > 1);
          return path2;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, true, true, true, (value) => isPlainObject(value) ? void 0 : value);
        }
        let length2 = paths.length;
        while (length2--) {
          unset(result2, paths[length2]);
        }
        return result2;
      };
      const pick = (object, ...paths) => {
        return object == null ? {} : basePick(object, paths.flat(Infinity));
      };
      const bindAll = (object, ...methodNames) => {
        methodNames.flat(1).forEach((key) => {
          key = toKey(key);
          assignValue(object, key, object[key].bind(object));
        });
        return object;
      };
      const forIn = (object, iteratee = (value) => value) => {
        let index2 = -1;
        const iterable = Object(object);
        const props2 = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);
        let length2 = props2.length;
        while (length2--) {
          const key = props2[++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
      };
      const camelCase = (string = "") => words(`${string}`.replace(/['\u2019]/g, "")).reduce((result2, word, index2) => {
        word = word.toLowerCase();
        return result2 + (index2 ? upperFirst(word) : word);
      }, "");
      let idCounter = 0;
      const uniqueId = (prefix = "") => {
        const id2 = ++idCounter;
        return `${prefix}` + id2;
      };
      const merge = createAssigner((object, source, srcIndex, customizer) => {
        baseMerge(object, source, srcIndex, customizer);
      }, true);
      class Data {
        constructor() {
          this.map = /* @__PURE__ */ new WeakMap();
        }
        has(obj, key) {
          if (key === void 0) return this.map.has(obj);
          return key in this.map.get(obj);
        }
        create(obj) {
          if (!this.has(obj)) this.map.set(obj, /* @__PURE__ */ Object.create(null));
          return this.get(obj);
        }
        get(obj, key) {
          if (!this.has(obj)) return void 0;
          const data2 = this.map.get(obj);
          if (key === void 0) return data2;
          return data2[key];
        }
        set(obj, key, value) {
          if (key === void 0) return;
          const data2 = this.create(obj);
          if (typeof key === "string") {
            data2[key] = value;
          } else {
            Object.assign(data2, key);
          }
        }
        remove(obj, key) {
          if (!this.has(obj)) return;
          if (key === void 0) {
            this.map.delete(obj);
          } else {
            const data2 = this.map.get(obj);
            delete data2[key];
          }
        }
      }
      const dataPriv = new Data();
      const dataUser = new Data();
      const Event = function(src, props2) {
        if (!(this instanceof Event)) {
          return new Event(src, props2);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;
          this.target = src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props2) {
          Object.assign(this, props2);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this.envelope = true;
      };
      Event.prototype = {
        constructor: Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
          const evt = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (evt) {
            evt.preventDefault();
          }
        },
        stopPropagation: function() {
          const evt = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (evt) {
            evt.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          const evt = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (evt) {
            evt.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      ["altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "pageX", "pageY", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "clientX", "clientY", "offsetX", "offsetY", "pointerId", "pointerType", "screenX", "screenY", "targetTouches", "toElement", "touches", "which"].forEach((name) => addProp(name));
      function addProp(name) {
        Object.defineProperty(Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: function() {
            return this.originalEvent ? this.originalEvent[name] : void 0;
          },
          set: function(value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      }
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      const document$1 = typeof window !== "undefined" ? window.document : null;
      const documentElement = document$1 && document$1.documentElement;
      const rTypeNamespace = /^([^.]*)(?:\.(.+)|)/;
      const rNotHtmlWhite = /[^\x20\t\r\n\f]+/g;
      const $ = function(selector) {
        return new $.Dom(selector);
      };
      $.fn = $.prototype = {
        constructor: $,
        // The default length of a $ object is 0
        length: 0
      };
      $.guid = 1;
      $.data = dataUser;
      $.merge = function(first, second) {
        let len = +second.length;
        let i = first.length;
        for (let j = 0; j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      };
      $.parseHTML = function(string) {
        const context = document$1.implementation.createHTMLDocument();
        const base = context.createElement("base");
        base.href = document$1.location.href;
        context.head.appendChild(base);
        context.body.innerHTML = string;
        const scripts = context.getElementsByTagName("script");
        for (let i = 0; i < scripts.length; i++) {
          scripts[i].remove();
        }
        return Array.from(context.body.childNodes);
      };
      if (typeof Symbol === "function") {
        $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];
      }
      $.fn.toArray = function() {
        return Array.from(this);
      };
      $.fn.pushStack = function(elements) {
        const ret = $.merge(this.constructor(), elements);
        ret.prevObject = this;
        return ret;
      };
      $.fn.find = function(selector) {
        const [el] = this;
        const ret = this.pushStack([]);
        if (!el) return ret;
        const {
          nodeType
        } = el;
        if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return ret;
        }
        if (typeof selector !== "string") {
          if (el !== selector && el.contains(selector)) {
            $.merge(ret, [selector]);
          }
        } else {
          $.merge(ret, el.querySelectorAll(selector));
        }
        return ret;
      };
      $.fn.add = function(selector) {
        const newElements = $(selector).toArray();
        const prevElements = this.toArray();
        const ret = this.pushStack([]);
        $.merge(ret, uniq(prevElements.concat(newElements)));
        return ret;
      };
      $.fn.addBack = function() {
        return this.add(this.prevObject);
      };
      $.fn.filter = function(selector) {
        const matches2 = [];
        for (let i = 0; i < this.length; i++) {
          const node = this[i];
          if (!node.matches(selector)) continue;
          matches2.push(node);
        }
        return this.pushStack(matches2);
      };
      const rQuickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
      function isObviousHtml(input) {
        return input[0] === "<" && input[input.length - 1] === ">" && input.length >= 3;
      }
      const Dom = function(selector) {
        if (!selector) {
          return this;
        }
        if (typeof selector === "function") {
          throw new Error("function not supported");
        }
        if (arguments.length > 1) {
          throw new Error("selector with context not supported");
        }
        if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        }
        let match;
        if (isObviousHtml(selector + "")) {
          match = [null, selector, null];
        } else if (typeof selector === "string") {
          match = rQuickExpr.exec(selector);
        } else {
          return $.merge(this, selector);
        }
        if (!match || !match[1]) {
          return $root.find(selector);
        }
        if (match[1]) {
          $.merge(this, $.parseHTML(match[1]));
          return this;
        }
        const el = document$1.getElementById(match[2]);
        if (el) {
          this[0] = el;
          this.length = 1;
        }
        return this;
      };
      $.Dom = Dom;
      Dom.prototype = $.fn;
      $.Event = Event;
      $.event = {
        special: /* @__PURE__ */ Object.create(null)
      };
      $.event.has = function(elem, eventType) {
        const events = dataPriv.get(elem, "events");
        if (!events) return false;
        if (!eventType) return true;
        return Array.isArray(events[eventType]) && events[eventType].length > 0;
      };
      $.event.on = function(elem, types2, selector, data2, fn2, one2) {
        if (typeof types2 === "object") {
          if (typeof selector !== "string") {
            data2 = data2 || selector;
            selector = void 0;
          }
          for (let type in types2) {
            $.event.on(elem, type, selector, data2, types2[type], one2);
          }
          return elem;
        }
        if (data2 == null && fn2 == null) {
          fn2 = selector;
          data2 = selector = void 0;
        } else if (fn2 == null) {
          if (typeof selector === "string") {
            fn2 = data2;
            data2 = void 0;
          } else {
            fn2 = data2;
            data2 = selector;
            selector = void 0;
          }
        }
        if (!fn2) {
          return elem;
        }
        if (one2 === 1) {
          const origFn = fn2;
          fn2 = function(event) {
            $().off(event);
            return origFn.apply(this, arguments);
          };
          fn2.guid = origFn.guid || (origFn.guid = $.guid++);
        }
        for (let i = 0; i < elem.length; i++) {
          $.event.add(elem[i], types2, fn2, data2, selector);
        }
      };
      $.event.add = function(elem, types2, handler, data2, selector) {
        if (typeof elem != "object") {
          return;
        }
        const elemData = dataPriv.create(elem);
        let handleObjIn;
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          documentElement.matches(selector);
        }
        if (!handler.guid) {
          handler.guid = $.guid++;
        }
        let events;
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        let eventHandle;
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof $ !== "undefined" ? $.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        const typesArr = (types2 || "").match(rNotHtmlWhite) || [""];
        let i = typesArr.length;
        while (i--) {
          const [, origType, ns2 = ""] = rTypeNamespace.exec(typesArr[i]);
          if (!origType) {
            continue;
          }
          const namespaces = ns2.split(".").sort();
          let special2 = $.event.special[origType];
          const type = special2 && (selector ? special2.delegateType : special2.bindType) || origType;
          special2 = $.event.special[type];
          const handleObj = Object.assign({
            type,
            origType,
            data: data2,
            handler,
            guid: handler.guid,
            selector,
            namespace: namespaces.join(".")
          }, handleObjIn);
          let handlers;
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special2 || !special2.setup || special2.setup.call(elem, data2, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special2 && special2.add) {
            special2.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
        }
      };
      $.event.remove = function(elem, types2, handler, selector, mappedTypes) {
        const elemData = dataPriv.get(elem);
        if (!elemData || !elemData.events) return;
        const events = elemData.events;
        const typesArr = (types2 || "").match(rNotHtmlWhite) || [""];
        let i = typesArr.length;
        while (i--) {
          const [, origType, ns2 = ""] = rTypeNamespace.exec(typesArr[i]);
          if (!origType) {
            for (const type2 in events) {
              $.event.remove(elem, type2 + typesArr[i], handler, selector, true);
            }
            continue;
          }
          const special2 = $.event.special[origType];
          const type = special2 && (selector ? special2.delegateType : special2.bindType) || origType;
          const handlers = events[type];
          if (!handlers || handlers.length === 0) continue;
          const namespaces = ns2.split(".").sort();
          const rNamespace = ns2 ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          const origCount = handlers.length;
          let j = origCount;
          while (j--) {
            const handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!rNamespace || rNamespace.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special2 && special2.remove) {
                special2.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && handlers.length === 0) {
            if (!special2 || !special2.teardown || special2.teardown.call(elem, namespaces, elemData.handle) === false) {
              if (elem.removeEventListener) {
                elem.removeEventListener(type, elemData.handle);
              }
            }
            delete events[type];
          }
        }
        if (isEmpty(events)) {
          dataPriv.remove(elem, "handle");
          dataPriv.remove(elem, "events");
        }
      };
      $.event.dispatch = function(nativeEvent) {
        const elem = this;
        const event = $.event.fix(nativeEvent);
        event.delegateTarget = elem;
        const args = Array.from(arguments);
        args[0] = event;
        const eventsData = dataPriv.get(elem, "events");
        const handlers = eventsData && eventsData[event.type] || [];
        const special2 = $.event.special[event.type];
        if (special2 && special2.preDispatch) {
          if (special2.preDispatch.call(elem, event) === false) return;
        }
        const handlerQueue = $.event.handlers.call(elem, event, handlers);
        let i = 0;
        let matched;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          let j = 0;
          let handleObj;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            const origSpecial = $.event.special[handleObj.origType];
            let handler;
            if (origSpecial && origSpecial.handle) {
              handler = origSpecial.handle;
            } else {
              handler = handleObj.handler;
            }
            const ret = handler.apply(matched.elem, args);
            if (ret !== void 0) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
        if (special2 && special2.postDispatch) {
          special2.postDispatch.call(elem, event);
        }
        return event.result;
      };
      $.event.handlers = function(event, handlers) {
        const delegateCount = handlers.delegateCount;
        const handlerQueue = [];
        if (delegateCount && // Support: Firefox <=42 - 66+
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11+
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              const matchedHandlers = [];
              const matchedSelectors = {};
              for (let i = 0; i < delegateCount; i++) {
                const handleObj = handlers[i];
                const sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = cur.matches(sel);
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                });
              }
            }
          }
        }
        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: this,
            handlers: handlers.slice(delegateCount)
          });
        }
        return handlerQueue;
      };
      $.event.fix = function(originalEvent) {
        return originalEvent.envelope ? originalEvent : new Event(originalEvent);
      };
      const $root = $(document$1);
      const svg$1 = "http://www.w3.org/2000/svg";
      const xmlns = "http://www.w3.org/2000/xmlns/";
      const xml = "http://www.w3.org/XML/1998/namespace";
      const xlink = "http://www.w3.org/1999/xlink";
      const xhtml = "http://www.w3.org/1999/xhtml";
      var ns = {
        __proto__: null,
        svg: svg$1,
        xhtml,
        xlink,
        xml,
        xmlns
      };
      const isSVGSupported = typeof window === "object" && !!window.SVGAngle;
      const SVG_VERSION = "1.1";
      const internalSVGDocument = isSVGSupported ? createSVGDocument() : null;
      const internalSVGGroup = isSVGSupported ? createSVGElement("g") : null;
      function createSVGDocument() {
        const svg2 = createSVGElement("svg");
        svg2.setAttributeNS(xmlns, "xmlns:xlink", xlink);
        svg2.setAttribute("version", SVG_VERSION);
        return svg2;
      }
      function createSVGElement(name) {
        return document.createElementNS(svg$1, name);
      }
      function getCommonAncestor(node1, node2) {
        let parent2 = node1;
        do {
          if (parent2.contains(node2)) return parent2;
          parent2 = parent2.parentNode;
        } while (parent2);
        return null;
      }
      function createIdentityMatrix() {
        return internalSVGDocument.createSVGMatrix();
      }
      function createMatrix(matrixInit = {}) {
        const matrix = internalSVGDocument.createSVGMatrix();
        if (!matrixInit) return matrix;
        if ("a" in matrixInit) matrix.a = matrixInit.a;
        if ("b" in matrixInit) matrix.b = matrixInit.b;
        if ("c" in matrixInit) matrix.c = matrixInit.c;
        if ("d" in matrixInit) matrix.d = matrixInit.d;
        if ("e" in matrixInit) matrix.e = matrixInit.e;
        if ("f" in matrixInit) matrix.f = matrixInit.f;
        return matrix;
      }
      function createSVGTransform() {
        return internalSVGDocument.createSVGTransform();
      }
      function getNodeMatrix(node) {
        const consolidatedTransformation = node.transform.baseVal.consolidate();
        return consolidatedTransformation ? consolidatedTransformation.matrix : null;
      }
      function createMatrixFromTransformString(transformString) {
        internalSVGGroup.setAttribute("transform", transformString);
        return getNodeMatrix(internalSVGGroup);
      }
      function replaceTransformNode(node, matrixInit) {
        node.setAttribute("transform", matrixToTransformString(matrixInit));
      }
      function transformNode(node, matrixInit) {
        const transform = createSVGTransform();
        const matrix = isSVGMatrix(matrixInit) ? matrixInit : createMatrix(matrixInit);
        transform.setMatrix(matrix);
        node.transform.baseVal.appendItem(transform);
      }
      const MATRIX_TYPE = "[object SVGMatrix]";
      function isSVGMatrix(obj) {
        return Object.prototype.toString.call(obj) === MATRIX_TYPE;
      }
      function matrixToTransformString(matrixInit = {}) {
        const {
          a = 1,
          b = 0,
          c = 0,
          d = 1,
          e = 0,
          f: f2 = 0
        } = matrixInit;
        return `matrix(${a},${b},${c},${d},${e},${f2})`;
      }
      function getRelativeTransformation(a, b) {
        if ((a.ownerSVGElement || a) !== (b.ownerSVGElement || b)) return null;
        const am = b.getScreenCTM();
        if (!am) return null;
        const bm = a.getScreenCTM();
        if (!bm) return null;
        return am.inverse().multiply(bm);
      }
      function getRelativeTransformationSafe(a, b) {
        if (a === b) {
          return createIdentityMatrix();
        }
        const position2 = a.compareDocumentPosition(b);
        if (position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          return getLinealTransformation(a, b).inverse();
        } else if (position2 & Node.DOCUMENT_POSITION_CONTAINS) {
          return getLinealTransformation(b, a);
        }
        const c = getCommonAncestor(a, b);
        if (!c) {
          return null;
        }
        const mca = getLinealTransformation(c, a);
        const mcb = getLinealTransformation(c, b);
        return mcb.inverse().multiply(mca);
      }
      function getLinealTransformation(ancestor, descendant) {
        const transformations = [];
        let n = descendant;
        while (n && n.nodeType === Node.ELEMENT_NODE && n !== ancestor) {
          const nm = getNodeMatrix(n);
          if (nm) {
            transformations.unshift(nm);
          }
          n = n.parentNode;
        }
        return transformations.reduce((m, t) => m.multiply(t), createIdentityMatrix());
      }
      const V2 = (function() {
        if (!isSVGSupported) {
          return function() {
            throw new Error("SVG is required to use Vectorizer.");
          };
        }
        var math = Math;
        var PI2 = math.PI;
        var atan22 = math.atan2;
        var sqrt2 = math.sqrt;
        var min2 = math.min;
        var max2 = math.max;
        var cos2 = math.cos;
        var sin2 = math.sin;
        var V3 = function(el, attrs, children2) {
          if (!(this instanceof V3)) {
            return V3.apply(Object.create(V3.prototype), arguments);
          }
          if (!el) return;
          if (V3.isV(el)) {
            el = el.node;
          }
          attrs = attrs || {};
          if (V3.isString(el)) {
            el = el.trim();
            if (el.toLowerCase() === "svg") {
              el = V3.createSvgDocument();
            } else if (el[0] === "<") {
              var svgDoc = V3.createSvgDocument(el);
              if (svgDoc.childNodes.length > 1) {
                var arrayOfVels = [];
                var i, len;
                for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {
                  var childNode = svgDoc.childNodes[i];
                  arrayOfVels.push(new V3(document.importNode(childNode, true)));
                }
                return arrayOfVels;
              }
              el = document.importNode(svgDoc.firstChild, true);
            } else {
              el = createSVGElement(el);
            }
            V3.ensureId(el);
          }
          this.node = el;
          this.setAttributes(attrs);
          if (children2) {
            this.append(children2);
          }
          return this;
        };
        var VPrototype = V3.prototype;
        Object.defineProperty(VPrototype, "id", {
          enumerable: true,
          get: function() {
            return this.node.id;
          },
          set: function(id2) {
            this.node.id = id2;
          }
        });
        VPrototype.getTransformToElement = function(target, opt) {
          const node = this.node;
          const targetNode = V3.toNode(target);
          let m;
          if (V3.isSVGGraphicsElement(targetNode) && V3.isSVGGraphicsElement(node)) {
            if (opt && opt.safe) {
              m = getRelativeTransformationSafe(node, targetNode);
            } else {
              m = getRelativeTransformation(node, targetNode);
            }
          }
          return m || createIdentityMatrix();
        };
        VPrototype.transform = function(matrix, opt) {
          const node = this.node;
          if (V3.isUndefined(matrix)) {
            return getNodeMatrix(node) || createIdentityMatrix();
          }
          if (opt && opt.absolute) {
            replaceTransformNode(node, matrix);
          } else {
            transformNode(node, matrix);
          }
          return this;
        };
        VPrototype.translate = function(tx, ty, opt) {
          opt = opt || {};
          ty = ty || 0;
          var transformAttr = this.attr("transform") || "";
          var transform = V3.parseTransformString(transformAttr);
          transformAttr = transform.value;
          if (V3.isUndefined(tx)) {
            return transform.translate;
          }
          transformAttr = transformAttr.replace(/translate\([^)]*\)/g, "").trim();
          var newTx = opt.absolute ? tx : transform.translate.tx + tx;
          var newTy = opt.absolute ? ty : transform.translate.ty + ty;
          var newTranslate = "translate(" + newTx + "," + newTy + ")";
          this.attr("transform", (newTranslate + " " + transformAttr).trim());
          return this;
        };
        VPrototype.rotate = function(angle, cx, cy, opt) {
          opt = opt || {};
          var transformAttr = this.attr("transform") || "";
          var transform = V3.parseTransformString(transformAttr);
          transformAttr = transform.value;
          if (V3.isUndefined(angle)) {
            return transform.rotate;
          }
          transformAttr = transformAttr.replace(/rotate\([^)]*\)/g, "").trim();
          angle %= 360;
          var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;
          var newOrigin = cx !== void 0 && cy !== void 0 ? "," + cx + "," + cy : "";
          var newRotate = "rotate(" + newAngle + newOrigin + ")";
          this.attr("transform", (transformAttr + " " + newRotate).trim());
          return this;
        };
        VPrototype.scale = function(sx, sy) {
          sy = V3.isUndefined(sy) ? sx : sy;
          var transformAttr = this.attr("transform") || "";
          var transform = V3.parseTransformString(transformAttr);
          transformAttr = transform.value;
          if (V3.isUndefined(sx)) {
            return transform.scale;
          }
          transformAttr = transformAttr.replace(/scale\([^)]*\)/g, "").trim();
          var newScale = "scale(" + sx + "," + sy + ")";
          this.attr("transform", (transformAttr + " " + newScale).trim());
          return this;
        };
        VPrototype.bbox = function(withoutTransformations, target) {
          var box;
          var node = this.node;
          var ownerSVGElement = node.ownerSVGElement;
          if (!ownerSVGElement) {
            return new Rect(0, 0, 0, 0);
          }
          try {
            box = node.getBBox();
          } catch {
            box = {
              x: node.clientLeft,
              y: node.clientTop,
              width: node.clientWidth,
              height: node.clientHeight
            };
          }
          if (withoutTransformations) {
            return new Rect(box);
          }
          var matrix = this.getTransformToElement(target || ownerSVGElement);
          return V3.transformRect(box, matrix);
        };
        VPrototype.getBBox = function(opt) {
          var options = {};
          var outputBBox;
          var node = this.node;
          var ownerSVGElement = node.ownerSVGElement;
          if (!ownerSVGElement || !V3.isSVGGraphicsElement(node)) {
            return new Rect(0, 0, 0, 0);
          }
          if (opt) {
            if (opt.target) {
              options.target = V3.toNode(opt.target);
            }
            if (opt.recursive) {
              options.recursive = opt.recursive;
            }
          }
          if (!options.recursive) {
            try {
              outputBBox = node.getBBox();
            } catch {
              outputBBox = {
                x: node.clientLeft,
                y: node.clientTop,
                width: node.clientWidth,
                height: node.clientHeight
              };
            }
            if (!options.target) {
              return new Rect(outputBBox);
            } else {
              var matrix = this.getTransformToElement(options.target);
              return V3.transformRect(outputBBox, matrix);
            }
          } else {
            var children2 = this.children();
            var n = children2.length;
            if (n === 0) {
              return this.getBBox({
                target: options.target,
                recursive: false
              });
            }
            if (!options.target) {
              options.target = this;
            }
            for (var i = 0; i < n; i++) {
              var currentChild = children2[i];
              var childBBox;
              if (currentChild.children().length === 0) {
                childBBox = currentChild.getBBox({
                  target: options.target,
                  recursive: false
                });
              } else {
                childBBox = currentChild.getBBox({
                  target: options.target,
                  recursive: true
                });
              }
              if (!outputBBox) {
                outputBBox = childBBox;
              } else {
                outputBBox = outputBBox.union(childBBox);
              }
            }
            return outputBBox;
          }
        };
        function createTextPathNode(attrs, vel) {
          attrs || (attrs = {});
          var textPathElement = V3("textPath");
          var d = attrs.d;
          if (d && attrs["xlink:href"] === void 0) {
            var linkedPath = V3("path").attr("d", d).appendTo(vel.defs());
            textPathElement.attr("xlink:href", "#" + linkedPath.id);
          }
          if (V3.isObject(attrs)) {
            textPathElement.attr(attrs);
          }
          return textPathElement.node;
        }
        function annotateTextLine(lineNode, lineAnnotations, opt) {
          opt || (opt = {});
          var includeAnnotationIndices = opt.includeAnnotationIndices;
          var eol = opt.eol;
          var lineHeight = opt.lineHeight;
          var baseSize = opt.baseSize;
          var maxFontSize = 0;
          var fontMetrics = {};
          var lastJ = lineAnnotations.length - 1;
          for (var j = 0; j <= lastJ; j++) {
            var annotation = lineAnnotations[j];
            var fontSize = null;
            if (V3.isObject(annotation)) {
              var annotationAttrs = annotation.attrs;
              var vTSpan = V3("tspan", annotationAttrs);
              var tspanNode = vTSpan.node;
              var t = annotation.t;
              if (eol && j === lastJ) t += eol;
              tspanNode.textContent = t;
              var annotationClass = annotationAttrs["class"];
              if (annotationClass) vTSpan.addClass(annotationClass);
              if (includeAnnotationIndices) vTSpan.attr("annotations", annotation.annotations);
              fontSize = parseFloat(annotationAttrs["font-size"]);
              if (!isFinite(fontSize)) fontSize = baseSize;
              if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;
            } else {
              if (eol && j === lastJ) annotation += eol;
              tspanNode = document.createTextNode(annotation || " ");
              if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;
            }
            lineNode.appendChild(tspanNode);
          }
          if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;
          if (lineHeight) {
            fontMetrics.lineHeight = lineHeight;
          } else if (maxFontSize) {
            fontMetrics.lineHeight = maxFontSize * 1.2;
          }
          return fontMetrics;
        }
        var emRegex = /em$/;
        function convertEmToPx(em, fontSize) {
          var numerical = parseFloat(em);
          if (emRegex.test(em)) return numerical * fontSize;
          return numerical;
        }
        function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {
          if (!Array.isArray(linesMetrics)) return 0;
          var n = linesMetrics.length;
          if (!n) return 0;
          var lineMetrics = linesMetrics[0];
          var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
          var rLineHeights = 0;
          var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);
          for (var i = 1; i < n; i++) {
            lineMetrics = linesMetrics[i];
            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;
            rLineHeights += iLineHeight;
          }
          var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;
          var dy;
          switch (alignment) {
            case "middle":
              dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;
              break;
            case "bottom":
              dy = -(0.25 * llMaxFont) - rLineHeights;
              break;
            case "top":
            default:
              dy = 0.8 * flMaxFont;
              break;
          }
          return dy;
        }
        VPrototype.text = function(content, opt) {
          if (content && typeof content !== "string") throw new Error("Vectorizer: text() expects the first argument to be a string.");
          opt || (opt = {});
          if (content == null) content = "";
          if (opt.useNoBreakSpace) {
            content = V3.sanitizeText(content);
          }
          var displayEmpty = opt.displayEmpty;
          var eol = opt.eol;
          var textPath = opt.textPath;
          var verticalAnchor = opt.textVerticalAnchor;
          var namedVerticalAnchor = verticalAnchor === "middle" || verticalAnchor === "bottom" || verticalAnchor === "top";
          var x = opt.x;
          if (x === void 0) x = this.attr("x") || 0;
          var iai = opt.includeAnnotationIndices;
          var annotations = opt.annotations;
          if (annotations && !V3.isArray(annotations)) annotations = [annotations];
          var defaultLineHeight = opt.lineHeight;
          var autoLineHeight = defaultLineHeight === "auto";
          var lineHeight = autoLineHeight ? "1.5em" : defaultLineHeight || "1em";
          this.empty();
          this.attr({
            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.
            "xml:space": "preserve",
            // An empty text gets rendered into the DOM in webkit-based browsers.
            // In order to unify this behaviour across all browsers
            // we rather hide the text element when it's empty.
            "display": content || displayEmpty ? null : "none"
          });
          var fontSize = parseFloat(this.attr("font-size"));
          if (!fontSize) {
            fontSize = 16;
            if (namedVerticalAnchor || annotations) this.attr("font-size", fontSize);
          }
          var doc = document;
          var containerNode;
          if (textPath) {
            if (typeof textPath === "string") textPath = {
              d: textPath
            };
            containerNode = createTextPathNode(textPath, this);
          } else {
            containerNode = doc.createDocumentFragment();
          }
          var offset2 = 0;
          var lines = content.split("\n");
          var linesMetrics = [];
          var annotatedY;
          for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {
            var dy = lineHeight;
            var lineClassName = "v-line";
            var lineNode = doc.createElementNS(svg$1, "tspan");
            var line2 = lines[i];
            var lineMetrics;
            if (line2) {
              if (annotations) {
                var lineAnnotations = V3.annotateString(line2, annotations, {
                  offset: -offset2,
                  includeAnnotationIndices: iai
                });
                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {
                  includeAnnotationIndices: iai,
                  eol: i !== lastI && eol,
                  lineHeight: autoLineHeight ? null : lineHeight,
                  baseSize: fontSize
                });
                var iLineHeight = lineMetrics.lineHeight;
                if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;
                if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;
              } else {
                if (eol && i !== lastI) line2 += eol;
                lineNode.textContent = line2;
              }
            } else {
              lineNode.textContent = "-";
              lineClassName += " v-empty-line";
              var lineNodeStyle = lineNode.style;
              lineNodeStyle.fillOpacity = 0;
              lineNodeStyle.strokeOpacity = 0;
              if (annotations) {
                lineMetrics = {};
                lineAnnotations = V3.findAnnotationsAtIndex(annotations, offset2);
                let lineFontSize = fontSize;
                for (let j = lineAnnotations.length; j > 0; j--) {
                  const attrs = lineAnnotations[j - 1].attrs;
                  if (!attrs || !("font-size" in attrs)) continue;
                  const fs = parseFloat(attrs["font-size"]);
                  if (isFinite(fs)) {
                    lineFontSize = fs;
                    break;
                  }
                }
                if (autoLineHeight) {
                  if (i > 0) {
                    dy = lineFontSize * 1.2;
                  } else {
                    annotatedY = lineFontSize * 0.8;
                  }
                }
                lineNode.setAttribute("font-size", lineFontSize);
                lineMetrics.maxFontSize = lineFontSize;
              }
            }
            if (lineMetrics) linesMetrics.push(lineMetrics);
            if (i > 0) lineNode.setAttribute("dy", dy);
            if (i > 0 || textPath) lineNode.setAttribute("x", x);
            lineNode.className.baseVal = lineClassName;
            containerNode.appendChild(lineNode);
            offset2 += line2.length + 1;
          }
          if (namedVerticalAnchor) {
            if (annotations) {
              dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);
            } else if (verticalAnchor === "top") {
              dy = "0.8em";
            } else {
              var rh;
              if (lastI > 0) {
                rh = parseFloat(lineHeight) || 1;
                rh *= lastI;
                if (!emRegex.test(lineHeight)) rh /= fontSize;
              } else {
                rh = 0;
              }
              switch (verticalAnchor) {
                case "middle":
                  dy = 0.3 - rh / 2 + "em";
                  break;
                case "bottom":
                  dy = -rh - 0.3 + "em";
                  break;
              }
            }
          } else {
            if (verticalAnchor === 0) {
              dy = "0em";
            } else if (verticalAnchor) {
              dy = verticalAnchor;
            } else {
              dy = 0;
              if (this.attr("y") === null) this.attr("y", annotatedY || "0.8em");
            }
          }
          containerNode.firstChild.setAttribute("dy", dy);
          this.append(containerNode);
          return this;
        };
        VPrototype.removeAttr = function(name) {
          const trueName = attributeNames[name];
          const {
            ns: ns2,
            local
          } = V3.qualifyAttr(trueName);
          const el = this.node;
          if (ns2) {
            if (el.hasAttributeNS(ns2, local)) {
              el.removeAttributeNS(ns2, local);
            }
          } else if (el.hasAttribute(trueName)) {
            el.removeAttribute(trueName);
          }
          return this;
        };
        VPrototype.attr = function(name, value) {
          if (V3.isUndefined(name)) {
            var attributes2 = this.node.attributes;
            var attrs = {};
            for (var i = 0; i < attributes2.length; i++) {
              attrs[attributes2[i].name] = attributes2[i].value;
            }
            return attrs;
          }
          if (V3.isString(name) && V3.isUndefined(value)) {
            return this.node.getAttribute(attributeNames[name]);
          }
          if (typeof name === "object") {
            for (var attrName in name) {
              if (name.hasOwnProperty(attrName)) {
                this.setAttribute(attrName, name[attrName]);
              }
            }
          } else {
            this.setAttribute(name, value);
          }
          return this;
        };
        VPrototype.normalizePath = function() {
          var tagName = this.tagName();
          if (tagName === "PATH") {
            this.attr("d", V3.normalizePathData(this.attr("d")));
          }
          return this;
        };
        VPrototype.remove = function() {
          if (this.node.parentNode) {
            this.node.parentNode.removeChild(this.node);
          }
          return this;
        };
        VPrototype.empty = function() {
          while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
          }
          return this;
        };
        VPrototype.setAttributes = function(attrs) {
          for (var key in attrs) {
            if (attrs.hasOwnProperty(key)) {
              this.setAttribute(key, attrs[key]);
            }
          }
          return this;
        };
        VPrototype.append = function(els) {
          if (!V3.isArray(els)) {
            els = [els];
          }
          for (var i = 0, len = els.length; i < len; i++) {
            this.node.appendChild(V3.toNode(els[i]));
          }
          return this;
        };
        VPrototype.prepend = function(els) {
          var child = this.node.firstChild;
          return child ? V3(child).before(els) : this.append(els);
        };
        VPrototype.before = function(els) {
          var node = this.node;
          var parent2 = node.parentNode;
          if (parent2) {
            if (!V3.isArray(els)) {
              els = [els];
            }
            for (var i = 0, len = els.length; i < len; i++) {
              parent2.insertBefore(V3.toNode(els[i]), node);
            }
          }
          return this;
        };
        VPrototype.appendTo = function(node) {
          V3.toNode(node).appendChild(this.node);
          return this;
        };
        VPrototype.svg = function() {
          return this.node instanceof window.SVGSVGElement ? this : V3(this.node.ownerSVGElement);
        };
        VPrototype.tagName = function() {
          return this.node.tagName.toUpperCase();
        };
        VPrototype.defs = function() {
          var context = this.svg() || this;
          var defsNode = context.node.getElementsByTagName("defs")[0];
          if (defsNode) return V3(defsNode);
          return V3("defs").appendTo(context);
        };
        VPrototype.clone = function() {
          var clone2 = V3(this.node.cloneNode(
            true
            /* deep */
          ));
          clone2.node.id = V3.uniqueId();
          return clone2;
        };
        VPrototype.findOne = function(selector) {
          var found = this.node.querySelector(selector);
          return found ? V3(found) : void 0;
        };
        VPrototype.find = function(selector) {
          var vels = [];
          var nodes = this.node.querySelectorAll(selector);
          if (nodes) {
            for (var i = 0; i < nodes.length; i++) {
              vels.push(V3(nodes[i]));
            }
          }
          return vels;
        };
        VPrototype.children = function() {
          var children2 = this.node.childNodes;
          var outputArray = [];
          for (var i = 0; i < children2.length; i++) {
            var currentChild = children2[i];
            if (currentChild.nodeType === 1) {
              outputArray.push(V3(children2[i]));
            }
          }
          return outputArray;
        };
        VPrototype.parent = function() {
          return V3(this.node.parentNode) || null;
        }, // Find an index of an element inside its container.
        VPrototype.index = function() {
          var index2 = 0;
          var node = this.node.previousSibling;
          while (node) {
            if (node.nodeType === 1) index2++;
            node = node.previousSibling;
          }
          return index2;
        };
        VPrototype.findParentByClass = function(className2, terminator) {
          var ownerSVGElement = this.node.ownerSVGElement;
          var node = this.node.parentNode;
          while (node && node !== terminator && node !== ownerSVGElement) {
            var vel = V3(node);
            if (vel.hasClass(className2)) {
              return vel;
            }
            node = node.parentNode;
          }
          return null;
        };
        VPrototype.contains = function(el) {
          var a = this.node;
          var b = V3.toNode(el);
          var bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && a.compareDocumentPosition(bup) & 16);
        };
        VPrototype.toLocalPoint = function(x, y) {
          var svg2 = this.svg().node;
          var p = svg2.createSVGPoint();
          p.x = x;
          p.y = y;
          try {
            var globalPoint = p.matrixTransform(svg2.getScreenCTM().inverse());
            var globalToLocalMatrix = this.getTransformToElement(svg2).inverse();
          } catch {
            return p;
          }
          return globalPoint.matrixTransform(globalToLocalMatrix);
        };
        VPrototype.translateCenterToPoint = function(p) {
          var bbox2 = this.getBBox({
            target: this.svg()
          });
          var center2 = bbox2.center();
          this.translate(p.x - center2.x, p.y - center2.y);
          return this;
        };
        VPrototype.translateAndAutoOrient = function(position2, reference, target) {
          position2 = new Point(position2);
          reference = new Point(reference);
          target || (target = this.svg());
          var scale2 = this.scale();
          this.attr("transform", "");
          var bbox2 = this.getBBox({
            target
          }).scale(scale2.sx, scale2.sy);
          var translateToOrigin = V3.createSVGTransform();
          translateToOrigin.setTranslate(-bbox2.x - bbox2.width / 2, -bbox2.y - bbox2.height / 2);
          var rotateAroundOrigin = V3.createSVGTransform();
          var angle = position2.angleBetween(reference, position2.clone().offset(1, 0));
          if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);
          var translateFromOrigin = V3.createSVGTransform();
          var finalPosition = position2.clone().move(reference, bbox2.width / 2);
          translateFromOrigin.setTranslate(2 * position2.x - finalPosition.x, 2 * position2.y - finalPosition.y);
          var ctm = this.getTransformToElement(target);
          var transform = V3.createSVGTransform();
          transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(scale2.sx, scale2.sy)))));
          this.attr("transform", matrixToTransformString(transform.matrix));
          return this;
        };
        VPrototype.animateAlongPath = function(attrs, path2) {
          path2 = V3.toNode(path2);
          var id2 = V3.ensureId(path2);
          var animateMotion = V3("animateMotion", attrs);
          var mpath = V3("mpath", {
            "xlink:href": "#" + id2
          });
          animateMotion.append(mpath);
          this.append(animateMotion);
          try {
            animateMotion.node.beginElement();
          } catch {
            if (document.documentElement.getAttribute("smiling") === "fake") {
              var animation = animateMotion.node;
              animation.animators = [];
              var animationID = animation.getAttribute("id");
              if (animationID) id2anim[animationID] = animation;
              var targets = getTargets(animation);
              for (var i = 0, len = targets.length; i < len; i++) {
                var target = targets[i];
                var animator = new Animator(animation, target, i);
                animators.push(animator);
                animation.animators[i] = animator;
                animator.register();
              }
            }
          }
          return this;
        };
        const noHTMLWhitespaceRegex = /[^\x20\t\r\n\f]+/g;
        function getTokenList(str) {
          if (!V3.isString(str)) return [];
          return str.trim().match(noHTMLWhitespaceRegex) || [];
        }
        VPrototype.hasClass = function(className2) {
          if (!V3.isString(className2)) return false;
          return this.node.classList.contains(className2.trim());
        };
        VPrototype.addClass = function(className2) {
          this.node.classList.add(...getTokenList(className2));
          return this;
        };
        VPrototype.removeClass = function(className2) {
          this.node.classList.remove(...getTokenList(className2));
          return this;
        };
        VPrototype.toggleClass = function(className2, toAdd) {
          const tokens = getTokenList(className2);
          for (let i = 0; i < tokens.length; i++) {
            this.node.classList.toggle(tokens[i], toAdd);
          }
          return this;
        };
        VPrototype.sample = function(interval) {
          interval = interval || 1;
          var node = this.node;
          var length2 = node.getTotalLength();
          var samples = [];
          var distance = 0;
          var sample;
          while (distance < length2) {
            sample = node.getPointAtLength(distance);
            samples.push({
              x: sample.x,
              y: sample.y,
              distance
            });
            distance += interval;
          }
          return samples;
        };
        VPrototype.convertToPath = function() {
          var path2 = V3("path");
          path2.attr(this.attr());
          var d = this.convertToPathData();
          if (d) {
            path2.attr("d", d);
          }
          return path2;
        };
        VPrototype.convertToPathData = function() {
          var tagName = this.tagName();
          switch (tagName) {
            case "PATH":
              return this.attr("d");
            case "LINE":
              return V3.convertLineToPathData(this.node);
            case "POLYGON":
              return V3.convertPolygonToPathData(this.node);
            case "POLYLINE":
              return V3.convertPolylineToPathData(this.node);
            case "ELLIPSE":
              return V3.convertEllipseToPathData(this.node);
            case "CIRCLE":
              return V3.convertCircleToPathData(this.node);
            case "RECT":
              return V3.convertRectToPathData(this.node);
          }
          throw new Error(tagName + " cannot be converted to PATH.");
        };
        V3.prototype.toGeometryShape = function() {
          var x, y, width2, height2, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;
          switch (this.tagName()) {
            case "RECT":
              x = parseFloat(this.attr("x")) || 0;
              y = parseFloat(this.attr("y")) || 0;
              width2 = parseFloat(this.attr("width")) || 0;
              height2 = parseFloat(this.attr("height")) || 0;
              return new Rect(x, y, width2, height2);
            case "CIRCLE":
              cx = parseFloat(this.attr("cx")) || 0;
              cy = parseFloat(this.attr("cy")) || 0;
              r = parseFloat(this.attr("r")) || 0;
              return new Ellipse$1({
                x: cx,
                y: cy
              }, r, r);
            case "ELLIPSE":
              cx = parseFloat(this.attr("cx")) || 0;
              cy = parseFloat(this.attr("cy")) || 0;
              rx = parseFloat(this.attr("rx")) || 0;
              ry = parseFloat(this.attr("ry")) || 0;
              return new Ellipse$1({
                x: cx,
                y: cy
              }, rx, ry);
            case "POLYLINE":
              points = V3.getPointsFromSvgNode(this);
              return new Polyline$1(points);
            case "POLYGON":
              points = V3.getPointsFromSvgNode(this);
              if (points.length > 1) points.push(points[0]);
              return new Polyline$1(points);
            case "PATH":
              d = this.attr("d");
              if (!Path$1.isDataSupported(d)) d = V3.normalizePathData(d);
              return new Path$1(d);
            case "LINE":
              x1 = parseFloat(this.attr("x1")) || 0;
              y1 = parseFloat(this.attr("y1")) || 0;
              x2 = parseFloat(this.attr("x2")) || 0;
              y2 = parseFloat(this.attr("y2")) || 0;
              return new Line({
                x: x1,
                y: y1
              }, {
                x: x2,
                y: y2
              });
          }
          return this.getBBox();
        };
        VPrototype.findIntersection = function(ref, target) {
          var svg2 = this.svg().node;
          target = target || svg2;
          var bbox2 = this.getBBox({
            target
          });
          var center2 = bbox2.center();
          if (!bbox2.intersectionWithLineFromCenterToPoint(ref)) return void 0;
          var spot;
          var tagName = this.tagName();
          if (tagName === "RECT") {
            var gRect = new Rect(parseFloat(this.attr("x") || 0), parseFloat(this.attr("y") || 0), parseFloat(this.attr("width")), parseFloat(this.attr("height")));
            var rectMatrix = this.getTransformToElement(target);
            var rectMatrixComponents = V3.decomposeMatrix(rectMatrix);
            var resetRotation = svg2.createSVGTransform();
            resetRotation.setRotate(-rectMatrixComponents.rotation, center2.x, center2.y);
            var rect2 = V3.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));
            spot = new Rect(rect2).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);
          } else if (tagName === "PATH" || tagName === "POLYGON" || tagName === "POLYLINE" || tagName === "CIRCLE" || tagName === "ELLIPSE") {
            var pathNode = tagName === "PATH" ? this : this.convertToPath();
            var samples = pathNode.sample();
            var minDistance = Infinity;
            var closestSamples = [];
            var i, sample, gp, centerDistance, refDistance, distance;
            for (i = 0; i < samples.length; i++) {
              sample = samples[i];
              gp = V3.createSVGPoint(sample.x, sample.y);
              gp = gp.matrixTransform(this.getTransformToElement(target));
              sample = new Point(gp);
              centerDistance = sample.distance(center2);
              refDistance = sample.distance(ref) * 1.1;
              distance = centerDistance + refDistance;
              if (distance < minDistance) {
                minDistance = distance;
                closestSamples = [{
                  sample,
                  refDistance
                }];
              } else if (distance < minDistance + 1) {
                closestSamples.push({
                  sample,
                  refDistance
                });
              }
            }
            closestSamples.sort(function(a, b) {
              return a.refDistance - b.refDistance;
            });
            if (closestSamples[0]) {
              spot = closestSamples[0].sample;
            }
          }
          return spot;
        };
        VPrototype.setAttribute = function(name, value) {
          const el = this.node;
          if (value === null) {
            this.removeAttr(name);
            return this;
          }
          const trueName = attributeNames[name];
          const {
            ns: ns2
          } = V3.qualifyAttr(trueName);
          if (ns2) {
            el.setAttributeNS(ns2, trueName, value);
          } else if (trueName === "id") {
            el.id = value;
          } else {
            el.setAttribute(trueName, value);
          }
          return this;
        };
        V3.createSvgDocument = function(content) {
          if (content) {
            const XMLString = `<svg xmlns="${svg$1}" xmlns:xlink="${xlink}" version="${SVG_VERSION}">${content}</svg>`;
            const {
              documentElement: documentElement2
            } = V3.parseXML(XMLString, {
              async: false
            });
            return documentElement2;
          }
          return createSVGDocument();
        };
        V3.createSVGStyle = function(stylesheet) {
          const {
            node
          } = V3("style", {
            type: "text/css"
          }, [V3.createCDATASection(stylesheet)]);
          return node;
        }, V3.createCDATASection = function(data2 = "") {
          const xml2 = document.implementation.createDocument(null, "xml", null);
          return xml2.createCDATASection(data2);
        };
        V3.idCounter = 0;
        V3.uniqueId = function() {
          return "v-" + ++V3.idCounter;
        };
        V3.toNode = function(el) {
          return V3.isV(el) ? el.node : el.nodeName && el || el[0];
        };
        V3.ensureId = function(node) {
          node = V3.toNode(node);
          return node.id || (node.id = V3.uniqueId());
        };
        V3.sanitizeText = function(text) {
          return (text || "").replace(/ /g, "Â ");
        };
        V3.isUndefined = function(value) {
          return typeof value === "undefined";
        };
        V3.isString = function(value) {
          return typeof value === "string";
        };
        V3.isObject = function(value) {
          return value && typeof value === "object";
        };
        V3.isArray = Array.isArray;
        V3.parseXML = function(data2, opt) {
          opt = opt || {};
          var xml2;
          try {
            var parser = new DOMParser();
            if (!V3.isUndefined(opt.async)) {
              parser.async = opt.async;
            }
            xml2 = parser.parseFromString(data2, "text/xml");
          } catch {
            xml2 = void 0;
          }
          if (!xml2 || xml2.getElementsByTagName("parsererror").length) {
            throw new Error("Invalid XML: " + data2);
          }
          return xml2;
        };
        const _attributeNames = /* @__PURE__ */ Object.create(null);
        [
          "attributeName",
          "baseFrequency",
          "baseProfile",
          "clipPathUnits",
          "contentScriptType",
          "contentStyleType",
          "diffuseConstant",
          "edgeMode",
          "externalResourcesRequired",
          "filterRes",
          // deprecated
          "filterUnits",
          "gradientTransform",
          "gradientUnits",
          "kernelMatrix",
          "kernelUnitLength",
          "keyPoints",
          "lengthAdjust",
          "limitingConeAngle",
          "markerHeight",
          "markerUnits",
          "markerWidth",
          "maskContentUnits",
          "maskUnits",
          "numOctaves",
          "pathLength",
          "patternContentUnits",
          "patternTransform",
          "patternUnits",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "preserveAlpha",
          "preserveAspectRatio",
          "primitiveUnits",
          "refX",
          "refY",
          "requiredExtensions",
          "requiredFeatures",
          "repeatCount",
          "specularConstant",
          "specularExponent",
          "spreadMethod",
          "startOffset",
          "stdDeviation",
          "stitchTiles",
          "surfaceScale",
          "systemLanguage",
          "tableValues",
          "targetX",
          "targetY",
          "textLength",
          "viewBox",
          "viewTarget",
          // deprecated
          "xChannelSelector",
          "yChannelSelector",
          "zoomAndPan"
          // deprecated
        ].forEach((name) => _attributeNames[name] = name);
        _attributeNames["xlinkShow"] = "xlink:show";
        _attributeNames["xlinkRole"] = "xlink:role";
        _attributeNames["xlinkActuate"] = "xlink:actuate";
        _attributeNames["xlinkHref"] = "xlink:href";
        _attributeNames["xlinkType"] = "xlink:type";
        _attributeNames["xlinkTitle"] = "xlink:title";
        _attributeNames["xmlBase"] = "xml:base";
        _attributeNames["xmlLang"] = "xml:lang";
        _attributeNames["xmlSpace"] = "xml:space";
        const attributeNames = new Proxy(_attributeNames, {
          get(cache2, name) {
            if (!V3.supportCamelCaseAttributes) return name;
            if (name in cache2) {
              return cache2[name];
            }
            return cache2[name] = name.replace(/[A-Z]/g, "-$&").toLowerCase();
          }
        });
        Object.defineProperty(V3, "attributeNames", {
          enumerable: true,
          value: attributeNames,
          writable: false
        });
        Object.defineProperty(V3, "supportCamelCaseAttributes", {
          enumerable: true,
          value: true,
          writable: true
        });
        V3.qualifyAttr = function(name) {
          if (name.indexOf(":") !== -1) {
            var combinedKey = name.split(":");
            return {
              ns: ns[combinedKey[0]],
              local: combinedKey[1]
            };
          }
          return {
            ns: null,
            local: name
          };
        };
        V3.transformSeparatorRegex = /[ ,]+/;
        V3.transformFunctionRegex = /\b(\w+)\(([^()]+)\)/;
        V3.transformTranslateRegex = /\btranslate\(([^()]+)\)/;
        V3.transformRotateRegex = /\brotate\(([^()]+)\)/;
        V3.transformScaleRegex = /\bscale\(([^()]+)\)/;
        V3.transformStringToMatrix = function(transform) {
          let matrix;
          if (V3.isString(transform)) {
            matrix = createMatrixFromTransformString(transform);
          }
          return matrix || createIdentityMatrix();
        };
        V3.matrixToTransformString = matrixToTransformString;
        V3.parseTransformString = function(transform) {
          var translate, rotate, scale2;
          if (transform) {
            var separator = V3.transformSeparatorRegex;
            if (transform.trim().indexOf("matrix") >= 0) {
              var matrix = V3.transformStringToMatrix(transform);
              var decomposedMatrix = V3.decomposeMatrix(matrix);
              translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];
              scale2 = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];
              rotate = [decomposedMatrix.rotation];
              var transformations = [];
              if (translate[0] !== 0 || translate[1] !== 0) {
                transformations.push("translate(" + translate + ")");
              }
              if (scale2[0] !== 1 || scale2[1] !== 1) {
                transformations.push("scale(" + scale2 + ")");
              }
              if (rotate[0] !== 0) {
                transformations.push("rotate(" + rotate + ")");
              }
              transform = transformations.join(" ");
            } else {
              const translateMatch = transform.match(V3.transformTranslateRegex);
              if (translateMatch) {
                translate = translateMatch[1].split(separator);
              }
              const rotateMatch = transform.match(V3.transformRotateRegex);
              if (rotateMatch) {
                rotate = rotateMatch[1].split(separator);
              }
              const scaleMatch = transform.match(V3.transformScaleRegex);
              if (scaleMatch) {
                scale2 = scaleMatch[1].split(separator);
              }
            }
          }
          var sx = scale2 && scale2[0] ? parseFloat(scale2[0]) : 1;
          return {
            value: transform,
            translate: {
              tx: translate && translate[0] ? parseInt(translate[0], 10) : 0,
              ty: translate && translate[1] ? parseInt(translate[1], 10) : 0
            },
            rotate: {
              angle: rotate && rotate[0] ? parseInt(rotate[0], 10) : 0,
              cx: rotate && rotate[1] ? parseInt(rotate[1], 10) : void 0,
              cy: rotate && rotate[2] ? parseInt(rotate[2], 10) : void 0
            },
            scale: {
              sx,
              sy: scale2 && scale2[1] ? parseFloat(scale2[1]) : sx
            }
          };
        };
        V3.deltaTransformPoint = function(matrix, point2) {
          var dx = point2.x * matrix.a + point2.y * matrix.c + 0;
          var dy = point2.x * matrix.b + point2.y * matrix.d + 0;
          return {
            x: dx,
            y: dy
          };
        };
        V3.decomposeMatrix = function(matrix) {
          var px = V3.deltaTransformPoint(matrix, {
            x: 0,
            y: 1
          });
          var py = V3.deltaTransformPoint(matrix, {
            x: 1,
            y: 0
          });
          var skewX = 180 / PI2 * atan22(px.y, px.x) - 90;
          var skewY = 180 / PI2 * atan22(py.y, py.x);
          return {
            translateX: matrix.e,
            translateY: matrix.f,
            scaleX: sqrt2(matrix.a * matrix.a + matrix.b * matrix.b),
            scaleY: sqrt2(matrix.c * matrix.c + matrix.d * matrix.d),
            skewX,
            skewY,
            rotation: skewX
            // rotation is the same as skew x
          };
        };
        V3.matrixToScale = function(matrix) {
          var a, b, c, d;
          if (matrix) {
            a = V3.isUndefined(matrix.a) ? 1 : matrix.a;
            d = V3.isUndefined(matrix.d) ? 1 : matrix.d;
            b = matrix.b;
            c = matrix.c;
          } else {
            a = d = 1;
          }
          return {
            sx: b ? sqrt2(a * a + b * b) : a,
            sy: c ? sqrt2(c * c + d * d) : d
          };
        };
        V3.matrixToRotate = function(matrix) {
          var p = {
            x: 0,
            y: 1
          };
          if (matrix) {
            p = V3.deltaTransformPoint(matrix, p);
          }
          return {
            angle: normalizeAngle(toDeg(atan22(p.y, p.x)) - 90)
          };
        };
        V3.matrixToTranslate = function(matrix) {
          return {
            tx: matrix && matrix.e || 0,
            ty: matrix && matrix.f || 0
          };
        };
        V3.isV = function(object) {
          return object instanceof V3;
        };
        V3.isVElement = V3.isV;
        V3.isSVGGraphicsElement = function(node) {
          if (!node) return false;
          node = V3.toNode(node);
          return node instanceof SVGElement && typeof node.getScreenCTM === "function";
        };
        V3.createSVGMatrix = createMatrix;
        V3.createSVGTransform = function(matrix) {
          if (!V3.isUndefined(matrix)) {
            if (!isSVGMatrix(matrix)) {
              matrix = createMatrix(matrix);
            }
            return internalSVGDocument.createSVGTransformFromMatrix(matrix);
          }
          return internalSVGDocument.createSVGTransform();
        };
        V3.createSVGPoint = function(x, y) {
          var p = internalSVGDocument.createSVGPoint();
          p.x = x;
          p.y = y;
          return p;
        };
        V3.transformRect = function(r, matrix) {
          var p = internalSVGDocument.createSVGPoint();
          p.x = r.x;
          p.y = r.y;
          var corner1 = p.matrixTransform(matrix);
          p.x = r.x + r.width;
          p.y = r.y;
          var corner2 = p.matrixTransform(matrix);
          p.x = r.x + r.width;
          p.y = r.y + r.height;
          var corner3 = p.matrixTransform(matrix);
          p.x = r.x;
          p.y = r.y + r.height;
          var corner4 = p.matrixTransform(matrix);
          var minX = min2(corner1.x, corner2.x, corner3.x, corner4.x);
          var maxX = max2(corner1.x, corner2.x, corner3.x, corner4.x);
          var minY = min2(corner1.y, corner2.y, corner3.y, corner4.y);
          var maxY = max2(corner1.y, corner2.y, corner3.y, corner4.y);
          return new Rect(minX, minY, maxX - minX, maxY - minY);
        };
        V3.transformPoint = function(p, matrix) {
          return new Point(V3.createSVGPoint(p.x, p.y).matrixTransform(matrix));
        };
        V3.transformLine = function(l, matrix) {
          return new Line(V3.transformPoint(l.start, matrix), V3.transformPoint(l.end, matrix));
        };
        V3.transformPolyline = function(p, matrix) {
          var inPoints = p instanceof Polyline$1 ? p.points : p;
          if (!V3.isArray(inPoints)) inPoints = [];
          var outPoints = [];
          for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V3.transformPoint(inPoints[i], matrix);
          return new Polyline$1(outPoints);
        };
        V3.styleToObject = function(styleString) {
          var ret = {};
          var styles = styleString.split(";");
          for (var i = 0; i < styles.length; i++) {
            var style = styles[i];
            var pair = style.split("=");
            ret[pair[0].trim()] = pair[1].trim();
          }
          return ret;
        };
        V3.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {
          var svgArcMax = 2 * PI2 - 1e-6;
          var r0 = innerRadius;
          var r1 = outerRadius;
          var a0 = startAngle;
          var a1 = endAngle;
          var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);
          var df = da < PI2 ? "0" : "1";
          var c0 = cos2(a0);
          var s0 = sin2(a0);
          var c1 = cos2(a1);
          var s1 = sin2(a1);
          return da >= svgArcMax ? r0 ? "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "M0," + r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + -r0 + "A" + r0 + "," + r0 + " 0 1,0 0," + r0 + "Z" : "M0," + r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + -r1 + "A" + r1 + "," + r1 + " 0 1,1 0," + r1 + "Z" : r0 ? "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L" + r0 * c1 + "," + r0 * s1 + "A" + r0 + "," + r0 + " 0 " + df + ",0 " + r0 * c0 + "," + r0 * s0 + "Z" : "M" + r1 * c0 + "," + r1 * s0 + "A" + r1 + "," + r1 + " 0 " + df + ",1 " + r1 * c1 + "," + r1 * s1 + "L0,0Z";
        };
        V3.mergeAttrs = function(a, b) {
          for (var attr2 in b) {
            if (attr2 === "class") {
              a[attr2] = a[attr2] ? a[attr2] + " " + b[attr2] : b[attr2];
            } else if (attr2 === "style") {
              if (V3.isObject(a[attr2]) && V3.isObject(b[attr2])) {
                a[attr2] = V3.mergeAttrs(a[attr2], b[attr2]);
              } else if (V3.isObject(a[attr2])) {
                a[attr2] = V3.mergeAttrs(a[attr2], V3.styleToObject(b[attr2]));
              } else if (V3.isObject(b[attr2])) {
                a[attr2] = V3.mergeAttrs(V3.styleToObject(a[attr2]), b[attr2]);
              } else {
                a[attr2] = V3.mergeAttrs(V3.styleToObject(a[attr2]), V3.styleToObject(b[attr2]));
              }
            } else {
              a[attr2] = b[attr2];
            }
          }
          return a;
        };
        V3.annotateString = function(t, annotations, opt) {
          annotations = annotations || [];
          opt = opt || {};
          var offset2 = opt.offset || 0;
          var compacted = [];
          var batch;
          var ret = [];
          var item;
          var prev;
          for (var i = 0; i < t.length; i++) {
            item = ret[i] = t[i];
            for (var j = 0; j < annotations.length; j++) {
              var annotation = annotations[j];
              var start = annotation.start + offset2;
              var end = annotation.end + offset2;
              if (i >= start && i < end) {
                if (V3.isObject(item)) {
                  item.attrs = V3.mergeAttrs(V3.mergeAttrs({}, item.attrs), annotation.attrs);
                } else {
                  item = ret[i] = {
                    t: t[i],
                    attrs: annotation.attrs
                  };
                }
                if (opt.includeAnnotationIndices) {
                  (item.annotations || (item.annotations = [])).push(j);
                }
              }
            }
            prev = ret[i - 1];
            if (!prev) {
              batch = item;
            } else if (V3.isObject(item) && V3.isObject(prev)) {
              if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {
                batch.t += item.t;
              } else {
                compacted.push(batch);
                batch = item;
              }
            } else if (V3.isObject(item)) {
              compacted.push(batch);
              batch = item;
            } else if (V3.isObject(prev)) {
              compacted.push(batch);
              batch = item;
            } else {
              batch = (batch || "") + item;
            }
          }
          if (batch) {
            compacted.push(batch);
          }
          return compacted;
        };
        V3.findAnnotationsAtIndex = function(annotations, index2) {
          var found = [];
          if (annotations) {
            annotations.forEach(function(annotation) {
              if (annotation.start < index2 && index2 <= annotation.end) {
                found.push(annotation);
              }
            });
          }
          return found;
        };
        V3.findAnnotationsBetweenIndexes = function(annotations, start, end) {
          var found = [];
          if (annotations) {
            annotations.forEach(function(annotation) {
              if (start >= annotation.start && start < annotation.end || end > annotation.start && end <= annotation.end || annotation.start >= start && annotation.end < end) {
                found.push(annotation);
              }
            });
          }
          return found;
        };
        V3.shiftAnnotations = function(annotations, index2, offset2) {
          if (annotations) {
            annotations.forEach(function(annotation) {
              if (annotation.start < index2 && annotation.end >= index2) {
                annotation.end += offset2;
              } else if (annotation.start >= index2) {
                annotation.start += offset2;
                annotation.end += offset2;
              }
            });
          }
          return annotations;
        };
        V3.convertLineToPathData = function(line2) {
          line2 = V3(line2);
          var d = ["M", line2.attr("x1") || "0", line2.attr("y1") || "0", "L", line2.attr("x2") || "0", line2.attr("y2") || "0"].join(" ");
          return d;
        };
        V3.convertPolygonToPathData = function(polygon) {
          var points = V3.getPointsFromSvgNode(polygon);
          if (points.length === 0) return null;
          return V3.svgPointsToPath(points) + " Z";
        };
        V3.convertPolylineToPathData = function(polyline) {
          var points = V3.getPointsFromSvgNode(polyline);
          if (points.length === 0) return null;
          return V3.svgPointsToPath(points);
        };
        V3.svgPointsToPath = function(points) {
          for (var i = 0, n = points.length; i < n; i++) {
            points[i] = points[i].x + " " + points[i].y;
          }
          return "M " + points.join(" L");
        };
        V3.getPointsFromSvgNode = function(node) {
          node = V3.toNode(node);
          var points = [];
          var nodePoints = node.points;
          if (nodePoints) {
            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {
              points.push(nodePoints.getItem(i));
            }
          }
          return points;
        };
        V3.KAPPA = 0.551784;
        V3.convertCircleToPathData = function(circle) {
          circle = V3(circle);
          var cx = parseFloat(circle.attr("cx")) || 0;
          var cy = parseFloat(circle.attr("cy")) || 0;
          var r = parseFloat(circle.attr("r"));
          var cd = r * V3.KAPPA;
          var d = [
            "M",
            cx,
            cy - r,
            // Move to the first point.
            "C",
            cx + cd,
            cy - r,
            cx + r,
            cy - cd,
            cx + r,
            cy,
            // I. Quadrant.
            "C",
            cx + r,
            cy + cd,
            cx + cd,
            cy + r,
            cx,
            cy + r,
            // II. Quadrant.
            "C",
            cx - cd,
            cy + r,
            cx - r,
            cy + cd,
            cx - r,
            cy,
            // III. Quadrant.
            "C",
            cx - r,
            cy - cd,
            cx - cd,
            cy - r,
            cx,
            cy - r,
            // IV. Quadrant.
            "Z"
          ].join(" ");
          return d;
        };
        V3.convertEllipseToPathData = function(ellipse2) {
          ellipse2 = V3(ellipse2);
          var cx = parseFloat(ellipse2.attr("cx")) || 0;
          var cy = parseFloat(ellipse2.attr("cy")) || 0;
          var rx = parseFloat(ellipse2.attr("rx"));
          var ry = parseFloat(ellipse2.attr("ry")) || rx;
          var cdx = rx * V3.KAPPA;
          var cdy = ry * V3.KAPPA;
          var d = [
            "M",
            cx,
            cy - ry,
            // Move to the first point.
            "C",
            cx + cdx,
            cy - ry,
            cx + rx,
            cy - cdy,
            cx + rx,
            cy,
            // I. Quadrant.
            "C",
            cx + rx,
            cy + cdy,
            cx + cdx,
            cy + ry,
            cx,
            cy + ry,
            // II. Quadrant.
            "C",
            cx - cdx,
            cy + ry,
            cx - rx,
            cy + cdy,
            cx - rx,
            cy,
            // III. Quadrant.
            "C",
            cx - rx,
            cy - cdy,
            cx - cdx,
            cy - ry,
            cx,
            cy - ry,
            // IV. Quadrant.
            "Z"
          ].join(" ");
          return d;
        };
        V3.convertRectToPathData = function(rect2) {
          rect2 = V3(rect2);
          return V3.rectToPath({
            x: parseFloat(rect2.attr("x")) || 0,
            y: parseFloat(rect2.attr("y")) || 0,
            width: parseFloat(rect2.attr("width")) || 0,
            height: parseFloat(rect2.attr("height")) || 0,
            rx: parseFloat(rect2.attr("rx")) || 0,
            ry: parseFloat(rect2.attr("ry")) || 0
          });
        };
        V3.rectToPath = function(r) {
          var d;
          var x = r.x;
          var y = r.y;
          var width2 = r.width;
          var height2 = r.height;
          var topRx = min2(r.rx || r["top-rx"] || 0, width2 / 2);
          var bottomRx = min2(r.rx || r["bottom-rx"] || 0, width2 / 2);
          var topRy = min2(r.ry || r["top-ry"] || 0, height2 / 2);
          var bottomRy = min2(r.ry || r["bottom-ry"] || 0, height2 / 2);
          if (topRx || bottomRx || topRy || bottomRy) {
            d = ["M", x, y + topRy, "v", height2 - topRy - bottomRy, "a", bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy, "h", width2 - 2 * bottomRx, "a", bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy, "v", -(height2 - bottomRy - topRy), "a", topRx, topRy, 0, 0, 0, -topRx, -topRy, "h", -(width2 - 2 * topRx), "a", topRx, topRy, 0, 0, 0, -topRx, topRy, "Z"];
          } else {
            d = ["M", x, y, "H", x + width2, "V", y + height2, "H", x, "V", y, "Z"];
          }
          return d.join(" ");
        };
        V3.normalizePathData = (function() {
          var spaces = "	\n\v\f\r Â áá ââââââââââââ¯âã\u2028\u2029";
          var pathCommand = new RegExp("([a-z])[" + spaces + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + spaces + "]*,?[" + spaces + "]*)+)", "ig");
          var pathValues = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + spaces + "]*,?[" + spaces + "]*", "ig");
          var math2 = Math;
          var PI3 = math2.PI;
          var sin3 = math2.sin;
          var cos3 = math2.cos;
          var tan = math2.tan;
          var asin = math2.asin;
          var sqrt3 = math2.sqrt;
          var abs2 = math2.abs;
          function q2c(x1, y1, ax, ay, x2, y2) {
            var _132 = 1 / 3;
            var _232 = 2 / 3;
            return [_132 * x1 + _232 * ax, _132 * y1 + _232 * ay, _132 * x2 + _232 * ax, _132 * y2 + _232 * ay, x2, y2];
          }
          function rotate(x, y, rad) {
            var X = x * cos3(rad) - y * sin3(rad);
            var Y = x * sin3(rad) + y * cos3(rad);
            return {
              x: X,
              y: Y
            };
          }
          function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            var _120 = PI3 * 120 / 180;
            var rad = PI3 / 180 * (+angle || 0);
            var res = [];
            var xy;
            if (!recursive) {
              xy = rotate(x1, y1, -rad);
              x1 = xy.x;
              y1 = xy.y;
              xy = rotate(x2, y2, -rad);
              x2 = xy.x;
              y2 = xy.y;
              var x = (x1 - x2) / 2;
              var y = (y1 - y2) / 2;
              var h = x * x / (rx * rx) + y * y / (ry * ry);
              if (h > 1) {
                h = sqrt3(h);
                rx = h * rx;
                ry = h * ry;
              }
              var rx2 = rx * rx;
              var ry2 = ry * ry;
              var k = (large_arc_flag == sweep_flag ? -1 : 1) * sqrt3(abs2((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
              if (!Number.isFinite(k)) {
                return [x1, y1, x2, y2, x2, y2];
              }
              var cx = k * rx * y / ry + (x1 + x2) / 2;
              var cy = k * -ry * x / rx + (y1 + y2) / 2;
              var f1 = asin(((y1 - cy) / ry).toFixed(9));
              var f2 = asin(((y2 - cy) / ry).toFixed(9));
              f1 = x1 < cx ? PI3 - f1 : f1;
              f2 = x2 < cx ? PI3 - f2 : f2;
              if (f1 < 0) f1 = PI3 * 2 + f1;
              if (f2 < 0) f2 = PI3 * 2 + f2;
              if (sweep_flag && f1 > f2) f1 = f1 - PI3 * 2;
              if (!sweep_flag && f2 > f1) f2 = f2 - PI3 * 2;
            } else {
              f1 = recursive[0];
              f2 = recursive[1];
              cx = recursive[2];
              cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs2(df) > _120) {
              var f2old = f2;
              var x2old = x2;
              var y2old = y2;
              f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
              x2 = cx + rx * cos3(f2);
              y2 = cy + ry * sin3(f2);
              res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = cos3(f1);
            var s1 = sin3(f1);
            var c2 = cos3(f2);
            var s2 = sin3(f2);
            var t = tan(df / 4);
            var hx = 4 / 3 * (rx * t);
            var hy = 4 / 3 * (ry * t);
            var m1 = [x1, y1];
            var m2 = [x1 + hx * s1, y1 - hy * c1];
            var m3 = [x2 + hx * s2, y2 - hy * c2];
            var m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
              return [m2, m3, m4].concat(res);
            } else {
              res = [m2, m3, m4].concat(res).join().split(",");
              var newres = [];
              var ii = res.length;
              for (var i = 0; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
              }
              return newres;
            }
          }
          function parsePathString(pathString) {
            if (!pathString) return null;
            var paramCounts = {
              a: 7,
              c: 6,
              h: 1,
              l: 2,
              m: 2,
              q: 4,
              s: 4,
              t: 2,
              v: 1,
              z: 0
            };
            var data2 = [];
            String(pathString).replace(pathCommand, function(a, b, c) {
              var params = [];
              var name = b.toLowerCase();
              c.replace(pathValues, function(a2, b2) {
                if (b2) params.push(+b2);
              });
              if (name === "m" && params.length > 2) {
                data2.push([b].concat(params.splice(0, 2)));
                name = "l";
                b = b === "m" ? "l" : "L";
              }
              while (params.length >= paramCounts[name]) {
                data2.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) break;
              }
            });
            return data2;
          }
          function pathToAbsolute(pathArray) {
            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) {
              pathArray = parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) return [["M", 0, 0]];
            var res = [];
            var x = 0;
            var y = 0;
            var mx = 0;
            var my = 0;
            var start = 0;
            var pa0;
            var ii = pathArray.length;
            for (var i = start; i < ii; i++) {
              var r = [];
              res.push(r);
              var pa = pathArray[i];
              pa0 = pa[0];
              if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                var jj;
                var j;
                switch (r[0]) {
                  case "A":
                    r[1] = pa[1];
                    r[2] = pa[2];
                    r[3] = pa[3];
                    r[4] = pa[4];
                    r[5] = pa[5];
                    r[6] = +pa[6] + x;
                    r[7] = +pa[7] + y;
                    break;
                  case "V":
                    r[1] = +pa[1] + y;
                    break;
                  case "H":
                    r[1] = +pa[1] + x;
                    break;
                  case "M":
                    mx = +pa[1] + x;
                    my = +pa[2] + y;
                    jj = pa.length;
                    for (j = 1; j < jj; j++) {
                      r[j] = +pa[j] + (j % 2 ? x : y);
                    }
                    break;
                  default:
                    jj = pa.length;
                    for (j = 1; j < jj; j++) {
                      r[j] = +pa[j] + (j % 2 ? x : y);
                    }
                    break;
                }
              } else {
                var kk = pa.length;
                for (var k = 0; k < kk; k++) {
                  r[k] = pa[k];
                }
              }
              switch (r[0]) {
                case "Z":
                  x = +mx;
                  y = +my;
                  break;
                case "H":
                  x = r[1];
                  break;
                case "V":
                  y = r[1];
                  break;
                case "M":
                  mx = r[r.length - 2];
                  my = r[r.length - 1];
                  x = r[r.length - 2];
                  y = r[r.length - 1];
                  break;
                default:
                  x = r[r.length - 2];
                  y = r[r.length - 1];
                  break;
              }
            }
            return res;
          }
          function normalize2(path2) {
            var p = pathToAbsolute(path2);
            var attrs = {
              x: 0,
              y: 0,
              bx: 0,
              by: 0,
              X: 0,
              Y: 0,
              qx: null,
              qy: null
            };
            function processPath(path3, d, pcom2) {
              var nx, ny;
              if (!path3) return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
              if (!(path3[0] in {
                T: 1,
                Q: 1
              })) {
                d.qx = null;
                d.qy = null;
              }
              switch (path3[0]) {
                case "M":
                  d.X = path3[1];
                  d.Y = path3[2];
                  break;
                case "A":
                  if (parseFloat(path3[1]) === 0 || parseFloat(path3[2]) === 0) {
                    path3 = ["L", path3[6], path3[7]];
                  } else {
                    path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
                  }
                  break;
                case "S":
                  if (pcom2 === "C" || pcom2 === "S") {
                    nx = d.x * 2 - d.bx;
                    ny = d.y * 2 - d.by;
                  } else {
                    nx = d.x;
                    ny = d.y;
                  }
                  path3 = ["C", nx, ny].concat(path3.slice(1));
                  break;
                case "T":
                  if (pcom2 === "Q" || pcom2 === "T") {
                    d.qx = d.x * 2 - d.qx;
                    d.qy = d.y * 2 - d.qy;
                  } else {
                    d.qx = d.x;
                    d.qy = d.y;
                  }
                  path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
                  break;
                case "Q":
                  d.qx = path3[1];
                  d.qy = path3[2];
                  path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
                  break;
                case "H":
                  path3 = ["L"].concat(path3[1], d.y);
                  break;
                case "V":
                  path3 = ["L"].concat(d.x, path3[1]);
                  break;
                case "L":
                  break;
                case "Z":
                  break;
              }
              return path3;
            }
            function fixArc(pp, i2) {
              if (pp[i2].length > 7) {
                pp[i2].shift();
                var pi = pp[i2];
                while (pi.length) {
                  pcoms[i2] = "A";
                  pp.splice(i2++, 0, ["C"].concat(pi.splice(0, 6)));
                }
                pp.splice(i2, 1);
                ii = p.length;
              }
            }
            var pcoms = [];
            var pfirst = "";
            var pcom = "";
            var ii = p.length;
            for (var i = 0; i < ii; i++) {
              if (p[i]) pfirst = p[i][0];
              if (pfirst !== "C") {
                pcoms[i] = pfirst;
                if (i > 0) pcom = pcoms[i - 1];
              }
              p[i] = processPath(p[i], attrs, pcom);
              if (pcoms[i] !== "A" && pfirst === "C") pcoms[i] = "C";
              fixArc(p, i);
              var seg = p[i];
              var seglen = seg.length;
              attrs.x = seg[seglen - 2];
              attrs.y = seg[seglen - 1];
              attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
              attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
            }
            if (!p[0][0] || p[0][0] !== "M") {
              p.unshift(["M", 0, 0]);
            }
            return p;
          }
          return function(pathData) {
            return normalize2(pathData).join(",").split(",").join(" ");
          };
        })();
        V3.getCommonAncestor = function(node1, node2) {
          if (!node1 || !node2) return null;
          return getCommonAncestor(V3.toNode(node1), V3.toNode(node2));
        };
        V3.namespace = {
          ...ns
        };
        V3.g = g2;
        return V3;
      })();
      function cleanNodesData(nodes) {
        let i = nodes.length;
        while (i--) cleanNodeData(nodes[i]);
      }
      function cleanNodeData(node) {
        $.event.remove(node);
        dataPriv.remove(node);
        dataUser.remove(node);
      }
      function removeNodes(nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node.parentNode) {
            node.parentNode.removeChild(node);
          }
        }
      }
      function remove() {
        for (let i = 0; i < this.length; i++) {
          const node = this[i];
          cleanNodeData(node);
          cleanNodesData(node.getElementsByTagName("*"));
        }
        removeNodes(this);
        return this;
      }
      function detach() {
        removeNodes(this);
        return this;
      }
      function empty() {
        for (let i = 0; i < this.length; i++) {
          const node = this[i];
          if (node.nodeType === 1) {
            cleanNodesData(node.getElementsByTagName("*"));
            node.textContent = "";
          }
        }
        return this;
      }
      function clone() {
        const clones = [];
        for (let i = 0; i < this.length; i++) {
          clones.push(this[i].cloneNode(true));
        }
        return this.pushStack(clones);
      }
      function html(html2) {
        const [el] = this;
        if (!el) return null;
        if (arguments.length === 0) return el.innerHTML;
        if (html2 === void 0) return this;
        cleanNodesData(el.getElementsByTagName("*"));
        if (typeof html2 === "string" || typeof html2 === "number") {
          el.innerHTML = html2;
        } else {
          el.innerHTML = "";
          return this.append(html2);
        }
        return this;
      }
      function append(...nodes) {
        const [parent2] = this;
        if (!parent2) return this;
        nodes.forEach((node) => {
          if (!node) return;
          if (typeof node === "string") {
            parent2.append(...$.parseHTML(node));
          } else if (node.toString() === "[object Object]") {
            this.append(...Array.from(node));
          } else if (Array.isArray(node)) {
            this.append(...node);
          } else {
            parent2.appendChild(node);
          }
        });
        return this;
      }
      function prepend(...nodes) {
        const [parent2] = this;
        if (!parent2) return this;
        nodes.forEach((node) => {
          if (!node) return;
          if (typeof node === "string") {
            parent2.prepend(...$.parseHTML(node));
          } else if (node.toString() === "[object Object]") {
            this.prepend(...Array.from(node));
          } else if (Array.isArray(node)) {
            this.prepend(...node);
          } else {
            parent2.insertBefore(node, parent2.firstChild);
          }
        });
        return this;
      }
      function appendTo(parent2) {
        $(parent2).append(this);
        return this;
      }
      function prependTo(parent2) {
        $(parent2).prepend(this);
        return this;
      }
      const requireUnits = {};
      ["width", "height", "top", "bottom", "left", "right", "padding", "paddingTop", "paddingBottom", "paddingLeft", "paddingRight", "margin", "marginTop", "marginBottom", "marginLeft", "marginRight"].forEach((cssProp) => {
        requireUnits[cssProp] = true;
      });
      function setCSSProperty(el, name, value) {
        if (typeof value === "number" && requireUnits[camelCase(name)]) {
          value += "px";
        }
        el.style[name] = value;
      }
      function css(name, value) {
        let styles;
        if (typeof name === "string") {
          if (value === void 0) {
            const [el] = this;
            if (!el) return null;
            return el.style[name];
          } else {
            styles = {
              [name]: value
            };
          }
        } else if (!name) {
          throw new Error("no styles provided");
        } else {
          styles = name;
        }
        for (let style in styles) {
          if (styles.hasOwnProperty(style)) {
            for (let i = 0; i < this.length; i++) {
              setCSSProperty(this[i], style, styles[style]);
            }
          }
        }
        return this;
      }
      function data(name, value) {
        if (arguments.length < 2) {
          const [el] = this;
          if (!el) return null;
          if (name === void 0) {
            return el.dataset;
          }
          return el.dataset[name];
        }
        for (let i = 0; i < this.length; i++) {
          this[i].dataset[name] = value;
        }
        return this;
      }
      function setNodesClass(method, nodes, args) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          V2.prototype[method].apply({
            node
          }, args);
        }
      }
      function removeClass() {
        setNodesClass("removeClass", this, arguments);
        return this;
      }
      function addClass$1() {
        setNodesClass("addClass", this, arguments);
        return this;
      }
      function toggleClass() {
        setNodesClass("toggleClass", this, arguments);
        return this;
      }
      function hasClass() {
        const [node] = this;
        if (!node) return false;
        return V2.prototype.hasClass.apply({
          node
        }, arguments);
      }
      function children(selector) {
        const matches2 = [];
        for (let i = 0; i < this.length; i++) {
          const node = this[i];
          let children2 = Array.from(node.children);
          if (typeof selector === "string") {
            children2 = children2.filter((child) => child.matches(selector));
          }
          matches2.push(...children2);
        }
        return this.pushStack(matches2);
      }
      function closest(selector) {
        const closest2 = [];
        for (let i = 0; i < this.length; i++) {
          const el = this[i];
          if (typeof selector === "string") {
            const closestEl = el.closest(selector);
            if (closestEl) {
              closest2.push(closestEl);
            }
          } else {
            const [ancestorEl] = $(selector);
            if (ancestorEl && ancestorEl.contains(el)) {
              closest2.push(ancestorEl);
            }
          }
        }
        return this.pushStack(closest2);
      }
      function on(types2, selector, data2, fn2) {
        $.event.on(this, types2, selector, data2, fn2);
        return this;
      }
      function one(types2, selector, data2, fn2) {
        $.event.on(this, types2, selector, data2, fn2, 1);
        return this;
      }
      function off(types2, selector, fn2) {
        if (types2 && types2.preventDefault && types2.handleObj) {
          const handleObj = types2.handleObj;
          $(types2.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }
        if (typeof types2 === "object") {
          for (let type in types2) {
            this.off(type, selector, types2[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn2 = selector;
          selector = void 0;
        }
        for (let i = 0; i < this.length; i++) {
          $.event.remove(this[i], types2, fn2, selector);
        }
        return this;
      }
      function width() {
        const [el] = this;
        if (el === window) return el.document.documentElement.clientWidth;
        else if (!el) return void 0;
        const styles = window.getComputedStyle(el);
        const height2 = el.offsetWidth;
        const borderTopWidth = parseFloat(styles.borderTopWidth);
        const borderBottomWidth = parseFloat(styles.borderBottomWidth);
        const paddingTop = parseFloat(styles.paddingTop);
        const paddingBottom = parseFloat(styles.paddingBottom);
        return height2 - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;
      }
      function height() {
        const [el] = this;
        if (el === window) return el.document.documentElement.clientHeight;
        if (!el) return void 0;
        const styles = window.getComputedStyle(el);
        const width2 = el.offsetHeight;
        const borderLeftWidth = parseFloat(styles.borderLeftWidth);
        const borderRightWidth = parseFloat(styles.borderRightWidth);
        const paddingLeft = parseFloat(styles.paddingLeft);
        const paddingRight = parseFloat(styles.paddingRight);
        return width2 - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;
      }
      function position() {
        const [el] = this;
        if (!el) return;
        let $el = $(el);
        let offsetParent;
        let offset2;
        let doc;
        let parentOffset = {
          top: 0,
          left: 0
        };
        if ($el.css("position") === "fixed") {
          offset2 = el.getBoundingClientRect();
        } else {
          offset2 = $el.offset();
          doc = el.ownerDocument;
          offsetParent = el.offsetParent || doc.documentElement;
          const isStaticallyPositioned = (el2) => {
            const {
              position: position2
            } = getComputedStyle(el2);
            return position2 === "static";
          };
          while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent || doc.documentElement;
          }
          if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {
            const offsetParentStyles = window.getComputedStyle(offsetParent);
            const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;
            const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;
            parentOffset = $(offsetParent).offset();
            parentOffset.top += borderTopWidth;
            parentOffset.left += borderLeftWidth;
          }
        }
        const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;
        const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;
        return {
          top: offset2.top - parentOffset.top - marginTop,
          left: offset2.left - parentOffset.left - marginLeft
        };
      }
      function offset(coordinates) {
        const [el] = this;
        if (coordinates === void 0) {
          if (!el) return null;
          if (!el.getClientRects().length) {
            return {
              top: 0,
              left: 0
            };
          }
          const rect2 = el.getBoundingClientRect();
          return {
            top: rect2.top + window.scrollY,
            left: rect2.left + window.scrollX
          };
        }
        if (!el) return this;
        const currentStyle = window.getComputedStyle(el);
        if (currentStyle.position === "static") {
          this.css("position", "relative");
        }
        const currentOffset = this.offset();
        const topDifference = coordinates.top - currentOffset.top;
        const leftDifference = coordinates.left - currentOffset.left;
        this.css({
          top: (parseFloat(currentStyle.top) || 0) + topDifference + "px",
          left: (parseFloat(currentStyle.left) || 0) + leftDifference + "px"
        });
        return this;
      }
      var methods$1 = {
        __proto__: null,
        addClass: addClass$1,
        append,
        appendTo,
        children,
        clone,
        closest,
        css,
        data,
        detach,
        empty,
        hasClass,
        height,
        html,
        off,
        offset,
        on,
        one,
        position,
        prepend,
        prependTo,
        remove,
        removeClass,
        toggleClass,
        width
      };
      const animationKey = "animationFrameId";
      const cssReset = {};
      cssReset["transition-property"] = cssReset["transition-duration"] = cssReset["transition-delay"] = cssReset["transition-timing-function"] = cssReset["animation-name"] = cssReset["animation-duration"] = cssReset["animation-delay"] = cssReset["animation-timing-function"] = "";
      function animate(properties, opt = {}) {
        this.stop();
        for (let i = 0; i < this.length; i++) {
          animateNode(this[i], properties, opt);
        }
        return this;
      }
      function animateNode(el, properties, opt = {}) {
        let {
          duration = 400,
          easing = "ease-in-out",
          delay = 0,
          complete
        } = opt;
        const delayId = setTimeout(function() {
          const $el = $(el);
          let fired = false;
          let endEvent = "transitionend";
          duration = duration / 1e3;
          delay = delay / 1e3;
          const cssValues = {};
          if (typeof properties === "string") {
            cssValues["animation-name"] = properties;
            cssValues["animation-duration"] = duration + "s";
            cssValues["animation-delay"] = delay + "s";
            cssValues["animation-timing-function"] = easing;
            endEvent = "animationend";
          } else {
            const transitionProperties = [];
            for (var key in properties) {
              if (properties.hasOwnProperty(key)) {
                cssValues[key] = properties[key];
                transitionProperties.push(key);
              }
            }
            if (duration > 0) {
              cssValues["transition-property"] = transitionProperties.join(", ");
              cssValues["transition-duration"] = duration + "s";
              cssValues["transition-delay"] = delay + "s";
              cssValues["transition-timing-function"] = easing;
            }
          }
          const wrappedCallback = function(event) {
            if (event) {
              if (event.target !== event.currentTarget) return;
              event.target.removeEventListener(endEvent, wrappedCallback);
            } else {
              el.removeEventListener(endEvent, wrappedCallback);
            }
            fired = true;
            $el.css(cssReset);
            complete && complete.call(el);
          };
          if (duration > 0) {
            el.addEventListener(endEvent, wrappedCallback);
            const callbackId = setTimeout(function() {
              if (fired) return;
              wrappedCallback(null);
            }, (duration + delay) * 1e3 + 25);
            dataPriv.set(el, animationKey, {
              id: callbackId,
              stop: () => {
                clearTimeout(callbackId);
                el.removeEventListener(endEvent, wrappedCallback);
              }
            });
          }
          $el.css(cssValues);
          if (duration <= 0) {
            wrappedCallback(null);
          }
        });
        dataPriv.set(el, animationKey, {
          stop: () => clearTimeout(delayId)
        });
      }
      function stop() {
        for (let i = 0; i < this.length; i++) {
          const el = this[i];
          const animation = dataPriv.get(el, animationKey);
          if (!animation) continue;
          animation.stop();
          dataPriv.remove(el, animationKey);
        }
        this.css(cssReset);
        return this;
      }
      var animations = {
        __proto__: null,
        animate,
        stop
      };
      const propertySetters = {
        outerWidth: "offsetWidth",
        outerHeight: "offsetHeight",
        innerWidth: "clientWidth",
        innerHeight: "clientHeight",
        scrollLeft: "scrollLeft",
        scrollTop: "scrollTop",
        val: "value",
        text: "textContent"
      };
      const propertiesMap = {
        disabled: "disabled",
        value: "value",
        text: "textContent"
      };
      function prop(name, value) {
        if (!name) throw new Error("no property provided");
        if (arguments.length === 1) {
          const [el] = this;
          if (!el) return null;
          return el[name];
        }
        if (value === void 0) return this;
        for (let i = 0; i < this.length; i++) {
          this[i][name] = value;
        }
        return this;
      }
      function attr(name, value) {
        let attributes2;
        if (typeof name === "string") {
          if (value === void 0) {
            const [el] = this;
            if (!el) return null;
            return el.getAttribute(name);
          } else {
            attributes2 = {
              [name]: value
            };
          }
        } else if (!name) {
          throw new Error("no attributes provided");
        } else {
          attributes2 = name;
        }
        for (let attr2 in attributes2) {
          if (attributes2.hasOwnProperty(attr2)) {
            const value2 = attributes2[attr2];
            if (propertiesMap[attr2]) {
              this.prop(propertiesMap[attr2], value2);
              continue;
            }
            for (let i = 0; i < this.length; i++) {
              if (value2 === null) {
                this[i].removeAttribute(attr2);
              } else {
                this[i].setAttribute(attr2, value2);
              }
            }
          }
        }
        return this;
      }
      const methods = {
        prop,
        attr
      };
      Object.keys(propertySetters).forEach((methodName) => {
        methods[methodName] = function(...args) {
          return this.prop(propertySetters[methodName], ...args);
        };
      });
      const config$3 = {
        // How the cell attributes are merged when `cell.prop()` is called.
        // DEFAULT: the arrays are merged into the source array.
        cellMergeStrategy: null,
        // How the cell default attributes are merged with the attributes provided
        // in the cell constructor.
        // DEFAULT: the arrays are merged by replacing the source array
        // with the destination array.
        cellDefaultsMergeStrategy: null,
        // When set to `true` the cell selectors could be defined as CSS selectors.
        // If not, only JSON Markup selectors are taken into account.
        useCSSSelectors: false,
        // The class name prefix config is for advanced use only.
        // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.
        classNamePrefix: "joint-",
        defaultTheme: "default",
        // The maximum delay required for two consecutive touchend events to be interpreted
        // as a double-tap.
        doubleTapInterval: 300,
        // Name of the attribute used to store the layer id on the cell model.
        layerAttribute: "layer"
      };
      const special = /* @__PURE__ */ Object.create(null);
      special.load = {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      };
      [["mouseenter", "mouseover"], ["mouseleave", "mouseout"], ["pointerenter", "pointerover"], ["pointerleave", "pointerout"]].forEach(([orig, fix]) => {
        special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            const target = this;
            const related = event.relatedTarget;
            const handleObj = event.handleObj;
            let ret;
            if (!related || !target.contains(related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(target, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      const maxDelay = config$3.doubleTapInterval;
      const minDelay = 30;
      special.dbltap = {
        bindType: "touchend",
        delegateType: "touchend",
        handle: function(event, ...args) {
          const {
            handleObj,
            target
          } = event;
          const targetData = $.data.create(target);
          const now = (/* @__PURE__ */ new Date()).getTime();
          const delta = "lastTouch" in targetData ? now - targetData.lastTouch : 0;
          if (delta < maxDelay && delta > minDelay) {
            targetData.lastTouch = null;
            event.type = handleObj.origType;
            handleObj.handler.call(this, event, ...args);
          } else {
            targetData.lastTouch = now;
          }
        }
      };
      Object.assign($.fn, methods$1);
      Object.assign($.fn, animations);
      Object.assign($.fn, methods);
      Object.assign($.event.special, special);
      const addClassNamePrefix = function(className2) {
        if (!className2) return className2;
        return className2.toString().split(" ").map(function(_className) {
          if (_className.substr(0, config$3.classNamePrefix.length) !== config$3.classNamePrefix) {
            _className = config$3.classNamePrefix + _className;
          }
          return _className;
        }).join(" ");
      };
      const removeClassNamePrefix = function(className2) {
        if (!className2) return className2;
        return className2.toString().split(" ").map(function(_className) {
          if (_className.substr(0, config$3.classNamePrefix.length) === config$3.classNamePrefix) {
            _className = _className.substr(config$3.classNamePrefix.length);
          }
          return _className;
        }).join(" ");
      };
      const parseDOMJSON = function(json, namespace) {
        const selectors = {};
        const groupSelectors = {};
        const svgNamespace = V2.namespace.svg;
        const initialNS = namespace || svgNamespace;
        const fragment = document.createDocumentFragment();
        const parseNode = function(siblingsDef, parentNode, parentNS) {
          for (let i = 0; i < siblingsDef.length; i++) {
            const nodeDef = siblingsDef[i];
            if (typeof nodeDef === "string") {
              const textNode = document.createTextNode(nodeDef);
              parentNode.appendChild(textNode);
              continue;
            }
            if (!nodeDef.hasOwnProperty("tagName")) throw new Error("json-dom-parser: missing tagName");
            const tagName = nodeDef.tagName;
            let node;
            const ns2 = nodeDef.hasOwnProperty("namespaceURI") ? nodeDef.namespaceURI : parentNS;
            node = document.createElementNS(ns2, tagName);
            const svg2 = ns2 === svgNamespace;
            const wrapperNode = svg2 ? V2(node) : $(node);
            const attributes2 = nodeDef.attributes;
            if (attributes2) wrapperNode.attr(attributes2);
            const style = nodeDef.style;
            if (style) $(node).css(style);
            if (nodeDef.hasOwnProperty("className")) {
              const className2 = nodeDef.className;
              if (svg2) {
                node.className.baseVal = className2;
              } else {
                node.className = className2;
              }
            }
            if (nodeDef.hasOwnProperty("textContent")) {
              node.textContent = nodeDef.textContent;
            }
            if (nodeDef.hasOwnProperty("selector")) {
              const nodeSelector = nodeDef.selector;
              if (selectors[nodeSelector]) throw new Error("json-dom-parser: selector must be unique");
              selectors[nodeSelector] = node;
              wrapperNode.attr("joint-selector", nodeSelector);
            }
            if (nodeDef.hasOwnProperty("groupSelector")) {
              let nodeGroups = nodeDef.groupSelector;
              if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];
              for (let j = 0; j < nodeGroups.length; j++) {
                const nodeGroup = nodeGroups[j];
                let group = groupSelectors[nodeGroup];
                if (!group) group = groupSelectors[nodeGroup] = [];
                group.push(node);
              }
            }
            parentNode.appendChild(node);
            const childrenDef = nodeDef.children;
            if (Array.isArray(childrenDef)) {
              parseNode(childrenDef, node, ns2);
            }
          }
        };
        parseNode(json, fragment, initialNS);
        return {
          fragment,
          selectors,
          groupSelectors
        };
      };
      const hashCode = function(str) {
        let hash = 0;
        if (str.length === 0) return hash;
        for (let i = 0; i < str.length; i++) {
          const c = str.charCodeAt(i);
          hash = (hash << 5) - hash + c;
          hash = hash & hash;
        }
        return hash;
      };
      const getByPath = function(obj, path2, delimiter) {
        var keys2 = Array.isArray(path2) ? path2 : path2.split(delimiter || "/");
        var key;
        var i = 0;
        var length2 = keys2.length;
        while (i < length2) {
          key = keys2[i++];
          if (Object(obj) === obj && key in obj) {
            obj = obj[key];
          } else {
            return void 0;
          }
        }
        return obj;
      };
      const isGetSafe = function(obj, key) {
        if (typeof key !== "string" && typeof key !== "number") {
          key = String(key);
        }
        if (key === "constructor" && typeof obj[key] === "function") {
          return false;
        }
        if (key === "__proto__") {
          return false;
        }
        return true;
      };
      const setByPath = function(obj, path2, value, delimiter) {
        const keys2 = Array.isArray(path2) ? path2 : path2.split(delimiter || "/");
        const last2 = keys2.length - 1;
        let diver = obj;
        let i = 0;
        for (; i < last2; i++) {
          const key = keys2[i];
          if (!isGetSafe(diver, key)) return obj;
          const value2 = diver[key];
          diver = value2 || (diver[key] = {});
        }
        diver[keys2[last2]] = value;
        return obj;
      };
      const unsetByPath = function(obj, path2, delimiter) {
        const keys2 = Array.isArray(path2) ? path2 : path2.split(delimiter || "/");
        const last2 = keys2.length - 1;
        let diver = obj;
        let i = 0;
        for (; i < last2; i++) {
          const key = keys2[i];
          if (!isGetSafe(diver, key)) return obj;
          const value = diver[key];
          if (!value) return obj;
          diver = value;
        }
        delete diver[keys2[last2]];
        return obj;
      };
      const flattenObject = function(obj, delim, stop2) {
        delim = delim || "/";
        var ret = {};
        for (var key in obj) {
          if (!obj.hasOwnProperty(key)) continue;
          var shouldGoDeeper = typeof obj[key] === "object";
          if (shouldGoDeeper && stop2 && stop2(obj[key])) {
            shouldGoDeeper = false;
          }
          if (shouldGoDeeper) {
            var flatObject = flattenObject(obj[key], delim, stop2);
            for (var flatKey in flatObject) {
              if (!flatObject.hasOwnProperty(flatKey)) continue;
              ret[key + delim + flatKey] = flatObject[flatKey];
            }
          } else {
            ret[key] = obj[key];
          }
        }
        return ret;
      };
      const uuid = function() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0;
          var v = c === "x" ? r : r & 3 | 8;
          return v.toString(16);
        });
      };
      const guid = function(obj) {
        guid.id = guid.id || 1;
        if (obj === void 0) {
          return "j_" + guid.id++;
        }
        obj.id = obj.id === void 0 ? "j_" + guid.id++ : obj.id;
        return obj.id;
      };
      const toKebabCase = function(string) {
        return string.replace(/[A-Z]/g, "-$&").toLowerCase();
      };
      const normalizeEvent = function(evt) {
        if (evt.normalized) return evt;
        const {
          originalEvent,
          target
        } = evt;
        const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];
        if (touch) {
          for (let property2 in touch) {
            if (evt[property2] === void 0) {
              evt[property2] = touch[property2];
            }
          }
        }
        if (target) {
          const useElement = target.correspondingUseElement;
          if (useElement) evt.target = useElement;
        }
        evt.normalized = true;
        return evt;
      };
      const normalizeWheel = function(evt) {
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;
        let sX = 0, sY = 0, pX = 0, pY = 0;
        if ("detail" in evt) {
          sY = evt.detail;
        }
        if ("wheelDelta" in evt) {
          sY = -evt.wheelDelta / 120;
        }
        if ("wheelDeltaY" in evt) {
          sY = -evt.wheelDeltaY / 120;
        }
        if ("wheelDeltaX" in evt) {
          sX = -evt.wheelDeltaX / 120;
        }
        if ("axis" in evt && evt.axis === evt.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }
        pX = "deltaX" in evt ? evt.deltaX : sX * PIXEL_STEP;
        pY = "deltaY" in evt ? evt.deltaY : sY * PIXEL_STEP;
        if ((pX || pY) && evt.deltaMode) {
          if (evt.deltaMode == 1) {
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        }
        if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {
          pX = pY;
          pY = 0;
          sX = sY;
          sY = 0;
        }
        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }
        return {
          spinX: sX,
          spinY: sY,
          deltaX: pX,
          deltaY: pY
        };
      };
      const cap = function(val, max2) {
        return val > max2 ? max2 : val < -max2 ? -max2 : val;
      };
      const nextFrame = (function() {
        var raf;
        if (typeof window !== "undefined") {
          raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        }
        if (!raf) {
          var lastTime = 0;
          raf = function(callback) {
            var currTime = (/* @__PURE__ */ new Date()).getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id2 = setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id2;
          };
        }
        return function(callback, context, ...rest) {
          return context !== void 0 ? raf(callback.bind(context, ...rest)) : raf(callback);
        };
      })();
      const cancelFrame = (function() {
        var caf;
        var client = typeof window != "undefined";
        if (client) {
          caf = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame;
        }
        caf = caf || clearTimeout;
        return client ? caf.bind(window) : caf;
      })();
      const isPercentage = function(val) {
        return isString(val) && val.slice(-1) === "%";
      };
      const parseCssNumeric = function(val, restrictUnits) {
        function getUnit(validUnitExp2) {
          var matches2 = new RegExp("(?:\\d+(?:\\.\\d+)*)(" + validUnitExp2 + ")$").exec(val);
          if (!matches2) return null;
          return matches2[1];
        }
        var number = parseFloat(val);
        if (Number.isNaN(number)) return null;
        var output = {};
        output.value = number;
        var validUnitExp;
        if (restrictUnits == null) {
          validUnitExp = "[A-Za-z]*";
        } else if (Array.isArray(restrictUnits)) {
          if (restrictUnits.length === 0) return null;
          validUnitExp = restrictUnits.join("|");
        } else if (isString(restrictUnits)) {
          validUnitExp = restrictUnits;
        }
        var unit = getUnit(validUnitExp);
        if (unit === null) return null;
        output.unit = unit;
        return output;
      };
      const NO_SPACE = 0;
      function splitWordWithEOL(word, eol) {
        const eolWords = word.split(eol);
        let n = 1;
        for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {
          const replacement2 = [];
          if (j > 0 || eolWords[0] !== "") replacement2.push(NO_SPACE);
          replacement2.push(eol);
          if (j < jl - 1 || eolWords[jl] !== "") replacement2.push(NO_SPACE);
          eolWords.splice(n, 0, ...replacement2);
          n += replacement2.length + 1;
        }
        return eolWords.filter((word2) => word2 !== "");
      }
      function getLineHeight(heightValue, textElement) {
        if (heightValue === null) {
          return textElement.getBBox().height;
        }
        switch (heightValue.unit) {
          case "em":
            return textElement.getBBox().height * heightValue.value;
          case "px":
          case "":
            return heightValue.value;
        }
      }
      const breakText = function(text, size, styles = {}, opt = {}) {
        var width2 = size.width;
        var height2 = size.height;
        var svgDocument = opt.svgDocument || V2("svg").node;
        var textSpan = V2("tspan").node;
        var textElement = V2("text").attr(styles).append(textSpan).node;
        var textNode = document.createTextNode("");
        textElement.style.opacity = 0;
        textElement.style.display = "block";
        textSpan.style.display = "block";
        textSpan.appendChild(textNode);
        svgDocument.appendChild(textElement);
        if (!opt.svgDocument) {
          document.body.appendChild(svgDocument);
        }
        const preserveSpaces = opt.preserveSpaces;
        const space = " ";
        const separator = opt.separator || opt.separator === "" ? opt.separator : space;
        const separatorChar = typeof separator === "string" ? separator : space;
        var eol = opt.eol || "\n";
        var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\w\d\u00C0-\u1FFF\u2800-\uFFFD]/;
        var maxLineCount = opt.maxLineCount;
        if (!isNumber(maxLineCount)) maxLineCount = Infinity;
        var words2 = text.split(separator);
        var full = [];
        var lines = [];
        var p, h;
        var lineHeight;
        if (preserveSpaces) {
          V2(textSpan).attr("xml:space", "preserve");
        }
        for (var i = 0, l = 0, len = words2.length; i < len; i++) {
          var word = words2[i];
          if (!word && !preserveSpaces) continue;
          if (typeof word !== "string") continue;
          var isEol = false;
          if (eol && word.indexOf(eol) >= 0) {
            if (word.length > 1) {
              const eolWords = splitWordWithEOL(words2[i], eol);
              words2.splice(i, 1, ...eolWords);
              i--;
              len = words2.length;
              continue;
            } else {
              if (preserveSpaces && typeof words2[i - 1] === "string") {
                words2.splice(i, NO_SPACE, "", NO_SPACE);
                len += 2;
                i--;
                continue;
              }
              lines[++l] = !preserveSpaces || typeof words2[i + 1] === "string" ? "" : void 0;
              isEol = true;
            }
          }
          if (!isEol) {
            let data2;
            if (preserveSpaces) {
              data2 = lines[l] !== void 0 ? lines[l] + separatorChar + word : word;
            } else {
              data2 = lines[l] ? lines[l] + separatorChar + word : word;
            }
            textNode.data = data2;
            if (textSpan.getComputedTextLength() <= width2) {
              lines[l] = data2;
              if (p || h) {
                full[l++] = true;
                p = 0;
                h = 0;
              }
            } else {
              if (!lines[l] || p) {
                var partition = !!p;
                p = word.length - 1;
                if (partition || !p) {
                  if (!p) {
                    if (!lines[l]) {
                      lines = [];
                      break;
                    }
                    words2.splice(i, 2, word + words2[i + 1]);
                    len--;
                    full[l++] = true;
                    i--;
                    continue;
                  }
                  words2[i] = word.substring(0, p);
                  const nextWord = words2[i + 1];
                  words2[i + 1] = word.substring(p) + (nextWord === void 0 || nextWord === NO_SPACE ? "" : nextWord);
                } else {
                  if (h) {
                    words2.splice(i, 2, words2[i] + words2[i + 1]);
                    h = 0;
                  } else {
                    var hyphenIndex = word.search(hyphen);
                    if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {
                      h = hyphenIndex + 1;
                      p = 0;
                    }
                    words2.splice(i, 1, word.substring(0, h || p), word.substring(h || p));
                    len++;
                  }
                  if (l && !full[l - 1]) {
                    l--;
                  }
                }
                if (!preserveSpaces || lines[l] !== "") {
                  i--;
                }
                continue;
              }
              l++;
              i--;
            }
          }
          var lastL = null;
          if (lines.length > maxLineCount) {
            lastL = maxLineCount - 1;
          } else if (height2 !== void 0) {
            if (lineHeight === void 0 && textNode.data !== "") {
              if (styles.lineHeight === "auto") {
                lineHeight = getLineHeight({
                  value: 1.5,
                  unit: "em"
                }, textElement);
              } else {
                const parsed = parseCssNumeric(styles.lineHeight, ["em", "px", ""]);
                lineHeight = getLineHeight(parsed, textElement);
              }
            }
            if (lineHeight * lines.length > height2) {
              lastL = Math.floor(height2 / lineHeight) - 1;
            }
          }
          if (lastL !== null) {
            lines.splice(lastL + 1);
            var ellipsis = opt.ellipsis;
            if (!ellipsis || lastL < 0) break;
            if (typeof ellipsis !== "string") ellipsis = "â¦";
            var lastLine = lines[lastL];
            if (!lastLine && !isEol) break;
            var k = lastLine.length;
            var lastLineWithOmission, lastChar;
            do {
              lastChar = lastLine[k];
              lastLineWithOmission = lastLine.substring(0, k);
              if (!lastChar) {
                lastLineWithOmission += separatorChar;
              } else if (lastChar.match(separator)) {
                lastLineWithOmission += lastChar;
              }
              lastLineWithOmission += ellipsis;
              textNode.data = lastLineWithOmission;
              if (textSpan.getComputedTextLength() <= width2) {
                lines[lastL] = lastLineWithOmission;
                break;
              }
              k--;
            } while (k >= 0);
            break;
          }
        }
        if (opt.svgDocument) {
          svgDocument.removeChild(textElement);
        } else {
          document.body.removeChild(svgDocument);
        }
        return lines.join(eol);
      };
      const sanitizeHTML = function(html2) {
        const [outputEl] = $.parseHTML("<div>" + html2 + "</div>");
        Array.from(outputEl.getElementsByTagName("*")).forEach(function(node) {
          const names = node.getAttributeNames();
          names.forEach(function(name) {
            const value = node.getAttribute(name);
            if (name.startsWith("on") || value.startsWith("javascript:") || value.startsWith("data:") || value.startsWith("vbscript:")) {
              node.removeAttribute(name);
            }
          });
        });
        return outputEl.innerHTML;
      };
      const downloadBlob = function(blob, fileName) {
        if (window.navigator.msSaveBlob) {
          window.navigator.msSaveBlob(blob, fileName);
        } else {
          var url = window.URL.createObjectURL(blob);
          var link = document.createElement("a");
          link.href = url;
          link.download = fileName;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);
        }
      };
      const downloadDataUri = function(dataUri, fileName) {
        const blob = dataUriToBlob(dataUri);
        downloadBlob(blob, fileName);
      };
      const dataUriToBlob = function(dataUri) {
        dataUri = dataUri.replace(/\s/g, "");
        dataUri = decodeURIComponent(dataUri);
        var firstCommaIndex = dataUri.indexOf(",");
        var dataTypeString = dataUri.slice(0, firstCommaIndex);
        var mimeString = dataTypeString.split(":")[1].split(";")[0];
        var data2 = dataUri.slice(firstCommaIndex + 1);
        var decodedString;
        if (dataTypeString.indexOf("base64") >= 0) {
          decodedString = atob(data2);
        } else {
          decodedString = unescape(encodeURIComponent(data2));
        }
        var ia = new Uint8Array(decodedString.length);
        for (var i = 0; i < decodedString.length; i++) {
          ia[i] = decodedString.charCodeAt(i);
        }
        return new Blob([ia], {
          type: mimeString
        });
      };
      const imageToDataUri = function(url, callback) {
        if (!url || url.substr(0, "data:".length) === "data:") {
          return setTimeout(function() {
            callback(null, url);
          }, 0);
        }
        var modernHandler = function(xhr2, callback2) {
          if (xhr2.status === 200) {
            var reader = new FileReader();
            reader.onload = function(evt) {
              var dataUri = evt.target.result;
              callback2(null, dataUri);
            };
            reader.onerror = function() {
              callback2(new Error("Failed to load image " + url));
            };
            reader.readAsDataURL(xhr2.response);
          } else {
            callback2(new Error("Failed to load image " + url));
          }
        };
        var legacyHandler = function(xhr2, callback2) {
          var Uint8ToString = function(u8a) {
            var CHUNK_SZ = 32768;
            var c = [];
            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {
              c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));
            }
            return c.join("");
          };
          if (xhr2.status === 200) {
            var bytes = new Uint8Array(xhr2.response);
            var suffix = url.split(".").pop() || "png";
            var map = {
              "svg": "svg+xml"
            };
            var meta = "data:image/" + (map[suffix] || suffix) + ";base64,";
            var b64encoded = meta + btoa(Uint8ToString(bytes));
            callback2(null, b64encoded);
          } else {
            callback2(new Error("Failed to load image " + url));
          }
        };
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.addEventListener("error", function() {
          callback(new Error("Failed to load image " + url));
        });
        xhr.responseType = window.FileReader ? "blob" : "arraybuffer";
        xhr.addEventListener("load", function() {
          if (window.FileReader) {
            modernHandler(xhr, callback);
          } else {
            legacyHandler(xhr, callback);
          }
        });
        xhr.send();
      };
      const getElementBBox = function(el) {
        var $el = $(el);
        if ($el.length === 0) {
          throw new Error("Element not found");
        }
        var element = $el[0];
        var doc = element.ownerDocument;
        var clientBBox = element.getBoundingClientRect();
        var strokeWidthX = 0;
        var strokeWidthY = 0;
        if (element.ownerSVGElement) {
          var vel = V2(element);
          var bbox2 = vel.getBBox({
            target: vel.svg()
          });
          strokeWidthX = clientBBox.width - bbox2.width;
          strokeWidthY = clientBBox.height - bbox2.height;
        }
        return {
          x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,
          y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,
          width: clientBBox.width - strokeWidthX,
          height: clientBBox.height - strokeWidthY
        };
      };
      const sortElements = function(elements, comparator) {
        elements = $(elements).toArray();
        var placements = elements.map(function(sortElement) {
          var parentNode = sortElement.parentNode;
          var nextSibling = parentNode.insertBefore(document.createTextNode(""), sortElement.nextSibling);
          return function() {
            if (parentNode === this) {
              throw new Error("You can't sort elements if any one is a descendant of another.");
            }
            parentNode.insertBefore(this, nextSibling);
            parentNode.removeChild(nextSibling);
          };
        });
        elements.sort(comparator);
        for (var i = 0; i < placements.length; i++) {
          placements[i].call(elements[i]);
        }
        return elements;
      };
      const setAttributesBySelector = function(element, attrs) {
        var $element = $(element);
        forIn(attrs, function(attrs2, selector) {
          var $elements = $element.find(selector).addBack().filter(selector);
          if (has(attrs2, "class")) {
            $elements.addClass(attrs2["class"]);
            attrs2 = omit(attrs2, "class");
          }
          $elements.attr(attrs2);
        });
      };
      const normalizeSides = function(box) {
        if (Object(box) !== box) {
          var val = 0;
          if (isFinite(box)) val = +box;
          return {
            top: val,
            right: val,
            bottom: val,
            left: val
          };
        }
        var top2, right2, bottom2, left2;
        top2 = right2 = bottom2 = left2 = 0;
        if (isFinite(box.vertical)) top2 = bottom2 = +box.vertical;
        if (isFinite(box.horizontal)) right2 = left2 = +box.horizontal;
        if (isFinite(box.top)) top2 = +box.top;
        if (isFinite(box.right)) right2 = +box.right;
        if (isFinite(box.bottom)) bottom2 = +box.bottom;
        if (isFinite(box.left)) left2 = +box.left;
        return {
          top: top2,
          right: right2,
          bottom: bottom2,
          left: left2
        };
      };
      const timing = {
        linear: function(t) {
          return t;
        },
        quad: function(t) {
          return t * t;
        },
        cubic: function(t) {
          return t * t * t;
        },
        inout: function(t) {
          if (t <= 0) return 0;
          if (t >= 1) return 1;
          var t2 = t * t;
          var t3 = t2 * t;
          return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
        },
        exponential: function(t) {
          return Math.pow(2, 10 * (t - 1));
        },
        bounce: function(t) {
          for (var a = 0, b = 1; 1; a += b, b /= 2) {
            if (t >= (7 - 4 * a) / 11) {
              var q = (11 - 6 * a - 11 * t) / 4;
              return -q * q + b * b;
            }
          }
        },
        reverse: function(f2) {
          return function(t) {
            return 1 - f2(1 - t);
          };
        },
        reflect: function(f2) {
          return function(t) {
            return 0.5 * (t < 0.5 ? f2(2 * t) : 2 - f2(2 - 2 * t));
          };
        },
        clamp: function(f2, n, x) {
          n = n || 0;
          x = x || 1;
          return function(t) {
            var r = f2(t);
            return r < n ? n : r > x ? x : r;
          };
        },
        back: function(s) {
          if (!s) s = 1.70158;
          return function(t) {
            return t * t * ((s + 1) * t - s);
          };
        },
        elastic: function(x) {
          if (!x) x = 1.5;
          return function(t) {
            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);
          };
        }
      };
      const interpolate = {
        number: function(a, b) {
          var d = b - a;
          return function(t) {
            return a + d * t;
          };
        },
        object: function(a, b) {
          var s = Object.keys(a);
          return function(t) {
            var i, p;
            var r = {};
            for (i = s.length - 1; i != -1; i--) {
              p = s[i];
              r[p] = a[p] + (b[p] - a[p]) * t;
            }
            return r;
          };
        },
        hexColor: function(a, b) {
          var ca = parseInt(a.slice(1), 16);
          var cb2 = parseInt(b.slice(1), 16);
          var ra = ca & 255;
          var rd = (cb2 & 255) - ra;
          var ga = ca & 65280;
          var gd = (cb2 & 65280) - ga;
          var ba = ca & 16711680;
          var bd = (cb2 & 16711680) - ba;
          return function(t) {
            var r = ra + rd * t & 255;
            var g3 = ga + gd * t & 65280;
            var b2 = ba + bd * t & 16711680;
            return "#" + (1 << 24 | r | g3 | b2).toString(16).slice(1);
          };
        },
        unit: function(a, b) {
          var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;
          var ma = r.exec(a);
          var mb = r.exec(b);
          var p = mb[1].indexOf(".");
          var f2 = p > 0 ? mb[1].length - p - 1 : 0;
          a = +ma[1];
          var d = +mb[1] - a;
          var u = ma[2];
          return function(t) {
            return (a + d * t).toFixed(f2) + u;
          };
        }
      };
      const filter = {
        // `color` ... outline color ('blue')
        // `width`... outline width (1)
        // `opacity` ... outline opacity (1)
        // `margin` ... gap between outline and the element (2)
        outline: function(args) {
          var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="${outerRadius}" /><feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="${innerRadius}" /><feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/><feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/><feMerge><feMergeNode in="outline"/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
          var margin = Number.isFinite(args.margin) ? args.margin : 2;
          var width2 = Number.isFinite(args.width) ? args.width : 1;
          return template(tpl)({
            color: args.color || "blue",
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
            outerRadius: margin + width2,
            innerRadius: margin
          });
        },
        // `color` ... color ('red')
        // `width`... width (1)
        // `blur` ... blur (0)
        // `opacity` ... opacity (1)
        highlight: function(args) {
          var tpl = '<filter><feFlood flood-color="${color}" flood-opacity="${opacity}" result="colored"/><feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="${width}"/><feComposite result="composed" in="colored" in2="morphed" operator="in"/><feGaussianBlur result="blured" in="composed" stdDeviation="${blur}"/><feBlend in="SourceGraphic" in2="blured" mode="normal"/></filter>';
          return template(tpl)({
            color: args.color || "red",
            width: Number.isFinite(args.width) ? args.width : 1,
            blur: Number.isFinite(args.blur) ? args.blur : 0,
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1
          });
        },
        // `x` ... horizontal blur (2)
        // `y` ... vertical blur (optional)
        blur: function(args) {
          var x = Number.isFinite(args.x) ? args.x : 2;
          return template('<filter><feGaussianBlur stdDeviation="${stdDeviation}"/></filter>')({
            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x
          });
        },
        // `dx` ... horizontal shift (0)
        // `dy` ... vertical shift (0)
        // `blur` ... blur (4)
        // `color` ... color ('black')
        // `opacity` ... opacity (1)
        dropShadow: function(args) {
          var tpl = "SVGFEDropShadowElement" in window ? '<filter><feDropShadow stdDeviation="${blur}" dx="${dx}" dy="${dy}" flood-color="${color}" flood-opacity="${opacity}"/></filter>' : '<filter><feGaussianBlur in="SourceAlpha" stdDeviation="${blur}"/><feOffset dx="${dx}" dy="${dy}" result="offsetblur"/><feFlood flood-color="${color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="${opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
          return template(tpl)({
            dx: args.dx || 0,
            dy: args.dy || 0,
            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,
            color: args.color || "black",
            blur: Number.isFinite(args.blur) ? args.blur : 4
          });
        },
        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.
        grayscale: function(args) {
          var amount = Number.isFinite(args.amount) ? args.amount : 1;
          return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0"/></filter>')({
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
          });
        },
        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.
        sepia: function(args) {
          var amount = Number.isFinite(args.amount) ? args.amount : 1;
          return template('<filter><feColorMatrix type="matrix" values="${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0"/></filter>')({
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
          });
        },
        // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.
        saturate: function(args) {
          var amount = Number.isFinite(args.amount) ? args.amount : 1;
          return template('<filter><feColorMatrix type="saturate" values="${amount}"/></filter>')({
            amount: 1 - amount
          });
        },
        // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).
        hueRotate: function(args) {
          return template('<filter><feColorMatrix type="hueRotate" values="${angle}"/></filter>')({
            angle: args.angle || 0
          });
        },
        // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.
        invert: function(args) {
          var amount = Number.isFinite(args.amount) ? args.amount : 1;
          return template('<filter><feComponentTransfer><feFuncR type="table" tableValues="${amount} ${amount2}"/><feFuncG type="table" tableValues="${amount} ${amount2}"/><feFuncB type="table" tableValues="${amount} ${amount2}"/></feComponentTransfer></filter>')({
            amount,
            amount2: 1 - amount
          });
        },
        // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
        brightness: function(args) {
          return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}"/><feFuncG type="linear" slope="${amount}"/><feFuncB type="linear" slope="${amount}"/></feComponentTransfer></filter>')({
            amount: Number.isFinite(args.amount) ? args.amount : 1
          });
        },
        // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.
        contrast: function(args) {
          var amount = Number.isFinite(args.amount) ? args.amount : 1;
          return template('<filter><feComponentTransfer><feFuncR type="linear" slope="${amount}" intercept="${amount2}"/><feFuncG type="linear" slope="${amount}" intercept="${amount2}"/><feFuncB type="linear" slope="${amount}" intercept="${amount2}"/></feComponentTransfer></filter>')({
            amount,
            amount2: 0.5 - amount / 2
          });
        }
      };
      const format$1 = {
        // Formatting numbers via the Python Format Specification Mini-language.
        // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.
        // Heavilly inspired by the D3.js library implementation.
        number: function(specifier, value, locale) {
          locale = locale || {
            currency: ["$", ""],
            decimal: ".",
            thousands: ",",
            grouping: [3]
          };
          var re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
          var match = re.exec(specifier);
          var fill = match[1] || " ";
          var align2 = match[2] || ">";
          var sign = match[3] || "";
          var symbol = match[4] || "";
          var zfill = match[5];
          var width2 = +match[6];
          var comma = match[7];
          var precision = match[8];
          var type = match[9];
          var scale2 = 1;
          var prefix = "";
          var suffix = "";
          var integer = false;
          if (precision) precision = +precision.substring(1);
          if (zfill || fill === "0" && align2 === "=") {
            zfill = fill = "0";
            align2 = "=";
            if (comma) width2 -= Math.floor((width2 - 1) / 4);
          }
          switch (type) {
            case "n":
              comma = true;
              type = "g";
              break;
            case "%":
              scale2 = 100;
              suffix = "%";
              type = "f";
              break;
            case "p":
              scale2 = 100;
              suffix = "%";
              type = "r";
              break;
            case "b":
            case "o":
            case "x":
            case "X":
              if (symbol === "#") prefix = "0" + type.toLowerCase();
              break;
            case "c":
            case "d":
              integer = true;
              precision = 0;
              break;
            case "s":
              scale2 = -1;
              type = "r";
              break;
          }
          if (symbol === "$") {
            prefix = locale.currency[0];
            suffix = locale.currency[1];
          }
          if (type == "r" && !precision) type = "g";
          if (precision != null) {
            if (type == "g") precision = Math.max(1, Math.min(21, precision));
            else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
          }
          var zcomma = zfill && comma;
          if (integer && value % 1) return "";
          var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign;
          var fullSuffix = suffix;
          if (scale2 < 0) {
            var unit = this.prefix(value, precision);
            value = unit.scale(value);
            fullSuffix = unit.symbol + suffix;
          } else {
            value *= scale2;
          }
          value = this.convert(type, value, precision);
          var i = value.lastIndexOf(".");
          var before = i < 0 ? value : value.substring(0, i);
          var after = i < 0 ? "" : locale.decimal + value.substring(i + 1);
          function formatGroup(value2) {
            var i2 = value2.length;
            var t = [];
            var j = 0;
            var g3 = locale.grouping[0];
            while (i2 > 0 && g3 > 0) {
              t.push(value2.substring(i2 -= g3, i2 + g3));
              g3 = locale.grouping[j = (j + 1) % locale.grouping.length];
            }
            return t.reverse().join(locale.thousands);
          }
          if (!zfill && comma && locale.grouping) {
            before = formatGroup(before);
          }
          var length2 = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);
          var padding = length2 < width2 ? new Array(length2 = width2 - length2 + 1).join(fill) : "";
          if (zcomma) before = formatGroup(padding + before);
          negative += prefix;
          value = before + after;
          return (align2 === "<" ? negative + value + padding : align2 === ">" ? padding + negative + value : align2 === "^" ? padding.substring(0, length2 >>= 1) + negative + value + padding.substring(length2) : negative + (zcomma ? value : padding + value)) + fullSuffix;
        },
        // Formatting string via the Python Format string.
        // See https://docs.python.org/2/library/string.html#format-string-syntax)
        string: function(formatString, value) {
          var fieldDelimiterIndex;
          var fieldDelimiter = "{";
          var endPlaceholder = false;
          var formattedStringArray = [];
          while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {
            var pieceFormattedString, formatSpec, fieldName;
            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);
            if (endPlaceholder) {
              formatSpec = pieceFormattedString.split(":");
              fieldName = formatSpec.shift().split(".");
              pieceFormattedString = value;
              for (var i = 0; i < fieldName.length; i++) pieceFormattedString = pieceFormattedString[fieldName[i]];
              if (formatSpec.length) pieceFormattedString = this.number(formatSpec, pieceFormattedString);
            }
            formattedStringArray.push(pieceFormattedString);
            formatString = formatString.slice(fieldDelimiterIndex + 1);
            endPlaceholder = !endPlaceholder;
            fieldDelimiter = endPlaceholder ? "}" : "{";
          }
          formattedStringArray.push(formatString);
          return formattedStringArray.join("");
        },
        convert: function(type, value, precision) {
          switch (type) {
            case "b":
              return value.toString(2);
            case "c":
              return String.fromCharCode(value);
            case "o":
              return value.toString(8);
            case "x":
              return value.toString(16);
            case "X":
              return value.toString(16).toUpperCase();
            case "g":
              return value.toPrecision(precision);
            case "e":
              return value.toExponential(precision);
            case "f":
              return value.toFixed(precision);
            case "r":
              return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));
            default:
              return value + "";
          }
        },
        round: function(value, precision) {
          return precision ? Math.round(value * (precision = Math.pow(10, precision))) / precision : Math.round(value);
        },
        precision: function(value, precision) {
          return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);
        },
        prefix: function(value, precision) {
          var prefixes = ["y", "z", "a", "f", "p", "n", "Âµ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(function(d, i2) {
            var k = Math.pow(10, Math.abs(8 - i2) * 3);
            return {
              scale: i2 > 8 ? function(d2) {
                return d2 / k;
              } : function(d2) {
                return d2 * k;
              },
              symbol: d
            };
          });
          var i = 0;
          if (value) {
            if (value < 0) value *= -1;
            if (precision) value = this.round(value, this.precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));
          }
          return prefixes[8 + i / 3];
        }
      };
      const template = function(html2) {
        var regex = /<%= ([^ ]+) %>|\$\{ ?([^{} ]+) ?\}|\{\{([^{} ]+)\}\}/g;
        return function(data2) {
          data2 = data2 || {};
          return html2.replace(regex, function(match) {
            var args = Array.from(arguments);
            var attr2 = args.slice(1, 4).find(function(_attr) {
              return !!_attr;
            });
            var attrArray = attr2.split(".");
            var value = data2[attrArray.shift()];
            while (value !== void 0 && attrArray.length) {
              value = value[attrArray.shift()];
            }
            return value !== void 0 ? value : "";
          });
        };
      };
      const toggleFullScreen = function(el) {
        var topDocument = window.top.document;
        el = el || topDocument.body;
        function prefixedResult(el2, prop2) {
          var prefixes = ["webkit", "moz", "ms", "o", ""];
          for (var i = 0; i < prefixes.length; i++) {
            var prefix = prefixes[i];
            var propName = prefix ? prefix + prop2 : prop2.substr(0, 1).toLowerCase() + prop2.substr(1);
            if (el2[propName] !== void 0) {
              return isFunction(el2[propName]) ? el2[propName]() : el2[propName];
            }
          }
        }
        if (prefixedResult(topDocument, "FullscreenElement") || prefixedResult(topDocument, "FullScreenElement")) {
          prefixedResult(topDocument, "ExitFullscreen") || // Spec.
          prefixedResult(topDocument, "CancelFullScreen");
        } else {
          prefixedResult(el, "RequestFullscreen") || // Spec.
          prefixedResult(el, "RequestFullScreen");
        }
      };
      function findDifference(obj, baseObj, currentDepth, maxDepth) {
        if (currentDepth === maxDepth) {
          return {};
        }
        const diff2 = {};
        Object.keys(obj).forEach((key) => {
          const objValue = obj[key];
          const baseValue = baseObj[key];
          if (!Array.isArray(objValue) && !Array.isArray(baseValue) && isObject(objValue) && isObject(baseValue)) {
            const nestedDepth = currentDepth + 1;
            const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);
            if (Object.keys(nestedDiff).length > 0) {
              diff2[key] = nestedDiff;
            } else if (currentDepth === 0 || nestedDepth === maxDepth) {
              diff2[key] = {};
            }
          } else if (!isEqual(objValue, baseValue)) {
            diff2[key] = objValue;
          }
        });
        return diff2;
      }
      function objectDifference(object, base, opt) {
        const {
          maxDepth = Number.POSITIVE_INFINITY
        } = opt || {};
        return findDifference(object, base, 0, maxDepth);
      }
      const noop = function() {
      };
      var Events = {};
      var eventSplitter = /\s+/;
      var _listening;
      var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0, names;
        if (name && typeof name === "object") {
          if (callback !== void 0 && "context" in opts && opts.context === void 0) opts.context = callback;
          for (names = Object.keys(name); i < names.length; i++) {
            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
          }
        } else if (name && eventSplitter.test(name)) {
          for (names = name.split(eventSplitter); i < names.length; i++) {
            events = iteratee(events, names[i], callback, opts);
          }
        } else {
          events = iteratee(events, name, callback, opts);
        }
        return events;
      };
      Events.on = function(name, callback, context) {
        this._events = eventsApi(onApi, this._events || {}, name, callback, {
          context,
          ctx: this,
          listening: _listening
        });
        if (_listening) {
          var listeners = this._listeners || (this._listeners = {});
          listeners[_listening.id] = _listening;
          _listening.interop = false;
        }
        return this;
      };
      Events.listenTo = function(obj, name, callback) {
        if (!obj) return this;
        var id2 = obj._listenId || (obj._listenId = uniqueId("l"));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = _listening = listeningTo[id2];
        if (!listening) {
          this._listenId || (this._listenId = uniqueId("l"));
          listening = _listening = listeningTo[id2] = new Listening(this, obj);
        }
        var error = tryCatchOn(obj, name, callback, this);
        _listening = void 0;
        if (error) throw error;
        if (listening.interop) listening.on(name, callback);
        return this;
      };
      var onApi = function(events, name, callback, options) {
        if (callback) {
          var handlers = events[name] || (events[name] = []);
          var context = options.context, ctx = options.ctx, listening = options.listening;
          if (listening) listening.count++;
          handlers.push({
            callback,
            context,
            ctx: context || ctx,
            listening
          });
        }
        return events;
      };
      var tryCatchOn = function(obj, name, callback, context) {
        try {
          obj.on(name, callback, context);
        } catch (e) {
          return e;
        }
      };
      Events.off = function(name, callback, context) {
        if (!this._events) return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
          context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) return this;
        var ids = obj ? [obj._listenId] : Object.keys(listeningTo);
        for (var i = 0; i < ids.length; i++) {
          var listening = listeningTo[ids[i]];
          if (!listening) break;
          listening.obj.off(name, callback, this);
          if (listening.interop) listening.off(name, callback);
        }
        if (isEmpty(listeningTo)) this._listeningTo = void 0;
        return this;
      };
      var offApi = function(events, name, callback, options) {
        if (!events) return;
        var context = options.context, listeners = options.listeners;
        var i = 0, names;
        if (!name && !context && !callback) {
          if (listeners != null) {
            for (names = Object.keys(listeners); i < names.length; i++) {
              listeners[names[i]].cleanup();
            }
          }
          return;
        }
        names = name ? [name] : Object.keys(events);
        for (; i < names.length; i++) {
          name = names[i];
          var handlers = events[name];
          if (!handlers) break;
          var remaining = [];
          for (var j = 0; j < handlers.length; j++) {
            var handler = handlers[j];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              var listening = handler.listening;
              if (listening) listening.off(name, callback);
            }
          }
          if (remaining.length) {
            events[name] = remaining;
          } else {
            delete events[name];
          }
        }
        return events;
      };
      Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
        if (typeof name === "string" && context == null) callback = void 0;
        return this.on(events, callback, context);
      };
      Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
        return this.listenTo(obj, events);
      };
      var onceMap = function(map, name, callback, offer) {
        if (callback) {
          var once = map[name] = onceInvoke(function() {
            offer(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map;
      };
      var onceInvoke = function(func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError("Expected a function");
        }
        var n = 2;
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = void 0;
          }
          return result2;
        };
      };
      Events.trigger = function(name) {
        if (!this._events) return this;
        var length2 = Math.max(0, arguments.length - 1);
        var args = Array(length2);
        for (var i = 0; i < length2; i++) args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
          var events = objEvents[name];
          var allEvents = objEvents.all;
          if (events && allEvents) allEvents = allEvents.slice();
          if (events) triggerEvents(events, args);
          if (allEvents) triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events, args) {
        var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;
          case 3:
            while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;
          default:
            while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
      };
      var Listening = function(listener, obj) {
        this.id = listener._listenId;
        this.listener = listener;
        this.obj = obj;
        this.interop = true;
        this.count = 0;
        this._events = void 0;
      };
      Listening.prototype.on = Events.on;
      Listening.prototype.off = function(name, callback) {
        var cleanup;
        if (this.interop) {
          this._events = eventsApi(offApi, this._events, name, callback, {
            context: void 0,
            listeners: void 0
          });
          cleanup = !this._events;
        } else {
          this.count--;
          cleanup = this.count === 0;
        }
        if (cleanup) this.cleanup();
      };
      Listening.prototype.cleanup = function() {
        delete this.listener._listeningTo[this.obj._listenId];
        if (!this.interop) delete this.obj._listeners[this.id];
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      var extend = function(protoProps, staticProps) {
        var parent2 = this;
        var child;
        if (protoProps && has(protoProps, "constructor")) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent2.apply(this, arguments);
          };
        }
        assign(child, parent2, staticProps);
        child.prototype = Object.assign(Object.create(parent2.prototype), protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent2.prototype;
        return child;
      };
      var addMethod = function(base, length2, method, attribute) {
        switch (length2) {
          case 1:
            return function() {
              return base[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return base[method](this[attribute], value);
            };
          case 3:
            return function(iteratee, context) {
              return base[method](this[attribute], cb(iteratee, this), context);
            };
          case 4:
            return function(iteratee, defaultVal, context) {
              return base[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };
          default:
            return function() {
              var args = Array.prototype.slice.call(arguments);
              args.unshift(this[attribute]);
              return base[method].apply(base, args);
            };
        }
      };
      var addMethodsUtil = function(Class, base, methods2, attribute) {
        forIn(methods2, function(length2, method) {
          if (base[method]) Class.prototype[method] = addMethod(base, length2, method, attribute);
        });
      };
      var cb = function(iteratee, instance) {
        if (isFunction(iteratee)) return iteratee;
        if (isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
        if (isString(iteratee)) return function(model) {
          return model.get(iteratee);
        };
        return iteratee;
      };
      var modelMatcher = function(attrs) {
        var matcher = matches(attrs);
        return function(model) {
          return matcher(model.attributes);
        };
      };
      var Model = function(attributes2, options) {
        var attrs = attributes2 || {};
        options || (options = {});
        this.eventPrefix = options.eventPrefix || "";
        this.preinitialize.apply(this, arguments);
        this.cid = uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection) this.collection = options.collection;
        this._setDefaults(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      assign(Model.prototype, Events, {
        // A hash of attributes whose current and previous value differ.
        changed: null,
        // The value returned during the last failed validation.
        validationError: null,
        // The default name for the JSON `id` attribute is `"id"`. MongoDB and
        // CouchDB users may want to set this to `"_id"`.
        idAttribute: "id",
        // The prefix is used to create the client id which is used to identify models locally.
        // You may want to override this if you're experiencing name clashes with model ids.
        cidPrefix: "c",
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Model.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return clone$1(this.attributes);
        },
        // Get the value of an attribute.
        get: function(attr2) {
          return this.attributes[attr2];
        },
        // Returns `true` if the attribute contains a value that is not null
        // or undefined.
        has: function(attr2) {
          return this.get(attr2) != null;
        },
        // Set a hash of model attributes on the object, firing `"change"`. This is
        // the core primitive operation of a model, updating the data and notifying
        // anyone who needs to know about the change in state. The heart of the beast.
        set: function(key, val, options) {
          if (key == null) return this;
          var attrs;
          if (typeof key === "object") {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options)) return false;
          var unset2 = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = clone$1(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr2 in attrs) {
            val = attrs[attr2];
            if (!isEqual(current[attr2], val)) changes.push(attr2);
            if (!isEqual(prev[attr2], val)) {
              changed[attr2] = val;
            } else {
              delete changed[attr2];
            }
            unset2 ? delete current[attr2] : current[attr2] = val;
          }
          if (this.idAttribute in attrs) {
            var prevId = this.id;
            this.id = this.get(this.idAttribute);
            this.trigger(this.eventPrefix + "changeId", this, prevId, options);
          }
          if (!silent) {
            if (changes.length) this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger(this.eventPrefix + "change:" + changes[i], this, current[changes[i]], options);
            }
          }
          if (changing) return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger(this.eventPrefix + "change", this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        // Remove an attribute from the model, firing `"change"`. `unset` is a noop
        // if the attribute doesn't exist.
        unset: function(attr2, options) {
          return this.set(attr2, void 0, assign({}, options, {
            unset: true
          }));
        },
        // Clear all attributes on the model, firing `"change"`.
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes) attrs[key] = void 0;
          return this.set(attrs, assign({}, options, {
            unset: true
          }));
        },
        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr2) {
          if (attr2 == null) return !isEmpty(this.changed);
          return has(this.changed, attr2);
        },
        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff2) {
          if (!diff2) return this.hasChanged() ? clone$1(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          var hasChanged;
          for (var attr2 in diff2) {
            var val = diff2[attr2];
            if (isEqual(old[attr2], val)) continue;
            changed[attr2] = val;
            hasChanged = true;
          }
          return hasChanged ? changed : false;
        },
        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr2) {
          if (attr2 == null || !this._previousAttributes) return null;
          return this._previousAttributes[attr2];
        },
        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          return clone$1(this._previousAttributes);
        },
        // Create a new model with identical attributes to this one.
        clone: function() {
          return new this.constructor(this.attributes);
        },
        // Check if the model is currently in a valid state.
        isValid: function(options) {
          return this._validate({}, assign({}, options, {
            validate: true
          }));
        },
        // Run validation against the next complete set of model attributes,
        // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate) return true;
          attrs = assign({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error) return true;
          this.trigger("invalid", this, error, assign(options, {
            validationError: error
          }));
          return false;
        },
        _setDefaults: function(ctorAttributes, options) {
          const attributeDefaults = result(this, "defaults");
          const attributes2 = defaults(assign({}, attributeDefaults, ctorAttributes), attributeDefaults);
          this.set(attributes2, options);
        }
      });
      Model.extend = extend;
      function cloneCells(cells) {
        cells = uniq(cells);
        const cloneMap = toArray$1(cells).reduce(function(map, cell) {
          map[cell.id] = cell.clone();
          return map;
        }, {});
        toArray$1(cells).forEach(function(cell) {
          const clone2 = cloneMap[cell.id];
          if (clone2.isLink()) {
            const source = clone2.source();
            const target = clone2.target();
            if (source.id && cloneMap[source.id]) {
              clone2.prop("source/id", cloneMap[source.id].id);
            }
            if (target.id && cloneMap[target.id]) {
              clone2.prop("target/id", cloneMap[target.id].id);
            }
          }
          const parent2 = cell.get("parent");
          if (parent2 && cloneMap[parent2]) {
            clone2.set("parent", cloneMap[parent2].id);
          }
          const embeds = toArray$1(cell.get("embeds")).reduce(function(newEmbeds, embed) {
            if (cloneMap[embed]) {
              newEmbeds.push(cloneMap[embed].id);
            }
            return newEmbeds;
          }, []);
          if (!isEmpty(embeds)) {
            clone2.set("embeds", embeds);
          }
        });
        return cloneMap;
      }
      const validPropertiesList = ["checked", "selected", "disabled", "readOnly", "contentEditable", "value", "indeterminate"];
      const validProperties = validPropertiesList.reduce((acc, key) => {
        acc[key] = true;
        return acc;
      }, {});
      const props$1 = {
        qualify: function(properties) {
          return isPlainObject(properties);
        },
        set: function(properties, _, node) {
          Object.keys(properties).forEach(function(key) {
            if (validProperties[key] && key in node) {
              const value = properties[key];
              if (node.tagName === "SELECT" && Array.isArray(value)) {
                Array.from(node.options).forEach(function(option, index2) {
                  option.selected = value.includes(option.value);
                });
              } else {
                node[key] = value;
              }
            }
          });
        }
      };
      function positionWrapper(axis, dimension, origin) {
        return function(value, refBBox) {
          var valuePercentage = isPercentage(value);
          value = parseFloat(value);
          if (valuePercentage) {
            value /= 100;
          }
          var delta;
          if (isFinite(value)) {
            var refOrigin = refBBox[origin]();
            if (valuePercentage || value > 0 && value < 1) {
              delta = refOrigin[axis] + refBBox[dimension] * value;
            } else {
              delta = refOrigin[axis] + value;
            }
          }
          var point2 = Point();
          point2[axis] = delta || 0;
          return point2;
        };
      }
      function setWrapper(attrName, dimension) {
        return function(value, refBBox) {
          var isValuePercentage = isPercentage(value);
          value = parseFloat(value);
          if (isValuePercentage) {
            value /= 100;
          }
          var attrs = {};
          if (isFinite(value)) {
            var attrValue = isValuePercentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);
            attrs[attrName] = attrValue;
          }
          return attrs;
        };
      }
      const legacyAttributesNS = {
        // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width
        // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box
        // otherwise, `refX` is the left coordinate of the bounding box
        "ref-x": {
          position: positionWrapper("x", "width", "origin")
        },
        "ref-y": {
          position: positionWrapper("y", "height", "origin")
        },
        // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom
        // coordinate of the reference element.
        "ref-dx": {
          position: positionWrapper("x", "width", "corner")
        },
        "ref-dy": {
          position: positionWrapper("y", "height", "corner")
        },
        // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to
        // the reference element size
        // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width
        // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20
        "ref-width": {
          set: setWrapper("width", "width")
        },
        "ref-height": {
          set: setWrapper("height", "height")
        },
        "ref-rx": {
          set: setWrapper("rx", "width")
        },
        "ref-ry": {
          set: setWrapper("ry", "height")
        },
        "ref-cx": {
          set: setWrapper("cx", "width")
        },
        "ref-cy": {
          set: setWrapper("cy", "height")
        },
        "ref-r-inscribed": {
          set: (function(attrName) {
            var widthFn = setWrapper(attrName, "width");
            var heightFn = setWrapper(attrName, "height");
            return function(value, refBBox) {
              var fn2 = refBBox.height > refBBox.width ? widthFn : heightFn;
              return fn2(value, refBBox);
            };
          })("r")
        },
        "ref-r-circumscribed": {
          set: function(value, refBBox) {
            var isValuePercentage = isPercentage(value);
            value = parseFloat(value);
            if (isValuePercentage) {
              value /= 100;
            }
            var diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);
            var rValue;
            if (isFinite(value)) {
              if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;
              else rValue = Math.max(value + diagonalLength, 0);
            }
            return {
              r: rValue
            };
          }
        }
      };
      legacyAttributesNS["refX"] = legacyAttributesNS["ref-x"];
      legacyAttributesNS["refY"] = legacyAttributesNS["ref-y"];
      legacyAttributesNS["ref-x2"] = legacyAttributesNS["ref-x"];
      legacyAttributesNS["ref-y2"] = legacyAttributesNS["ref-y"];
      legacyAttributesNS["ref-width2"] = legacyAttributesNS["ref-width"];
      legacyAttributesNS["ref-height2"] = legacyAttributesNS["ref-height"];
      legacyAttributesNS["ref-r"] = legacyAttributesNS["ref-r-inscribed"];
      const props = {
        x: "x",
        y: "y",
        width: "w",
        height: "h",
        minimum: "s",
        maximum: "l",
        diagonal: "d"
      };
      const propsList = Object.keys(props).map((key) => props[key]).join("");
      const numberPattern = "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?";
      const findSpacesRegex = /\s/g;
      const parseFormulaRegExp = new RegExp(`^(${numberPattern}\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, "g");
      function throwInvalid(expression) {
        throw new Error(`Invalid calc() expression: ${expression}`);
      }
      function evalCalcFormula(formula, rect2) {
        const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ""));
        if (!match) throwInvalid(formula);
        parseFormulaRegExp.lastIndex = 0;
        const [, multiply, property2, divide, add] = match;
        const {
          x,
          y,
          width: width2,
          height: height2
        } = rect2;
        let value = 0;
        switch (property2) {
          case props.width: {
            value = width2;
            break;
          }
          case props.height: {
            value = height2;
            break;
          }
          case props.x: {
            value = x;
            break;
          }
          case props.y: {
            value = y;
            break;
          }
          case props.minimum: {
            value = Math.min(height2, width2);
            break;
          }
          case props.maximum: {
            value = Math.max(height2, width2);
            break;
          }
          case props.diagonal: {
            value = Math.sqrt(height2 * height2 + width2 * width2);
            break;
          }
        }
        if (multiply) {
          value *= parseFloat(multiply);
        }
        if (divide) {
          value /= parseFloat(divide.slice(1));
        }
        if (add) {
          value += evalAddExpression(add);
        }
        return value;
      }
      function evalAddExpression(addExpression) {
        if (!addExpression) return 0;
        const [sign] = addExpression;
        switch (sign) {
          case "+": {
            return parseFloat(addExpression.substr(1));
          }
          case "-": {
            return -parseFloat(addExpression.substr(1));
          }
        }
        return parseFloat(addExpression);
      }
      function isCalcExpression(value) {
        return typeof value === "string" && value.includes("calc");
      }
      const calcStart = "calc(";
      const calcStartOffset = calcStart.length;
      function evalCalcExpression(expression, rect2) {
        let value = expression;
        let startSearchIndex = 0;
        do {
          let calcIndex = value.indexOf(calcStart, startSearchIndex);
          if (calcIndex === -1) return value;
          let calcEndIndex = calcIndex + calcStartOffset;
          let brackets = 1;
          findClosingBracket: do {
            switch (value[calcEndIndex]) {
              case "(": {
                brackets++;
                break;
              }
              case ")": {
                brackets--;
                if (brackets === 0) break findClosingBracket;
                break;
              }
              case void 0: {
                throwInvalid(value);
              }
            }
            calcEndIndex++;
          } while (true);
          let expression2 = value.slice(calcIndex + calcStartOffset, calcEndIndex);
          if (isCalcExpression(expression2)) {
            expression2 = evalCalcExpression(expression2, rect2);
          }
          const calcValue = String(evalCalcFormula(expression2, rect2));
          value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);
          startSearchIndex = calcIndex + calcValue.length;
        } while (true);
      }
      function isTextInUse(_value, _node, attrs) {
        return attrs.text !== void 0;
      }
      const FONT_ATTRIBUTES = ["font-weight", "font-family", "font-size", "letter-spacing", "text-transform"];
      const textAttributesNS = {
        "line-height": {
          qualify: isTextInUse
        },
        "text-vertical-anchor": {
          qualify: isTextInUse
        },
        "text-path": {
          qualify: isTextInUse
        },
        "annotations": {
          qualify: isTextInUse
        },
        "eol": {
          qualify: isTextInUse
        },
        "display-empty": {
          qualify: isTextInUse
        },
        "text": {
          qualify: function(_text, _node, attrs) {
            const textWrap = attrs["text-wrap"];
            return !textWrap || !isPlainObject(textWrap);
          },
          unset: function(node) {
            node.textContent = "";
          },
          set: function(text, refBBox, node, attrs) {
            const cacheName = "joint-text";
            const cache2 = $.data.get(node, cacheName);
            const lineHeight = attrs["line-height"];
            const textVerticalAnchor = attrs["text-vertical-anchor"];
            const displayEmpty = attrs["display-empty"];
            const fontSize = attrs["font-size"];
            const annotations = attrs.annotations;
            const eol = attrs.eol;
            const x = attrs.x;
            let textPath = attrs["text-path"];
            const useNoBreakSpace = attrs["use-no-break-space"] === true;
            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize, useNoBreakSpace]);
            if (cache2 === void 0 || cache2 !== textHash) {
              if (fontSize) node.setAttribute("font-size", fontSize);
              if (isObject(textPath)) {
                const pathSelector = textPath.selector;
                if (typeof pathSelector === "string") {
                  const pathNode = this.findNode(pathSelector);
                  if (pathNode instanceof SVGPathElement) {
                    textPath = assign({
                      "xlink:href": "#" + pathNode.id
                    }, textPath);
                  }
                }
              }
              V2(node).text("" + text, {
                lineHeight,
                annotations,
                textPath,
                x,
                textVerticalAnchor,
                eol,
                displayEmpty,
                useNoBreakSpace
              });
              $.data.set(node, cacheName, textHash);
            }
          }
        },
        "text-wrap": {
          qualify: isPlainObject,
          set: function(value, refBBox, node, attrs) {
            var size = {};
            var width2 = value.width || 0;
            if (isPercentage(width2)) {
              size.width = refBBox.width * parseFloat(width2) / 100;
            } else if (isCalcExpression(width2)) {
              size.width = Number(evalCalcExpression(width2, refBBox));
            } else {
              if (value.width === null) {
                size.width = Infinity;
              } else if (width2 <= 0) {
                size.width = refBBox.width + width2;
              } else {
                size.width = width2;
              }
            }
            var height2 = value.height || 0;
            if (isPercentage(height2)) {
              size.height = refBBox.height * parseFloat(height2) / 100;
            } else if (isCalcExpression(height2)) {
              size.height = Number(evalCalcExpression(height2, refBBox));
            } else {
              if (value.height === null) {
              } else if (height2 <= 0) {
                size.height = refBBox.height + height2;
              } else {
                size.height = height2;
              }
            }
            var wrappedText;
            var text = value.text;
            if (text === void 0) text = attrs.text;
            if (text !== void 0) {
              const breakTextFn = value.breakText || breakText;
              const computedStyles = getComputedStyle(node);
              const wrapFontAttributes = {};
              for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {
                const name = FONT_ATTRIBUTES[i];
                if (name in attrs) {
                  node.setAttribute(name, attrs[name]);
                }
                wrapFontAttributes[name] = computedStyles[name];
              }
              wrapFontAttributes.lineHeight = attrs["line-height"];
              let svgDocument = this.paper.svg;
              if (!svgDocument.checkVisibility()) {
                svgDocument = null;
              }
              wrappedText = breakTextFn("" + text, size, wrapFontAttributes, {
                svgDocument,
                ellipsis: value.ellipsis,
                hyphen: value.hyphen,
                separator: value.separator,
                maxLineCount: value.maxLineCount,
                preserveSpaces: value.preserveSpaces
              });
            } else {
              wrappedText = "";
            }
            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);
          },
          // We expose the font attributes list to allow
          // the user to take other custom font attributes into account
          // when wrapping the text.
          FONT_ATTRIBUTES
        },
        "title": {
          qualify: function(title, node) {
            return node instanceof SVGElement;
          },
          unset: function(node) {
            $.data.remove(node, "joint-title");
            const titleNode = node.firstElementChild;
            if (titleNode) {
              titleNode.remove();
            }
          },
          set: function(title, refBBox, node) {
            var cacheName = "joint-title";
            var cache2 = $.data.get(node, cacheName);
            if (cache2 === void 0 || cache2 !== title) {
              $.data.set(node, cacheName, title);
              if (node.tagName === "title") {
                node.textContent = title;
                return;
              }
              var firstChild = node.firstElementChild;
              if (firstChild && firstChild.tagName === "title") {
                firstChild.textContent = title;
              } else {
                var titleNode = document.createElementNS(node.namespaceURI, "title");
                titleNode.textContent = title;
                node.insertBefore(titleNode, firstChild);
              }
            }
          }
        }
      };
      function atConnectionWrapper(method, opt) {
        var zeroVector = new Point(1, 0);
        return function(value) {
          var p, angle;
          var tangent = this[method](value);
          if (tangent) {
            angle = opt.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;
            p = tangent.start;
          } else {
            p = this.path.start;
            angle = 0;
          }
          if (angle === 0) return {
            transform: "translate(" + p.x + "," + p.y + ")"
          };
          return {
            transform: "translate(" + p.x + "," + p.y + ") rotate(" + angle + ")"
          };
        };
      }
      function isLinkView() {
        return this.model.isLink();
      }
      const connectionAttributesNS = {
        "connection": {
          qualify: isLinkView,
          unset: "d",
          set: function({
            stubs = 0
          }) {
            let d;
            if (isFinite(stubs) && stubs !== 0) {
              let offset2;
              if (stubs < 0) {
                offset2 = (this.getConnectionLength() + stubs) / 2;
              } else {
                offset2 = stubs;
              }
              const path2 = this.getConnection();
              const segmentSubdivisions = this.getConnectionSubdivisions();
              const sourceParts = path2.divideAtLength(offset2, {
                segmentSubdivisions
              });
              const targetParts = path2.divideAtLength(-offset2, {
                segmentSubdivisions
              });
              if (sourceParts && targetParts) {
                d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;
              }
            }
            return {
              d: d || this.getSerializedConnection()
            };
          }
        },
        "at-connection-length-keep-gradient": {
          qualify: isLinkView,
          unset: "transform",
          set: atConnectionWrapper("getTangentAtLength", {
            rotate: true
          })
        },
        "at-connection-length-ignore-gradient": {
          qualify: isLinkView,
          unset: "transform",
          set: atConnectionWrapper("getTangentAtLength", {
            rotate: false
          })
        },
        "at-connection-ratio-keep-gradient": {
          qualify: isLinkView,
          unset: "transform",
          set: atConnectionWrapper("getTangentAtRatio", {
            rotate: true
          })
        },
        "at-connection-ratio-ignore-gradient": {
          qualify: isLinkView,
          unset: "transform",
          set: atConnectionWrapper("getTangentAtRatio", {
            rotate: false
          })
        }
      };
      connectionAttributesNS["at-connection-length"] = connectionAttributesNS["at-connection-length-keep-gradient"];
      connectionAttributesNS["at-connection-ratio"] = connectionAttributesNS["at-connection-ratio-keep-gradient"];
      function shapeWrapper(shapeConstructor, opt) {
        var cacheName = "joint-shape";
        var resetOffset = opt && opt.resetOffset;
        return function(value, refBBox, node) {
          var cache2 = $.data.get(node, cacheName);
          if (!cache2 || cache2.value !== value) {
            var cachedShape = shapeConstructor(value);
            cache2 = {
              value,
              shape: cachedShape,
              shapeBBox: cachedShape.bbox()
            };
            $.data.set(node, cacheName, cache2);
          }
          var shape = cache2.shape.clone();
          var shapeBBox = cache2.shapeBBox.clone();
          var shapeOrigin = shapeBBox.origin();
          var refOrigin = refBBox.origin();
          shapeBBox.x = refOrigin.x;
          shapeBBox.y = refOrigin.y;
          var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);
          var sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;
          var sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;
          shape.scale(sx, sy, shapeOrigin);
          if (resetOffset) {
            shape.translate(-shapeOrigin.x, -shapeOrigin.y);
          }
          return shape;
        };
      }
      function dWrapper(opt) {
        function pathConstructor(value) {
          return new Path$1(V2.normalizePathData(value));
        }
        var shape = shapeWrapper(pathConstructor, opt);
        return function(value, refBBox, node) {
          var path2 = shape(value, refBBox, node);
          return {
            d: path2.serialize()
          };
        };
      }
      function pointsWrapper(opt) {
        var shape = shapeWrapper(Polyline$1, opt);
        return function(value, refBBox, node) {
          var polyline = shape(value, refBBox, node);
          return {
            points: polyline.serialize()
          };
        };
      }
      const shapeAttributesNS = {
        "ref-d-reset-offset": {
          unset: "d",
          set: dWrapper({
            resetOffset: true
          })
        },
        "ref-d-keep-offset": {
          unset: "d",
          set: dWrapper({
            resetOffset: false
          })
        },
        "ref-points-reset-offset": {
          unset: "points",
          set: pointsWrapper({
            resetOffset: true
          })
        },
        "ref-points-keep-offset": {
          unset: "points",
          set: pointsWrapper({
            resetOffset: false
          })
        }
      };
      shapeAttributesNS["ref-d"] = shapeAttributesNS["ref-d-reset-offset"];
      shapeAttributesNS["ref-points"] = shapeAttributesNS["ref-points-reset-offset"];
      function contextMarker(context) {
        var marker = {};
        var stroke2 = context.stroke;
        if (typeof stroke2 === "string") {
          marker["stroke"] = stroke2;
          marker["fill"] = stroke2;
        }
        var strokeOpacity = context["stroke-opacity"];
        if (strokeOpacity === void 0) strokeOpacity = context.opacity;
        if (strokeOpacity !== void 0) {
          marker["stroke-opacity"] = strokeOpacity;
          marker["fill-opacity"] = strokeOpacity;
        }
        return marker;
      }
      function setPaintURL(def) {
        const {
          paper
        } = this;
        const url = def.type === "pattern" ? paper.definePattern(def) : paper.defineGradient(def);
        return `url(#${url})`;
      }
      const defsAttributesNS = {
        "source-marker": {
          qualify: isPlainObject,
          unset: "marker-start",
          set: function(marker, refBBox, node, attrs) {
            marker = assign(contextMarker(attrs), marker);
            return {
              "marker-start": "url(#" + this.paper.defineMarker(marker) + ")"
            };
          }
        },
        "target-marker": {
          qualify: isPlainObject,
          unset: "marker-end",
          set: function(marker, refBBox, node, attrs) {
            marker = assign(contextMarker(attrs), {
              "transform": "rotate(180)"
            }, marker);
            return {
              "marker-end": "url(#" + this.paper.defineMarker(marker) + ")"
            };
          }
        },
        "vertex-marker": {
          qualify: isPlainObject,
          unset: "marker-mid",
          set: function(marker, refBBox, node, attrs) {
            marker = assign(contextMarker(attrs), marker);
            return {
              "marker-mid": "url(#" + this.paper.defineMarker(marker) + ")"
            };
          }
        },
        "fill": {
          qualify: isPlainObject,
          set: setPaintURL
        },
        "stroke": {
          qualify: isPlainObject,
          set: setPaintURL
        },
        "filter": {
          qualify: isPlainObject,
          set: function(filter2) {
            return "url(#" + this.paper.defineFilter(filter2) + ")";
          }
        }
      };
      function offsetWrapper(axis, dimension, corner) {
        return function(value, nodeBBox) {
          var delta;
          if (value === "middle") {
            delta = nodeBBox[dimension] / 2;
          } else if (value === corner) {
            delta = nodeBBox[dimension];
          } else if (isFinite(value)) {
            delta = value > -1 && value < 1 ? -nodeBBox[dimension] * value : -value;
          } else if (isPercentage(value)) {
            delta = nodeBBox[dimension] * parseFloat(value) / 100;
          } else {
            delta = 0;
          }
          var point2 = new Point();
          point2[axis] = -(nodeBBox[axis] + delta);
          return point2;
        };
      }
      const offsetAttributesNS = {
        // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.
        // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.
        "x-alignment": {
          offset: offsetWrapper("x", "width", "right")
        },
        // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.
        // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.
        "y-alignment": {
          offset: offsetWrapper("y", "height", "bottom")
        },
        "reset-offset": {
          offset: function(val, nodeBBox) {
            return val ? {
              x: -nodeBBox.x,
              y: -nodeBBox.y
            } : {
              x: 0,
              y: 0
            };
          }
        }
      };
      function setIfChangedWrapper(attribute) {
        return function setIfChanged(value, _, node) {
          const vel = V2(node);
          if (vel.attr(attribute) === value) return;
          vel.attr(attribute, value);
        };
      }
      const attributesNS = {
        "ref": {
          // We do not set `ref` attribute directly on an element.
          // The attribute itself does not qualify for relative positioning.
        },
        "href": {
          set: setIfChangedWrapper("href")
        },
        "xlink:href": {
          set: setIfChangedWrapper("xlink:href")
        },
        // `port` attribute contains the `id` of the port that the underlying magnet represents.
        "port": {
          set: function(port) {
            return port === null || port.id === void 0 ? port : port.id;
          }
        },
        // `style` attribute is special in the sense that it sets the CSS style of the sub-element.
        "style": {
          qualify: isPlainObject,
          set: function(styles, refBBox, node) {
            $(node).css(styles);
          }
        },
        "html": {
          unset: function(node) {
            $(node).empty();
          },
          set: function(html2, refBBox, node) {
            $(node).html(html2 + "");
          }
        },
        // Properties setter (set various properties on the node)
        props: props$1
      };
      assign(attributesNS, legacyAttributesNS);
      assign(attributesNS, textAttributesNS);
      assign(attributesNS, connectionAttributesNS);
      assign(attributesNS, shapeAttributesNS);
      assign(attributesNS, defsAttributesNS);
      assign(attributesNS, offsetAttributesNS);
      const attributes = attributesNS;
      const CELL_MARKER = Symbol("joint.cellMarker");
      const CELL_COLLECTION_MARKER = Symbol("joint.cellCollectionMarker");
      const GRAPH_LAYER_MARKER = Symbol("joint.graphLayerMarker");
      const GRAPH_LAYER_COLLECTION_MARKER = Symbol("joint.graphLayerCollectionMarker");
      const CELL_VIEW_MARKER = Symbol("joint.cellViewMarker");
      const LAYER_VIEW_MARKER = Symbol("joint.layerViewMarker");
      const GRAPH_LAYER_VIEW_MARKER = Symbol("joint.graphLayerViewMarker");
      const attributesMerger = function(a, b) {
        if (Array.isArray(a)) {
          return cloneDeep(b);
        }
      };
      function removeEmptyAttributes(obj) {
        for (const key in obj) {
          const objValue = obj[key];
          const isRealObject = isObject(objValue) && !Array.isArray(objValue);
          if (!isRealObject) continue;
          if (isEmpty(objValue)) {
            delete obj[key];
          }
        }
      }
      const Cell = Model.extend({
        cidPrefix: "c",
        // Default attributes are merged deeply instead of shallowly.
        _setDefaults: function(ctorAttributes, options) {
          let attributes2;
          const attributeDefaults = result(this, "defaults");
          if (attributeDefaults) {
            const customizer = options && options.mergeArrays === true ? false : config$3.cellDefaultsMergeStrategy || attributesMerger;
            attributes2 = merge({}, attributeDefaults, ctorAttributes, customizer);
          } else {
            attributes2 = ctorAttributes;
          }
          this.set(attributes2, options);
        },
        translate: function(dx, dy, opt) {
          throw new Error("Must define a translate() method.");
        },
        toJSON: function(opt) {
          const {
            ignoreDefaults,
            ignoreEmptyAttributes = false
          } = opt || {};
          const defaults2 = result(this.constructor.prototype, "defaults");
          if (ignoreDefaults === false) {
            const finalAttributes2 = cloneDeep(this.attributes);
            if (!ignoreEmptyAttributes) return finalAttributes2;
            removeEmptyAttributes(finalAttributes2);
            return finalAttributes2;
          }
          let defaultAttributes = {};
          let attributes2 = cloneDeep(this.attributes);
          if (ignoreDefaults === true) {
            defaultAttributes = defaults2;
          } else {
            const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ["attrs"];
            differentiateKeys.forEach((key) => {
              defaultAttributes[key] = defaults2[key] || {};
            });
          }
          const finalAttributes = objectDifference(attributes2, omit(defaultAttributes, "id", "type"), {
            maxDepth: 4
          });
          if (ignoreEmptyAttributes) {
            removeEmptyAttributes(finalAttributes);
          }
          return finalAttributes;
        },
        initialize: function(attributes2) {
          const idAttribute = this.getIdAttribute();
          if (!attributes2 || attributes2[idAttribute] === void 0) {
            this.set(idAttribute, this.generateId(), {
              silent: true
            });
          }
          this._transitionIds = {};
          this._scheduledTransitionIds = {};
          this.processPorts();
          this.on("change:attrs", this.processPorts, this);
        },
        getIdAttribute: function() {
          return this.idAttribute || "id";
        },
        generateId: function() {
          return uuid();
        },
        /**
         * @deprecated
         */
        processPorts: function() {
          var previousPorts = this.ports;
          var ports = {};
          forIn(this.get("attrs"), function(attrs, selector) {
            if (attrs && attrs.port) {
              if (attrs.port.id !== void 0) {
                ports[attrs.port.id] = attrs.port;
              } else {
                ports[attrs.port] = {
                  id: attrs.port
                };
              }
            }
          });
          var removedPorts = {};
          forIn(previousPorts, function(port, id2) {
            if (!ports[id2]) removedPorts[id2] = true;
          });
          if (this.graph && !isEmpty(removedPorts)) {
            var inboundLinks = this.graph.getConnectedLinks(this, {
              inbound: true
            });
            inboundLinks.forEach(function(link) {
              if (removedPorts[link.get("target").port]) link.remove();
            });
            var outboundLinks = this.graph.getConnectedLinks(this, {
              outbound: true
            });
            outboundLinks.forEach(function(link) {
              if (removedPorts[link.get("source").port]) link.remove();
            });
          }
          this.ports = ports;
        },
        remove: function(opt = {}) {
          const {
            graph,
            collection
          } = this;
          if (graph) {
            graph.removeCell(this, opt);
          } else {
            if (collection) collection.remove(this, opt);
          }
          return this;
        },
        toFront: function(opt) {
          const {
            graph
          } = this;
          if (graph) {
            opt = defaults(opt || {}, {
              foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
              cells = this.getEmbeddedCells({
                deep: true,
                breadthFirst: opt.breadthFirst !== false,
                sortSiblings: opt.foregroundEmbeds
              });
              cells.unshift(this);
            } else {
              cells = [this];
            }
            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, (cell) => cell.z());
            const layerId = graph.getCellLayerId(this);
            const maxZ = graph.maxZIndex(layerId);
            let z = maxZ - cells.length + 1;
            const layerCells = graph.getLayer(layerId).cellCollection.toArray();
            let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== layerCells.length - cells.length;
            if (!shouldUpdate) {
              shouldUpdate = sortedCells.some(function(cell, index2) {
                return cell.z() !== z + index2;
              });
            }
            if (shouldUpdate) {
              this.startBatch("to-front");
              z = z + cells.length;
              sortedCells.forEach(function(cell, index2) {
                cell.set("z", z + index2, opt);
              });
              this.stopBatch("to-front");
            }
          }
          return this;
        },
        toBack: function(opt) {
          const {
            graph
          } = this;
          if (graph) {
            opt = defaults(opt || {}, {
              foregroundEmbeds: true
            });
            let cells;
            if (opt.deep) {
              cells = this.getEmbeddedCells({
                deep: true,
                breadthFirst: opt.breadthFirst !== false,
                sortSiblings: opt.foregroundEmbeds
              });
              cells.unshift(this);
            } else {
              cells = [this];
            }
            const sortedCells = opt.foregroundEmbeds ? cells : sortBy(cells, (cell) => cell.z());
            const layerId = graph.getCellLayerId(this);
            let z = graph.minZIndex(layerId);
            const layerCells = graph.getLayer(layerId).cellCollection.toArray();
            let shouldUpdate = layerCells.indexOf(sortedCells[0]) !== 0;
            if (!shouldUpdate) {
              shouldUpdate = sortedCells.some(function(cell, index2) {
                return cell.z() !== z + index2;
              });
            }
            if (shouldUpdate) {
              this.startBatch("to-back");
              z -= cells.length;
              sortedCells.forEach(function(cell, index2) {
                cell.set("z", z + index2, opt);
              });
              this.stopBatch("to-back");
            }
          }
          return this;
        },
        parent: function(parent2, opt) {
          if (parent2 === void 0) return this.get("parent");
          return this.set("parent", parent2, opt);
        },
        embed: function(cell, opt = {}) {
          const cells = Array.isArray(cell) ? cell : [cell];
          if (!this.canEmbed(cells)) {
            throw new Error("Recursive embedding not allowed.");
          }
          if (opt.reparent) {
            const parents = uniq(cells.map((c) => c.getParentCell()));
            parents.forEach((parent2) => {
              if (!parent2) return;
              parent2._unembedCells(cells, opt);
            });
          } else if (cells.some((c) => c.isEmbedded() && this.id !== c.parent())) {
            throw new Error("Embedding of already embedded cells is not allowed.");
          }
          this._embedCells(cells, opt);
          return this;
        },
        unembed: function(cell, opt) {
          const cells = Array.isArray(cell) ? cell : [cell];
          this._unembedCells(cells, opt);
          return this;
        },
        canEmbed: function(cell) {
          const cells = Array.isArray(cell) ? cell : [cell];
          return cells.every((c) => this !== c && !this.isEmbeddedIn(c));
        },
        _embedCells: function(cells, opt) {
          const batchName = "embed";
          this.startBatch(batchName);
          const embeds = assign([], this.get("embeds"));
          cells.forEach((cell) => {
            embeds[cell.isLink() ? "unshift" : "push"](cell.id);
            cell.parent(this.id, opt);
          });
          this.set("embeds", uniq(embeds), opt);
          this.stopBatch(batchName);
        },
        _unembedCells: function(cells, opt) {
          const batchName = "unembed";
          this.startBatch(batchName);
          cells.forEach((cell) => cell.unset("parent", opt));
          this.set("embeds", without(this.get("embeds"), ...cells.map((cell) => cell.id)), opt);
          this.stopBatch(batchName);
        },
        getParentCell: function() {
          var parentId = this.parent();
          var graph = this.graph;
          return parentId && graph && graph.getCell(parentId) || null;
        },
        // Return an array of ancestor cells.
        // The array is ordered from the parent of the cell
        // to the most distant ancestor.
        getAncestors: function() {
          var ancestors = [];
          if (!this.graph) {
            return ancestors;
          }
          var parentCell = this.getParentCell();
          while (parentCell) {
            ancestors.push(parentCell);
            parentCell = parentCell.getParentCell();
          }
          return ancestors;
        },
        getEmbeddedCells: function(opt) {
          opt = opt || {};
          if (!this.graph) {
            return [];
          }
          if (opt.deep) {
            if (opt.breadthFirst) {
              return this._getEmbeddedCellsBfs(opt.sortSiblings);
            } else {
              return this._getEmbeddedCellsDfs(opt.sortSiblings);
            }
          }
          const embeddedIds = this.get("embeds");
          if (isEmpty(embeddedIds)) {
            return [];
          }
          let cells = embeddedIds.map(this.graph.getCell, this.graph);
          if (opt.sortSiblings) {
            cells = sortBy(cells, (cell) => cell.z());
          }
          return cells;
        },
        _getEmbeddedCellsBfs: function(sortSiblings) {
          const cells = [];
          const queue = [];
          queue.push(this);
          while (queue.length > 0) {
            const current = queue.shift();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
              sortSiblings
            });
            queue.push(...embeddedCells);
          }
          cells.shift();
          return cells;
        },
        _getEmbeddedCellsDfs: function(sortSiblings) {
          const cells = [];
          const stack = [];
          stack.push(this);
          while (stack.length > 0) {
            const current = stack.pop();
            cells.push(current);
            const embeddedCells = current.getEmbeddedCells({
              sortSiblings
            });
            for (let i = embeddedCells.length - 1; i >= 0; --i) {
              stack.push(embeddedCells[i]);
            }
          }
          cells.shift();
          return cells;
        },
        isEmbeddedIn: function(cell, opt) {
          var cellId = isString(cell) ? cell : cell.id;
          var parentId = this.parent();
          opt = assign({
            deep: true
          }, opt);
          if (this.graph && opt.deep) {
            while (parentId) {
              if (parentId === cellId) {
                return true;
              }
              parentId = this.graph.getCell(parentId).parent();
            }
            return false;
          } else {
            return parentId === cellId;
          }
        },
        // Whether or not the cell is embedded in any other cell.
        isEmbedded: function() {
          return !!this.parent();
        },
        // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).
        // Shallow cloning simply clones the cell and returns a new cell with different ID.
        // Deep cloning clones the cell and all its embedded cells recursively.
        clone: function(opt) {
          opt = opt || {};
          if (!opt.deep) {
            const clone2 = new this.constructor(this.attributes, {
              portLayoutNamespace: this.portLayoutNamespace,
              portLabelLayoutNamespace: this.portLabelLayoutNamespace
            });
            clone2.set(this.getIdAttribute(), this.generateId());
            clone2.unset("embeds");
            clone2.unset("parent");
            return clone2;
          } else {
            return toArray$1(cloneCells([this].concat(this.getEmbeddedCells({
              deep: true
            }))));
          }
        },
        // A convenient way to set nested properties.
        // This method merges the properties you'd like to set with the ones
        // stored in the cell and makes sure change events are properly triggered.
        // You can either set a nested property with one object
        // or use a property path.
        // The most simple use case is:
        // `cell.prop('name/first', 'John')` or
        // `cell.prop({ name: { first: 'John' } })`.
        // Nested arrays are supported too:
        // `cell.prop('series/0/data/0/degree', 50)` or
        // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.
        prop: function(props2, value, opt) {
          var delim = "/";
          var _isString = isString(props2);
          if (_isString || Array.isArray(props2)) {
            if (arguments.length > 1) {
              var path2;
              var pathArray;
              if (_isString) {
                path2 = props2;
                pathArray = path2.split("/");
              } else {
                path2 = props2.join(delim);
                pathArray = props2.slice();
              }
              var property2 = pathArray[0];
              var pathArrayLength = pathArray.length;
              const options2 = opt || {};
              options2.propertyPath = path2;
              options2.propertyValue = value;
              options2.propertyPathArray = pathArray;
              if (!("rewrite" in options2)) {
                options2.rewrite = false;
              }
              var update = {};
              var initializer = update;
              var prevProperty = property2;
              for (var i = 1; i < pathArrayLength; i++) {
                var pathItem = pathArray[i];
                var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);
                initializer = initializer[prevProperty] = isArrayIndex ? [] : {};
                prevProperty = pathItem;
              }
              update = setByPath(update, pathArray, value, "/");
              var baseAttributes = merge({}, this.attributes);
              options2.rewrite && unsetByPath(baseAttributes, path2, "/");
              var attributes2 = merge(baseAttributes, update, config$3.cellMergeStrategy);
              return this.set(property2, attributes2[property2], options2);
            } else {
              return getByPath(this.attributes, props2, delim);
            }
          }
          const options = value || {};
          options.propertyPath = null;
          options.propertyValue = props2;
          options.propertyPathArray = [];
          if (!("rewrite" in options)) {
            options.rewrite = false;
          }
          const changedAttributes = {};
          for (const key in props2) {
            const {
              changedValue
            } = merge(merge({}, {
              changedValue: this.attributes[key]
            }), {
              changedValue: props2[key]
            }, config$3.cellMergeStrategy);
            changedAttributes[key] = changedValue;
          }
          return this.set(changedAttributes, options);
        },
        // A convenient way to unset nested properties
        removeProp: function(path2, opt) {
          opt = opt || {};
          var pathArray = Array.isArray(path2) ? path2 : path2.split("/");
          var property2 = pathArray[0];
          if (property2 === "attrs") opt.dirty = true;
          if (pathArray.length === 1) {
            return this.unset(path2, opt);
          }
          var nestedPath = pathArray.slice(1);
          var propertyValue = this.get(property2);
          if (propertyValue === void 0 || propertyValue === null) return this;
          propertyValue = cloneDeep(propertyValue);
          unsetByPath(propertyValue, nestedPath, "/");
          return this.set(property2, propertyValue, opt);
        },
        // A convenient way to set nested attributes.
        attr: function(attrs, value, opt) {
          var args = Array.from(arguments);
          if (args.length === 0) {
            return this.get("attrs");
          }
          if (Array.isArray(attrs)) {
            args[0] = ["attrs"].concat(attrs);
          } else if (isString(attrs)) {
            args[0] = "attrs/" + attrs;
          } else {
            args[0] = {
              "attrs": attrs
            };
          }
          return this.prop.apply(this, args);
        },
        // A convenient way to unset nested attributes
        removeAttr: function(path2, opt) {
          if (Array.isArray(path2)) {
            return this.removeProp(["attrs"].concat(path2));
          }
          return this.removeProp("attrs/" + path2, opt);
        },
        transition: function(path2, value, opt, delim) {
          delim = delim || "/";
          var defaults2 = {
            duration: 100,
            delay: 10,
            timingFunction: timing.linear,
            valueFunction: interpolate.number
          };
          opt = assign(defaults2, opt);
          var firstFrameTime = 0;
          var interpolatingFunction;
          const transitionKey = Array.isArray(path2) ? path2.join(delim) : path2;
          var setter = (function(runtime) {
            var id2, progress, propertyValue;
            firstFrameTime = firstFrameTime || runtime;
            runtime -= firstFrameTime;
            progress = runtime / opt.duration;
            if (progress < 1) {
              this._transitionIds[transitionKey] = id2 = nextFrame(setter);
            } else {
              progress = 1;
              delete this._transitionIds[transitionKey];
            }
            propertyValue = interpolatingFunction(opt.timingFunction(progress));
            opt.transitionId = id2;
            this.prop(path2, propertyValue, opt);
            if (!id2) this.trigger("transition:end", this, transitionKey);
          }).bind(this);
          const {
            _scheduledTransitionIds
          } = this;
          let initialId;
          var initiator = (callback) => {
            if (_scheduledTransitionIds[transitionKey]) {
              _scheduledTransitionIds[transitionKey] = without(_scheduledTransitionIds[transitionKey], initialId);
              if (_scheduledTransitionIds[transitionKey].length === 0) {
                delete _scheduledTransitionIds[transitionKey];
              }
            }
            this.stopPendingTransitions(path2, delim);
            interpolatingFunction = opt.valueFunction(getByPath(this.attributes, path2, delim), value);
            this._transitionIds[transitionKey] = nextFrame(callback);
            this.trigger("transition:start", this, transitionKey);
          };
          initialId = setTimeout(initiator, opt.delay, setter);
          _scheduledTransitionIds[transitionKey] || (_scheduledTransitionIds[transitionKey] = []);
          _scheduledTransitionIds[transitionKey].push(initialId);
          return initialId;
        },
        getTransitions: function() {
          return union(Object.keys(this._transitionIds), Object.keys(this._scheduledTransitionIds));
        },
        stopScheduledTransitions: function(path2, delim = "/") {
          const {
            _scheduledTransitionIds = {}
          } = this;
          let transitions = Object.keys(_scheduledTransitionIds);
          if (path2) {
            const pathArray = Array.isArray(path2) ? path2.map((item) => String(item)) : path2.split(delim);
            transitions = transitions.filter((key) => {
              return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));
            });
          }
          transitions.forEach((key) => {
            const transitionIds = _scheduledTransitionIds[key];
            transitionIds.forEach((transitionId) => clearTimeout(transitionId));
            delete _scheduledTransitionIds[key];
          });
          return this;
        },
        stopPendingTransitions(path2, delim = "/") {
          const {
            _transitionIds = {}
          } = this;
          let transitions = Object.keys(_transitionIds);
          if (path2) {
            const pathArray = Array.isArray(path2) ? path2.map((item) => String(item)) : path2.split(delim);
            transitions = transitions.filter((key) => {
              return isEqual(pathArray, key.split(delim).slice(0, pathArray.length));
            });
          }
          transitions.forEach((key) => {
            const transitionId = _transitionIds[key];
            cancelFrame(transitionId);
            delete _transitionIds[key];
            this.trigger("transition:end", this, key);
          });
        },
        stopTransitions: function(path2, delim = "/") {
          this.stopScheduledTransitions(path2, delim);
          this.stopPendingTransitions(path2, delim);
          return this;
        },
        // A shortcut making it easy to create constructs like the following:
        // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.
        addTo: function(graph, opt) {
          graph.addCell(this, opt);
          return this;
        },
        // A shortcut for an equivalent call: `paper.findViewByModel(cell)`
        // making it easy to create constructs like the following:
        // `cell.findView(paper).highlight()`
        findView: function(paper) {
          return paper.findViewByModel(this);
        },
        isElement: function() {
          return false;
        },
        isLink: function() {
          return false;
        },
        startBatch: function(name, opt) {
          if (this.graph) {
            this.graph.startBatch(name, assign({}, opt, {
              cell: this
            }));
          }
          return this;
        },
        stopBatch: function(name, opt) {
          if (this.graph) {
            this.graph.stopBatch(name, assign({}, opt, {
              cell: this
            }));
          }
          return this;
        },
        getChangeFlag: function(attributes2) {
          var flag = 0;
          if (!attributes2) return flag;
          for (var key in attributes2) {
            if (!attributes2.hasOwnProperty(key) || !this.hasChanged(key)) continue;
            flag |= attributes2[key];
          }
          return flag;
        },
        angle: function() {
          return 0;
        },
        position: function() {
          return new Point(0, 0);
        },
        z: function() {
          return this.get("z") || 0;
        },
        getPointFromConnectedLink: function() {
          return new Point();
        },
        getBBox: function() {
          return new Rect(0, 0, 0, 0);
        },
        getCenter: function() {
          return this.getBBox().center();
        },
        getPointRotatedAroundCenter(angle, x, y) {
          const point2 = new Point(x, y);
          if (angle) point2.rotate(this.getCenter(), angle);
          return point2;
        },
        getAbsolutePointFromRelative(x, y) {
          return this.getPointRotatedAroundCenter(
            -this.angle(),
            // Transform the relative position to absolute
            this.position().offset(x, y)
          );
        },
        getRelativePointFromAbsolute(x, y) {
          return this.getPointRotatedAroundCenter(this.angle(), x, y).difference(this.position());
        },
        layer: function(layerId, opt) {
          const layerAttribute = config$3.layerAttribute;
          if (layerId === void 0) {
            return this.get(layerAttribute) || null;
          }
          if (layerId === null) {
            return this.unset(layerAttribute, opt);
          }
          if (!isString(layerId)) {
            throw new Error("dia.Cell: Layer id must be a string.");
          }
          return this.set(layerAttribute, layerId, opt);
        }
      }, {
        getAttributeDefinition: function(attrName) {
          const defNS = this.attributes;
          const globalDefNS = attributes;
          const definition = defNS && defNS[attrName] || globalDefNS[attrName];
          return definition !== void 0 ? definition : null;
        },
        define: function(type, defaults2, protoProps, staticProps) {
          protoProps = assign({
            defaults: defaultsDeep({
              type
            }, defaults2, this.prototype.defaults)
          }, protoProps);
          var Cell2 = this.extend(protoProps, staticProps);
          if (typeof joint !== "undefined" && has(joint, "shapes")) {
            setByPath(joint.shapes, type, Cell2, ".");
          }
          return Cell2;
        }
      });
      Object.defineProperty(Cell.prototype, CELL_MARKER, {
        value: true
      });
      const wrapWith = function(object, methods2, wrapper) {
        if (isString(wrapper)) {
          if (!wrappers[wrapper]) {
            throw new Error('Unknown wrapper: "' + wrapper + '"');
          }
          wrapper = wrappers[wrapper];
        }
        if (!isFunction(wrapper)) {
          throw new Error("Wrapper must be a function.");
        }
        toArray$1(methods2).forEach(function(method) {
          object[method] = wrapper(object[method]);
        });
      };
      const wrappers = {
        cells: function(fn2) {
          return function() {
            var args = Array.from(arguments);
            var n = args.length;
            var cells = n > 0 && args[0] || [];
            var opt = n > 1 && args[n - 1] || {};
            if (!Array.isArray(cells)) {
              if (opt instanceof Cell) {
                cells = args;
              } else if (cells instanceof Cell) {
                if (args.length > 1) {
                  args.pop();
                }
                cells = args;
              }
            }
            if (opt instanceof Cell) {
              opt = {};
            }
            return fn2.call(this, cells, opt);
          };
        }
      };
      function svg(strings, ...expressions) {
        const svgParts = [];
        strings.forEach((part, index2) => {
          svgParts.push(part);
          if (index2 in expressions) {
            svgParts.push(expressions[index2]);
          }
        });
        const markup = parseFromSVGString(svgParts.join(""));
        return markup;
      }
      function parseFromSVGString(str) {
        const parser = new DOMParser();
        const markupString = `<svg>${str.trim()}</svg>`;
        const xmldocument = parser.parseFromString(markupString.replace(/@/g, ""), "application/xml");
        if (xmldocument.getElementsByTagName("parsererror")[0]) {
          throw new Error("Invalid SVG markup");
        }
        const document2 = parser.parseFromString(markupString, "text/html");
        const svg2 = document2.querySelector("svg");
        return build(svg2);
      }
      function buildNode(node) {
        const markupNode = {};
        const {
          tagName,
          attributes: attributes2,
          namespaceURI,
          style,
          childNodes
        } = node;
        markupNode.namespaceURI = namespaceURI;
        markupNode.tagName = namespaceURI === V2.namespace.xhtml ? tagName.toLowerCase() : tagName;
        const stylesObject = {};
        for (var i = style.length; i--; ) {
          var nameString = style[i];
          stylesObject[nameString] = style.getPropertyValue(nameString);
        }
        markupNode.style = stylesObject;
        const selectorAttribute = attributes2.getNamedItem("@selector");
        if (selectorAttribute) {
          markupNode.selector = selectorAttribute.value;
          attributes2.removeNamedItem("@selector");
        }
        const groupSelectorAttribute = attributes2.getNamedItem("@group-selector");
        if (groupSelectorAttribute) {
          const groupSelectors = groupSelectorAttribute.value.split(",");
          markupNode.groupSelector = groupSelectors.map((s) => s.trim());
          attributes2.removeNamedItem("@group-selector");
        }
        const className2 = attributes2.getNamedItem("class");
        if (className2) {
          markupNode.className = className2.value;
        }
        const children2 = [];
        childNodes.forEach((node2) => {
          switch (node2.nodeType) {
            case Node.TEXT_NODE: {
              const trimmedText = node2.data.replace(/\s\s+/g, " ");
              if (trimmedText.trim()) {
                children2.push(trimmedText);
              }
              break;
            }
            case Node.ELEMENT_NODE: {
              children2.push(buildNode(node2));
              break;
            }
            default:
              break;
          }
        });
        if (children2.length) {
          markupNode.children = children2;
        }
        const nodeAttrs = {};
        Array.from(attributes2).forEach((nodeAttribute) => {
          const {
            name,
            value
          } = nodeAttribute;
          nodeAttrs[name] = value;
        });
        if (Object.keys(nodeAttrs).length > 0) {
          markupNode.attributes = nodeAttrs;
        }
        return markupNode;
      }
      function build(root) {
        const markup = [];
        Array.from(root.children).forEach((node) => {
          markup.push(buildNode(node));
        });
        return markup;
      }
      const Positions = {
        TOP: "top",
        RIGHT: "right",
        BOTTOM: "bottom",
        LEFT: "left",
        TOP_LEFT: "top-left",
        TOP_RIGHT: "top-right",
        BOTTOM_LEFT: "bottom-left",
        BOTTOM_RIGHT: "bottom-right",
        CENTER: "center"
      };
      function getRectPoint(rect2, position2) {
        const r = new Rect(rect2);
        switch (position2) {
          case void 0:
            throw new Error("Position required");
          // Middle Points
          case Positions.LEFT:
          case "leftMiddle":
            return r.leftMiddle();
          case Positions.RIGHT:
          case "rightMiddle":
            return r.rightMiddle();
          case Positions.TOP:
          case "topMiddle":
            return r.topMiddle();
          case Positions.BOTTOM:
          case "bottomMiddle":
            return r.bottomMiddle();
          // Corners
          case Positions.TOP_LEFT:
          case "topLeft":
          case "origin":
            return r.topLeft();
          case Positions.TOP_RIGHT:
          case "topRight":
            return r.topRight();
          case Positions.BOTTOM_LEFT:
          case "bottomLeft":
            return r.bottomLeft();
          case Positions.BOTTOM_RIGHT:
          case "bottomRight":
          case "corner":
            return r.bottomRight();
          // Center
          case Positions.CENTER:
            return r.center();
          // TODO: calc(), percentage etc.
          default:
            throw new Error(`Unknown position: ${position2}`);
        }
      }
      var index$6 = {
        __proto__: null,
        addClassNamePrefix,
        assign,
        bindAll,
        breakText,
        camelCase,
        cancelFrame,
        cap,
        clone: clone$1,
        cloneCells,
        cloneDeep,
        dataUriToBlob,
        debounce,
        deepMixin,
        deepSupplement,
        defaults,
        defaultsDeep,
        difference,
        downloadBlob,
        downloadDataUri,
        evalCalcExpression,
        evalCalcFormula,
        filter,
        flattenDeep,
        flattenObject,
        forIn,
        format: format$1,
        getByPath,
        getElementBBox,
        getRectPoint,
        groupBy,
        guid,
        has,
        hashCode,
        imageToDataUri,
        interpolate,
        intersection,
        invoke,
        invokeProperty,
        isBoolean,
        isCalcExpression,
        isEmpty,
        isEqual,
        isFunction,
        isNumber,
        isObject,
        isPercentage,
        isPlainObject,
        isString,
        merge,
        mixin,
        nextFrame,
        noop,
        normalizeEvent,
        normalizeSides,
        normalizeWheel,
        objectDifference,
        omit,
        parseCssNumeric,
        parseDOMJSON,
        pick,
        removeClassNamePrefix,
        result,
        sanitizeHTML,
        setAttributesBySelector,
        setByPath,
        sortBy,
        sortElements,
        sortedIndex,
        supplement,
        svg,
        template,
        timing,
        toArray: toArray$1,
        toKebabCase,
        toggleFullScreen,
        union,
        uniq,
        uniqueId,
        unsetByPath,
        uuid,
        without,
        wrapWith,
        wrappers
      };
      function parseCoordinate(coordinate, dimension, bbox2, value) {
        if (isPercentage(value)) {
          return parseFloat(value) / 100 * bbox2[dimension];
        }
        if (isCalcExpression(value)) {
          return Number(evalCalcExpression(value, bbox2));
        }
        if (typeof value === "string") {
          const num = Number(value);
          if (isNaN(num)) {
            throw new TypeError(`Cannot convert port coordinate ${coordinate}: "${value}" to a number`);
          }
          return num;
        }
        return value;
      }
      function portTransformAttrs(point2, angle, opt) {
        var trans = point2.toJSON();
        trans.angle = angle || 0;
        return defaults({}, opt, trans);
      }
      function lineLayout(ports, p1, p2, elBBox) {
        return ports.map(function(port, index2, ports2) {
          var p = this.pointAt((index2 + 0.5) / ports2.length);
          if (port.dx || port.dy) {
            p.offset(port.dx || 0, port.dy || 0);
          }
          return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));
        }, line$1(p1, p2));
      }
      function ellipseLayout(ports, elBBox, startAngle, stepFn) {
        var center2 = elBBox.center();
        var ratio = elBBox.width / elBBox.height;
        var p1 = elBBox.topMiddle();
        var ellipse2 = Ellipse$1.fromRect(elBBox);
        return ports.map(function(port, index2, ports2) {
          var angle = startAngle + stepFn(index2, ports2.length);
          var p2 = p1.clone().rotate(center2, -angle).scale(ratio, 1, center2);
          var theta = port.compensateRotation ? -ellipse2.tangentTheta(p2) : 0;
          if (port.dx || port.dy) {
            p2.offset(port.dx || 0, port.dy || 0);
          }
          if (port.dr) {
            p2.move(center2, port.dr);
          }
          return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));
        });
      }
      function argTransform(bbox2, args) {
        let {
          x,
          y,
          angle
        } = args;
        return {
          x: parseCoordinate("x", "width", bbox2, x),
          y: parseCoordinate("y", "height", bbox2, y),
          angle
        };
      }
      function argPoint(bbox2, args) {
        const {
          x,
          y
        } = argTransform(bbox2, args);
        return new Point(x || 0, y || 0);
      }
      const absolute = function(ports, elBBox, opt) {
        return ports.map((port) => {
          const transformation = argPoint(elBBox, port).round().toJSON();
          transformation.angle = port.angle || 0;
          return transformation;
        });
      };
      const fn = function(ports, elBBox, opt) {
        return opt.fn(ports, elBBox, opt);
      };
      const line = function(ports, elBBox, opt) {
        var start = argPoint(elBBox, opt.start || elBBox.origin());
        var end = argPoint(elBBox, opt.end || elBBox.corner());
        return lineLayout(ports, start, end, elBBox);
      };
      const left$2 = function(ports, elBBox, opt) {
        return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);
      };
      const right$2 = function(ports, elBBox, opt) {
        return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);
      };
      const top$2 = function(ports, elBBox, opt) {
        return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);
      };
      const bottom$2 = function(ports, elBBox, opt) {
        return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);
      };
      const ellipseSpread = function(ports, elBBox, opt) {
        var startAngle = opt.startAngle || 0;
        var stepAngle = opt.step || 360 / ports.length;
        return ellipseLayout(ports, elBBox, startAngle, function(index2) {
          return index2 * stepAngle;
        });
      };
      const ellipse = function(ports, elBBox, opt) {
        var startAngle = opt.startAngle || 0;
        var stepAngle = opt.step || 20;
        return ellipseLayout(ports, elBBox, startAngle, function(index2, count) {
          return (index2 + 0.5 - count / 2) * stepAngle;
        });
      };
      var Port = {
        __proto__: null,
        absolute,
        bottom: bottom$2,
        ellipse,
        ellipseSpread,
        fn,
        left: left$2,
        line,
        right: right$2,
        top: top$2
      };
      function labelAttributes(opt1, opt2) {
        return defaultsDeep({}, opt1, opt2, {
          x: 0,
          y: 0,
          angle: 0,
          attrs: {}
        });
      }
      function getBBoxAngles(elBBox) {
        var center2 = elBBox.center();
        var tl = center2.theta(elBBox.origin());
        var bl = center2.theta(elBBox.bottomLeft());
        var br = center2.theta(elBBox.corner());
        var tr = center2.theta(elBBox.topRight());
        return [tl, tr, br, bl];
      }
      function outsideLayout(portPosition, elBBox, autoOrient, opt) {
        opt = defaults({}, opt, {
          offset: 15
        });
        var angle = elBBox.center().theta(portPosition);
        var tx, ty, y, textAnchor;
        var offset2 = opt.offset;
        var orientAngle = 0;
        const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
        if (angle < bottomLeftAngle || angle > bottomRightAngle) {
          y = ".3em";
          tx = offset2;
          ty = 0;
          textAnchor = "start";
        } else if (angle < topLeftAngle) {
          tx = 0;
          ty = -offset2;
          if (autoOrient) {
            orientAngle = -90;
            textAnchor = "start";
            y = ".3em";
          } else {
            textAnchor = "middle";
            y = "0";
          }
        } else if (angle < topRightAngle) {
          y = ".3em";
          tx = -offset2;
          ty = 0;
          textAnchor = "end";
        } else {
          tx = 0;
          ty = offset2;
          if (autoOrient) {
            orientAngle = 90;
            textAnchor = "start";
            y = ".3em";
          } else {
            textAnchor = "middle";
            y = ".6em";
          }
        }
        var round2 = Math.round;
        return labelAttributes(opt, {
          x: round2(tx),
          y: round2(ty),
          angle: orientAngle,
          attrs: {
            labelText: {
              y,
              textAnchor
            }
          }
        });
      }
      function insideLayout(portPosition, elBBox, autoOrient, opt) {
        opt = defaults({}, opt, {
          offset: 15
        });
        var angle = elBBox.center().theta(portPosition);
        var tx, ty, y, textAnchor;
        var offset2 = opt.offset;
        var orientAngle = 0;
        const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);
        if (angle < bottomLeftAngle || angle > bottomRightAngle) {
          y = ".3em";
          tx = -offset2;
          ty = 0;
          textAnchor = "end";
        } else if (angle < topLeftAngle) {
          tx = 0;
          ty = offset2;
          if (autoOrient) {
            orientAngle = 90;
            textAnchor = "start";
            y = ".3em";
          } else {
            textAnchor = "middle";
            y = ".6em";
          }
        } else if (angle < topRightAngle) {
          y = ".3em";
          tx = offset2;
          ty = 0;
          textAnchor = "start";
        } else {
          tx = 0;
          ty = -offset2;
          if (autoOrient) {
            orientAngle = -90;
            textAnchor = "start";
            y = ".3em";
          } else {
            textAnchor = "middle";
            y = "0";
          }
        }
        var round2 = Math.round;
        return labelAttributes(opt, {
          x: round2(tx),
          y: round2(ty),
          angle: orientAngle,
          attrs: {
            labelText: {
              y,
              textAnchor
            }
          }
        });
      }
      function radialLayout(portCenterOffset, autoOrient, opt) {
        opt = defaults({}, opt, {
          offset: 20
        });
        var origin = point(0, 0);
        var angle = -portCenterOffset.theta(origin);
        var orientAngle = angle;
        var offset2 = portCenterOffset.clone().move(origin, opt.offset).difference(portCenterOffset).round();
        var y = ".3em";
        var textAnchor;
        if ((angle + 90) % 180 === 0) {
          textAnchor = autoOrient ? "end" : "middle";
          if (!autoOrient && angle === -270) {
            y = "0em";
          }
        } else if (angle > -270 && angle < -90) {
          textAnchor = "start";
          orientAngle = angle - 180;
        } else {
          textAnchor = "end";
        }
        var round2 = Math.round;
        return labelAttributes(opt, {
          x: round2(offset2.x),
          y: round2(offset2.y),
          angle: autoOrient ? orientAngle : 0,
          attrs: {
            labelText: {
              y,
              textAnchor
            }
          }
        });
      }
      const manual = function(portPosition, elBBox, opt) {
        return labelAttributes(opt);
      };
      const left$1 = function(portPosition, elBBox, opt) {
        return labelAttributes(opt, {
          x: -15,
          attrs: {
            labelText: {
              y: ".3em",
              textAnchor: "end"
            }
          }
        });
      };
      const right$1 = function(portPosition, elBBox, opt) {
        return labelAttributes(opt, {
          x: 15,
          attrs: {
            labelText: {
              y: ".3em",
              textAnchor: "start"
            }
          }
        });
      };
      const top$1 = function(portPosition, elBBox, opt) {
        return labelAttributes(opt, {
          y: -15,
          attrs: {
            labelText: {
              y: "0",
              textAnchor: "middle"
            }
          }
        });
      };
      const bottom$1 = function(portPosition, elBBox, opt) {
        return labelAttributes(opt, {
          y: 15,
          attrs: {
            labelText: {
              y: ".6em",
              textAnchor: "middle"
            }
          }
        });
      };
      const outsideOriented = function(portPosition, elBBox, opt) {
        return outsideLayout(portPosition, elBBox, true, opt);
      };
      const outside = function(portPosition, elBBox, opt) {
        return outsideLayout(portPosition, elBBox, false, opt);
      };
      const insideOriented = function(portPosition, elBBox, opt) {
        return insideLayout(portPosition, elBBox, true, opt);
      };
      const inside = function(portPosition, elBBox, opt) {
        return insideLayout(portPosition, elBBox, false, opt);
      };
      const radial = function(portPosition, elBBox, opt) {
        return radialLayout(portPosition.difference(elBBox.center()), false, opt);
      };
      const radialOriented = function(portPosition, elBBox, opt) {
        return radialLayout(portPosition.difference(elBBox.center()), true, opt);
      };
      var PortLabel = {
        __proto__: null,
        bottom: bottom$1,
        inside,
        insideOriented,
        left: left$1,
        manual,
        outside,
        outsideOriented,
        radial,
        radialOriented,
        right: right$1,
        top: top$1
      };
      const DEFAULT_PORT_POSITION_NAME = "left";
      const DEFAULT_ABSOLUTE_PORT_POSITION_NAME = "absolute";
      const DEFAULT_PORT_LABEL_POSITION_NAME = "left";
      const PortData = function(model) {
        const {
          portLayoutNamespace = Port,
          portLabelLayoutNamespace = PortLabel
        } = model;
        const clonedData = cloneDeep(model.get("ports")) || {};
        this.ports = [];
        this.portsMap = {};
        this.groups = {};
        this.portLayoutNamespace = portLayoutNamespace;
        this.portLabelLayoutNamespace = portLabelLayoutNamespace;
        this.metrics = {};
        this.metricsKey = null;
        this._init(clonedData);
      };
      PortData.prototype = {
        hasPort: function(id2) {
          return id2 in this.portsMap;
        },
        getPort: function(id2) {
          const port = this.portsMap[id2];
          if (port) return port;
          throw new Error("Element: unable to find port with id " + id2);
        },
        getPorts: function() {
          return this.ports;
        },
        getGroup: function(name) {
          return this.groups[name] || {};
        },
        getPortsByGroup: function(groupName) {
          return this.ports.filter(function(port) {
            return port.group === groupName;
          });
        },
        // Calculate SVG transformations based on evaluated group + port data
        // NOTE: This function is also called for ports without a group (groupName = undefined)
        getGroupPortsMetrics: function(groupName, rect2) {
          const {
            x = 0,
            y = 0,
            width: width2 = 0,
            height: height2 = 0
          } = rect2;
          const metricsKey = `${x}:${y}:${width2}:${height2}`;
          if (this.metricsKey !== metricsKey) {
            this.metrics = {};
            this.metricsKey = metricsKey;
          }
          let groupPortsMetrics = this.metrics[groupName];
          if (groupPortsMetrics) {
            return groupPortsMetrics;
          }
          groupPortsMetrics = this.resolveGroupPortsMetrics(groupName, new Rect(x, y, width2, height2));
          this.metrics[groupName] = groupPortsMetrics;
          return groupPortsMetrics;
        },
        resolveGroupPortsMetrics: function(groupName, elBBox) {
          const isNoGroup = groupName === void 0;
          const group = this.getGroup(groupName);
          const ports = this.getPortsByGroup(groupName);
          const portsArgs = ports.map(function(port) {
            return port && port.position && port.position.args;
          });
          let groupPortTransformations;
          if (isNoGroup) {
            const noGroup = this._evaluateGroup({});
            groupPortTransformations = this._getGroupPortTransformations(noGroup, portsArgs, elBBox);
          } else {
            groupPortTransformations = this._getGroupPortTransformations(group, portsArgs, elBBox);
          }
          let accumulator = {
            ports,
            result: {}
          };
          toArray$1(groupPortTransformations).reduce((res, portTransformation, index2) => {
            const port = res.ports[index2];
            const portId = port.id;
            res.result[portId] = {
              index: index2,
              portId,
              portTransformation,
              labelTransformation: this._getPortLabelTransformation(port, Point(portTransformation), elBBox),
              portAttrs: port.attrs,
              portSize: port.size,
              labelSize: port.label.size
            };
            return res;
          }, accumulator);
          return accumulator.result;
        },
        _getGroupPortTransformations: function(group, portsArgs, elBBox) {
          const groupPosition = group.position || {};
          const groupPositionArgs = groupPosition.args || {};
          const groupPositionLayoutCallback = groupPosition.layoutCallback;
          return groupPositionLayoutCallback(portsArgs, elBBox, groupPositionArgs);
        },
        _getPortLabelTransformation: function(port, portPosition, elBBox) {
          const portLabelPosition = port.label.position || {};
          const portLabelPositionArgs = portLabelPosition.args || {};
          const portLabelPositionLayoutCallback = portLabelPosition.layoutCallback;
          if (portLabelPositionLayoutCallback) {
            return portLabelPositionLayoutCallback(portPosition, elBBox, portLabelPositionArgs);
          }
          return null;
        },
        _init: function(data2) {
          if (isObject(data2.groups)) {
            var groups = Object.keys(data2.groups);
            for (var i = 0, n = groups.length; i < n; i++) {
              var key = groups[i];
              this.groups[key] = this._evaluateGroup(data2.groups[key]);
            }
          }
          var ports = toArray$1(data2.items);
          for (var j = 0, m = ports.length; j < m; j++) {
            const resolvedPort = this._evaluatePort(ports[j]);
            this.ports.push(resolvedPort);
            this.portsMap[resolvedPort.id] = resolvedPort;
          }
        },
        _evaluateGroup: function(group) {
          return merge({}, group, {
            position: this._evaluateGroupPositionProperty(group),
            label: this._evaluateGroupLabelProperty(group)
          });
        },
        _evaluateGroupPositionProperty: function(group) {
          const namespace = this.portLayoutNamespace;
          const groupPosition = group.position;
          if (groupPosition === void 0) {
            const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, "Default port group");
            return {
              layoutCallback
            };
          } else if (isFunction(groupPosition)) {
            return {
              layoutCallback: groupPosition
            };
          } else if (isObject(groupPosition)) {
            if (groupPosition.name) {
              const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition.name, "Provided port group");
              return {
                layoutCallback,
                args: groupPosition.args
              };
            } else {
              const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_POSITION_NAME, "Default port group");
              return {
                layoutCallback,
                args: groupPosition.args
              };
            }
          } else if (isString(groupPosition)) {
            const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupPosition, "Provided port group");
            return {
              layoutCallback
            };
          } else if (Array.isArray(groupPosition)) {
            const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_ABSOLUTE_PORT_POSITION_NAME, "Default absolute port group");
            return {
              layoutCallback,
              args: {
                x: groupPosition[0],
                y: groupPosition[1]
              }
            };
          } else {
            throw new Error("dia.Element: Provided port group position value has an invalid type.");
          }
        },
        _evaluateGroupLabelProperty: function(group) {
          const groupLabel = group.label;
          if (!groupLabel) {
            return {
              position: this._evaluateGroupLabelPositionProperty({})
            };
          }
          return merge({}, groupLabel, {
            position: this._evaluateGroupLabelPositionProperty(groupLabel)
          });
        },
        _evaluateGroupLabelPositionProperty: function(groupLabel) {
          const namespace = this.portLabelLayoutNamespace;
          const groupLabelPosition = groupLabel.position;
          if (groupLabelPosition === void 0) {
            const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, "Default port group label");
            return {
              layoutCallback
            };
          } else if (isFunction(groupLabelPosition)) {
            return {
              layoutCallback: groupLabelPosition
            };
          } else if (isObject(groupLabelPosition)) {
            if (groupLabelPosition.name) {
              const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, groupLabelPosition.name, "Provided port group label");
              return {
                layoutCallback,
                args: groupLabelPosition.args
              };
            } else {
              const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, DEFAULT_PORT_LABEL_POSITION_NAME, "Default port group label");
              return {
                layoutCallback,
                args: groupLabelPosition.args
              };
            }
          } else {
            throw new Error("dia.Element: Provided port group label position value has an invalid type.");
          }
        },
        _evaluatePort: function(port) {
          const group = this.getGroup(port.group);
          const evaluated = assign({}, port);
          evaluated.markup = evaluated.markup || group.markup;
          evaluated.attrs = merge({}, group.attrs, evaluated.attrs);
          evaluated.position = this._evaluatePortPositionProperty(group, evaluated);
          evaluated.label = this._evaluatePortLabelProperty(group, evaluated);
          evaluated.z = this._evaluatePortZProperty(group, evaluated);
          evaluated.size = assign({}, group.size, evaluated.size);
          return evaluated;
        },
        _evaluatePortPositionProperty: function(group, port) {
          return {
            args: merge(
              {},
              // NOTE: `x != null` is equivalent to `x !== null && x !== undefined`.
              group.position != null ? group.position.args : {},
              // Port can overwrite `group.position.args` via `port.position.args` or `port.args`.
              // TODO: Remove `port.args` backwards compatibility.
              port.position != null && port.position.args != null ? port.position.args : port.args
            )
          };
        },
        _evaluatePortLabelProperty: function(group, port) {
          const groupLabel = group.label;
          const portLabel = port.label;
          if (!portLabel) {
            return assign({}, groupLabel);
          }
          return merge({}, groupLabel, merge({}, portLabel, {
            position: this._evaluatePortLabelPositionProperty(portLabel)
          }));
        },
        _evaluatePortLabelPositionProperty: function(portLabel) {
          const namespace = this.portLabelLayoutNamespace;
          const portLabelPosition = portLabel.position;
          if (portLabelPosition === void 0) {
            return {};
          } else if (isFunction(portLabelPosition)) {
            return {
              layoutCallback: portLabelPosition
            };
          } else if (isObject(portLabelPosition)) {
            if (portLabelPosition.name) {
              const layoutCallback = this._resolveLayoutCallbackOrThrow(namespace, portLabelPosition.name, "Provided port label");
              return {
                layoutCallback,
                args: portLabelPosition.args
              };
            } else {
              return {
                args: portLabelPosition.args
              };
            }
          } else {
            throw new Error("dia.Element: Provided port label position value has an invalid type.");
          }
        },
        _evaluatePortZProperty: function(group, port) {
          if (isNumber(port.z)) {
            return port.z;
          }
          if (isNumber(group.z) || group.z === "auto") {
            return group.z;
          }
          return "auto";
        },
        _resolveLayoutCallbackOrThrow: function(namespace, name, errorSubstring) {
          const layoutCallback = namespace[name];
          if (!layoutCallback) {
            throw new Error(`dia.Element: ${errorSubstring} layout name is not recognized.`);
          }
          return layoutCallback;
        }
      };
      const elementPortPrototype = {
        _initializePorts: function(options) {
          if (options) {
            if (options.portLayoutNamespace) {
              this.portLayoutNamespace = options.portLayoutNamespace;
            }
            if (options.portLabelLayoutNamespace) {
              this.portLabelLayoutNamespace = options.portLabelLayoutNamespace;
            }
          }
          this._createPortData();
          this.on("change:ports", function() {
            this._processRemovedPort();
            this._createPortData();
          }, this);
        },
        /**
         * remove links tied wiht just removed element
         * @private
         */
        _processRemovedPort: function() {
          var current = this.get("ports") || {};
          var currentItemsMap = {};
          toArray$1(current.items).forEach(function(item) {
            currentItemsMap[item.id] = true;
          });
          var previous = this.previous("ports") || {};
          var removed = {};
          toArray$1(previous.items).forEach(function(item) {
            if (!currentItemsMap[item.id]) {
              removed[item.id] = true;
            }
          });
          var graph = this.graph;
          if (graph && !isEmpty(removed)) {
            var inboundLinks = graph.getConnectedLinks(this, {
              inbound: true
            });
            inboundLinks.forEach(function(link) {
              if (removed[link.get("target").port]) link.remove();
            });
            var outboundLinks = graph.getConnectedLinks(this, {
              outbound: true
            });
            outboundLinks.forEach(function(link) {
              if (removed[link.get("source").port]) link.remove();
            });
          }
        },
        /**
         * @returns {boolean}
         */
        hasPorts: function() {
          return this._portSettingsData.getPorts().length > 0;
        },
        /**
         * @param {string} id
         * @returns {boolean}
         */
        hasPort: function(id2) {
          return this._portSettingsData.hasPort(id2);
        },
        /**
         * @returns {Array<object>}
         */
        getPorts: function() {
          return cloneDeep(this.prop("ports/items")) || [];
        },
        /**
         * @returns {Array<object>}
         */
        getGroupPorts: function(groupName) {
          const groupPorts = toArray$1(this.prop(["ports", "items"])).filter((port) => port.group === groupName);
          return cloneDeep(groupPorts);
        },
        /**
         * @param {string} id
         * @returns {object}
         */
        getPort: function(id2) {
          const port = toArray$1(this.prop("ports/items")).find((port2) => port2.id && port2.id === id2);
          return cloneDeep(port);
        },
        getPortGroupNames: function() {
          return Object.keys(this._portSettingsData.groups);
        },
        /**
         * @param {string} groupName
         * @returns {Object<portId, {x: number, y: number, angle: number}>}
         */
        getPortsPositions: function(groupName) {
          const portsMetrics = this.getGroupPortsMetrics(groupName);
          const portsPosition = {};
          for (const portId in portsMetrics) {
            const {
              portTransformation: {
                x,
                y,
                angle
              }
            } = portsMetrics[portId];
            portsPosition[portId] = {
              x,
              y,
              angle
            };
          }
          return portsPosition;
        },
        getPortMetrics: function(portId) {
          const port = this._portSettingsData.getPort(portId);
          return this.getGroupPortsMetrics(port.group)[portId];
        },
        getGroupPortsMetrics: function(groupName) {
          return this._portSettingsData.getGroupPortsMetrics(groupName, this.size());
        },
        getPortRelativePosition: function(portId) {
          const {
            portTransformation: {
              x,
              y,
              angle
            }
          } = this.getPortMetrics(portId);
          return {
            x,
            y,
            angle
          };
        },
        getPortRelativeRect(portId) {
          const {
            portTransformation: {
              x,
              y,
              angle
            },
            portSize: {
              width: width2,
              height: height2
            }
          } = this.getPortMetrics(portId);
          const portRect = {
            x: x - width2 / 2,
            y: y - height2 / 2,
            width: width2,
            height: height2,
            angle
          };
          return portRect;
        },
        /**
         * @param {string} portId
         * @returns {Point}
         * @description Returns the port center in the graph coordinate system.
         * The port center is in the graph coordinate system, and the position
         * already takes into account the element rotation.
         **/
        getPortCenter(portId) {
          const elementBBox = this.getBBox();
          const portPosition = this.getPortRelativePosition(portId);
          const portCenter = new Point(portPosition).offset(elementBBox.x, elementBBox.y);
          const angle = this.angle();
          if (angle) portCenter.rotate(elementBBox.center(), -angle);
          return portCenter;
        },
        /**
         * @param {string} portId
         * @param {object} [opt]
         * @param {boolean} [opt.rotate] - If true, the port bounding box is rotated
         * around the port center.
         * @returns {Rect}
         * @description Returns the bounding box of the port in the graph coordinate system.
         * The port center is rotated around the element center, but the port bounding box
         * is not rotated (unless `opt.rotate` is set to true).
         */
        getPortBBox: function(portId, opt) {
          const portRect = this.getPortRelativeRect(portId);
          const elementBBox = this.getBBox();
          const portBBox = new Rect(portRect);
          portBBox.offset(elementBBox.x, elementBBox.y);
          const angle = this.angle();
          if (angle) {
            portBBox.moveAroundPoint(elementBBox.center(), -angle);
          }
          if (opt && opt.rotate) {
            portBBox.rotateAroundCenter(angle);
          }
          return portBBox;
        },
        /**
         * @param {string|Port} port port id or port
         * @returns {number} port index
         */
        getPortIndex: function(port) {
          var id2 = isObject(port) ? port.id : port;
          if (!this._isValidPortId(id2)) {
            return -1;
          }
          return toArray$1(this.prop("ports/items")).findIndex(function(item) {
            return item.id === id2;
          });
        },
        /**
         * @param {object} port
         * @param {object} [opt]
         * @returns {joint.dia.Element}
         */
        addPort: function(port, opt) {
          if (!isObject(port) || Array.isArray(port)) {
            throw new Error("Element: addPort requires an object.");
          }
          var ports = assign([], this.prop("ports/items"));
          ports.push(port);
          this.prop("ports/items", ports, opt);
          return this;
        },
        /**
         * @param {string|Port|number} before
         * @param {object} port
         * @param {object} [opt]
         * @returns {joint.dia.Element}
         */
        insertPort: function(before, port, opt) {
          const index2 = typeof before === "number" ? before : this.getPortIndex(before);
          if (!isObject(port) || Array.isArray(port)) {
            throw new Error("dia.Element: insertPort requires an object.");
          }
          const ports = assign([], this.prop("ports/items"));
          ports.splice(index2, 0, port);
          this.prop("ports/items", ports, opt);
          return this;
        },
        /**
         * @param {string} portId
         * @param {string|object=} path
         * @param {*=} value
         * @param {object=} opt
         * @returns {joint.dia.Element}
         */
        portProp: function(portId, path2, value, opt) {
          var index2 = this.getPortIndex(portId);
          if (index2 === -1) {
            throw new Error("Element: unable to find port with id " + portId);
          }
          var args = Array.prototype.slice.call(arguments, 1);
          if (Array.isArray(path2)) {
            args[0] = ["ports", "items", index2].concat(path2);
          } else if (isString(path2)) {
            args[0] = ["ports/items/", index2, "/", path2].join("");
          } else {
            args = ["ports/items/" + index2];
            if (isPlainObject(path2)) {
              args.push(path2);
              args.push(value);
            }
          }
          return this.prop.apply(this, args);
        },
        _validatePorts: function() {
          var portsAttr = this.get("ports") || {};
          var errorMessages = [];
          portsAttr = portsAttr || {};
          var ports = toArray$1(portsAttr.items);
          ports.forEach(function(p) {
            if (typeof p !== "object") {
              errorMessages.push("Element: invalid port ", p);
            }
            if (!this._isValidPortId(p.id)) {
              p.id = this.generatePortId();
            }
          }, this);
          if (uniq(ports, "id").length !== ports.length) {
            errorMessages.push("Element: found id duplicities in ports.");
          }
          return errorMessages;
        },
        generatePortId: function() {
          return this.generateId();
        },
        /**
         * @param {string} id port id
         * @returns {boolean}
         * @private
         */
        _isValidPortId: function(id2) {
          return id2 !== null && id2 !== void 0 && !isObject(id2);
        },
        addPorts: function(ports, opt) {
          if (ports.length) {
            this.prop("ports/items", assign([], this.prop("ports/items")).concat(ports), opt);
          }
          return this;
        },
        removePort: function(port, opt) {
          const options = opt || {};
          const index2 = this.getPortIndex(port);
          if (index2 !== -1) {
            const ports = assign([], this.prop(["ports", "items"]));
            ports.splice(index2, 1);
            options.rewrite = true;
            this.startBatch("port-remove");
            this.prop(["ports", "items"], ports, options);
            this.stopBatch("port-remove");
          }
          return this;
        },
        removePorts: function(portsForRemoval, opt) {
          let options, newPorts;
          if (Array.isArray(portsForRemoval)) {
            options = opt || {};
            if (portsForRemoval.length === 0) return this.this;
            const currentPorts = assign([], this.prop(["ports", "items"]));
            newPorts = currentPorts.filter(function(cp) {
              return !portsForRemoval.some(function(rp) {
                const rpId = isObject(rp) ? rp.id : rp;
                return cp.id === rpId;
              });
            });
          } else {
            options = portsForRemoval || {};
            newPorts = [];
          }
          this.startBatch("port-remove");
          options.rewrite = true;
          this.prop(["ports", "items"], newPorts, options);
          this.stopBatch("port-remove");
          return this;
        },
        /**
         * @private
         */
        _createPortData: function() {
          var err = this._validatePorts();
          if (err.length > 0) {
            this.set("ports", this.previous("ports"));
            throw new Error(err.join(" "));
          }
          var prevPortData;
          if (this._portSettingsData) {
            prevPortData = this._portSettingsData.getPorts();
          }
          this._portSettingsData = new PortData(this);
          var curPortData = this._portSettingsData.getPorts();
          if (prevPortData) {
            var added = curPortData.filter(function(item) {
              if (!prevPortData.find(function(prevPort) {
                return prevPort.id === item.id;
              })) {
                return item;
              }
            });
            var removed = prevPortData.filter(function(item) {
              if (!curPortData.find(function(curPort) {
                return curPort.id === item.id;
              })) {
                return item;
              }
            });
            if (removed.length > 0) {
              this.trigger("ports:remove", this, removed);
            }
            if (added.length > 0) {
              this.trigger("ports:add", this, added);
            }
          }
        }
      };
      const elementViewPortPrototype = {
        portContainerMarkup: "g",
        portMarkup: [{
          tagName: "circle",
          selector: "circle",
          attributes: {
            "r": 10,
            "fill": "#FFFFFF",
            "stroke": "#000000"
          }
        }],
        portLabelMarkup: [{
          tagName: "text",
          selector: "text",
          attributes: {
            "fill": "#000000"
          }
        }],
        /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */
        _portElementsCache: null,
        /**
         * @private
         */
        _initializePorts: function() {
          this._cleanPortsCache();
        },
        /**
         * @typedef {Object} Port
         *
         * @property {string} id
         * @property {Object} position
         * @property {Object} label
         * @property {Object} attrs
         * @property {string} markup
         * @property {string} group
         */
        /**
         * @private
         */
        _refreshPorts: function() {
          this._removePorts();
          this._cleanPortsCache();
          this._renderPorts();
        },
        _cleanPortsCache: function() {
          this._portElementsCache = {};
        },
        /**
         * @private
         */
        _renderPorts: function() {
          var elementReferences = [];
          var elem = this._getContainerElement();
          for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {
            elementReferences.push(elem.node.childNodes[i]);
          }
          var portsGropsByZ = groupBy(this.model._portSettingsData.getPorts(), "z");
          var withoutZKey = "auto";
          toArray$1(portsGropsByZ[withoutZKey]).forEach(function(port) {
            var portElement = this._getPortElement(port);
            elem.append(portElement);
            elementReferences.push(portElement);
          }, this);
          var groupNames = Object.keys(portsGropsByZ);
          for (var k = 0; k < groupNames.length; k++) {
            var groupName = groupNames[k];
            if (groupName !== withoutZKey) {
              var z = parseInt(groupName, 10);
              this._appendPorts(portsGropsByZ[groupName], z, elementReferences);
            }
          }
          this._updatePorts();
        },
        /**
         * @returns {V}
         * @private
         */
        _getContainerElement: function() {
          return this.rotatableNode || this.vel;
        },
        /**
         * @param {Array<Port>}ports
         * @param {number} z
         * @param refs
         * @private
         */
        _appendPorts: function(ports, z, refs) {
          var containerElement = this._getContainerElement();
          var portElements = toArray$1(ports).map(this._getPortElement, this);
          if (refs[z] || z < 0) {
            V2(refs[Math.max(z, 0)]).before(portElements);
          } else {
            containerElement.append(portElements);
          }
        },
        /**
         * Try to get element from cache,
         * @param port
         * @returns {*}
         * @private
         */
        _getPortElement: function(port) {
          if (this._portElementsCache[port.id]) {
            return this._portElementsCache[port.id].portElement;
          }
          return this._createPortElement(port);
        },
        findPortNodes: function(portId, selector) {
          const portCache = this._portElementsCache[portId];
          if (!portCache) return [];
          if (!selector) return [portCache.portContentElement.node];
          const portRoot = portCache.portElement.node;
          const portSelectors = portCache.portSelectors;
          return this.findBySelector(selector, portRoot, portSelectors);
        },
        findPortNode: function(portId, selector) {
          const [node = null] = this.findPortNodes(portId, selector);
          return node;
        },
        /**
         * @private
         */
        _updatePorts: function() {
          this._updatePortGroup(void 0);
          var groupsNames = Object.keys(this.model._portSettingsData.groups);
          groupsNames.forEach(this._updatePortGroup, this);
        },
        /**
         * @private
         */
        _removePorts: function() {
          invoke(this._portElementsCache, "portElement.remove");
        },
        /**
         * @param {Port} port
         * @returns {V}
         * @private
         */
        _createPortElement: function(port) {
          let portElement;
          let labelElement;
          let labelSelectors;
          let portSelectors;
          var portContainerElement = V2(this.portContainerMarkup).addClass("joint-port");
          var portMarkup = this._getPortMarkup(port);
          if (Array.isArray(portMarkup)) {
            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);
            var portFragment = portDoc.fragment;
            if (portFragment.childNodes.length > 1) {
              portElement = V2("g").append(portFragment);
            } else {
              portElement = V2(portFragment.firstChild);
            }
            portSelectors = portDoc.selectors;
          } else {
            portElement = V2(portMarkup);
            if (Array.isArray(portElement)) {
              portElement = V2("g").append(portElement);
            }
          }
          if (!portElement) {
            throw new Error("ElementView: Invalid port markup.");
          }
          portElement.attr({
            "port": port.id,
            "port-group": port.group
          });
          if (isNumber(port.id)) {
            portElement.attr("port-id-type", "number");
          }
          const labelMarkupDef = this._getPortLabelMarkup(port.label);
          if (Array.isArray(labelMarkupDef)) {
            const {
              fragment,
              selectors
            } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);
            const childCount = fragment.childNodes.length;
            if (childCount > 0) {
              labelSelectors = selectors;
              labelElement = childCount === 1 ? V2(fragment.firstChild) : V2("g").append(fragment);
            }
          } else {
            labelElement = V2(labelMarkupDef);
            if (Array.isArray(labelElement)) {
              labelElement = V2("g").append(labelElement);
            }
          }
          var portContainerSelectors;
          if (portSelectors && labelSelectors) {
            for (var key in labelSelectors) {
              if (portSelectors[key] && key !== this.selector) throw new Error("ElementView: selectors within port must be unique.");
            }
            portContainerSelectors = assign({}, portSelectors, labelSelectors);
          } else {
            portContainerSelectors = portSelectors || labelSelectors || {};
          }
          const portRootSelector = "portRoot";
          const labelRootSelector = "labelRoot";
          const labelTextSelector = "labelText";
          if (!(portRootSelector in portContainerSelectors)) {
            portContainerSelectors[portRootSelector] = portElement.node;
          }
          if (labelElement) {
            const labelNode = labelElement.node;
            if (!(labelRootSelector in portContainerSelectors)) {
              portContainerSelectors[labelRootSelector] = labelNode;
            }
            if (!(labelTextSelector in portContainerSelectors)) {
              const labelTextNode = labelElement.tagName() === "TEXT" ? labelNode : Array.from(labelNode.querySelectorAll("text"));
              portContainerSelectors[labelTextSelector] = labelTextNode;
              if (!labelSelectors) labelSelectors = {};
              labelSelectors[labelTextSelector] = labelTextNode;
            }
          }
          portContainerElement.append(portElement.addClass("joint-port-body"));
          if (labelElement) {
            portContainerElement.append(labelElement.addClass("joint-port-label"));
          }
          this._portElementsCache[port.id] = {
            portElement: portContainerElement,
            portLabelElement: labelElement,
            portSelectors: portContainerSelectors,
            portLabelSelectors: labelSelectors,
            portContentElement: portElement,
            portContentSelectors: portSelectors
          };
          return portContainerElement;
        },
        /**
         * @param {string=} groupName
         * @private
         */
        _updatePortGroup: function(groupName) {
          const portsMetrics = this.model.getGroupPortsMetrics(groupName);
          const portsIds = Object.keys(portsMetrics);
          for (let i = 0, n = portsIds.length; i < n; i++) {
            const portId = portsIds[i];
            const metrics = portsMetrics[portId];
            const cached = this._portElementsCache[portId] || {};
            const portTransformation = metrics.portTransformation;
            const labelTransformation = metrics.labelTransformation;
            if (labelTransformation && cached.portLabelElement) {
              this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {
                rootBBox: new Rect(metrics.labelSize),
                selectors: cached.portLabelSelectors
              });
              this.applyPortTransform(cached.portLabelElement, labelTransformation, -portTransformation.angle || 0);
            }
            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {
              rootBBox: new Rect(metrics.portSize),
              selectors: cached.portSelectors
            });
            this.applyPortTransform(cached.portElement, portTransformation);
          }
        },
        /**
         * @param {Vectorizer} element
         * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData
         * @param {number=} initialAngle
         * @constructor
         */
        applyPortTransform: function(element, transformData, initialAngle) {
          var matrix = V2.createSVGMatrix().rotate(initialAngle || 0).translate(transformData.x || 0, transformData.y || 0).rotate(transformData.angle || 0);
          element.transform(matrix, {
            absolute: true
          });
        },
        /**
         * @param {Port} port
         * @returns {string}
         * @private
         */
        _getPortMarkup: function(port) {
          return port.markup || this.model.get("portMarkup") || this.model.portMarkup || this.portMarkup;
        },
        /**
         * @param {Object} label
         * @returns {string}
         * @private
         */
        _getPortLabelMarkup: function(label) {
          return label.markup || this.model.get("portLabelMarkup") || this.model.portLabelMarkup || this.portLabelMarkup;
        }
      };
      const Element$1 = Cell.extend({
        defaults: {
          position: {
            x: 0,
            y: 0
          },
          size: {
            width: 1,
            height: 1
          },
          angle: 0
        },
        initialize: function(attributes2, options) {
          this._initializePorts(options);
          Cell.prototype.initialize.apply(this, arguments);
        },
        /**
         * @abstract
         */
        _initializePorts: function() {
        },
        _refreshPorts: function() {
        },
        isElement: function() {
          return true;
        },
        position: function(x, y, opt) {
          const isSetter = isNumber(y);
          opt = (isSetter ? opt : x) || {};
          const {
            parentRelative,
            deep,
            restrictedArea
          } = opt;
          let parentPosition;
          if (parentRelative) {
            if (!this.graph) throw new Error("Element must be part of a graph.");
            const parent2 = this.getParentCell();
            if (parent2 && !parent2.isLink()) {
              parentPosition = parent2.get("position");
            }
          }
          if (isSetter) {
            if (parentPosition) {
              x += parentPosition.x;
              y += parentPosition.y;
            }
            if (deep || restrictedArea) {
              const {
                x: x0,
                y: y0
              } = this.get("position");
              this.translate(x - x0, y - y0, opt);
            } else {
              this.set("position", {
                x,
                y
              }, opt);
            }
            return this;
          } else {
            const elementPosition = Point(this.get("position"));
            return parentRelative ? elementPosition.difference(parentPosition) : elementPosition;
          }
        },
        translate: function(tx, ty, opt) {
          tx = tx || 0;
          ty = ty || 0;
          if (tx === 0 && ty === 0) {
            return this;
          }
          opt = opt || {};
          opt.translateBy = opt.translateBy || this.id;
          var position2 = this.get("position") || {
            x: 0,
            y: 0
          };
          var ra = opt.restrictedArea;
          if (ra && opt.translateBy === this.id) {
            if (typeof ra === "function") {
              var newPosition = ra.call(this, position2.x + tx, position2.y + ty, opt);
              tx = newPosition.x - position2.x;
              ty = newPosition.y - position2.y;
            } else {
              var bbox2 = this.getBBox({
                deep: true
              });
              var dx = position2.x - bbox2.x;
              var dy = position2.y - bbox2.y;
              var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox2.width, position2.x + tx));
              var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox2.height, position2.y + ty));
              tx = x - position2.x;
              ty = y - position2.y;
            }
          }
          var translatedPosition = {
            x: position2.x + tx,
            y: position2.y + ty
          };
          opt.tx = tx;
          opt.ty = ty;
          if (opt.transition) {
            if (!isObject(opt.transition)) opt.transition = {};
            this.transition("position", translatedPosition, assign({}, opt.transition, {
              valueFunction: interpolate.object
            }));
            invoke(this.getEmbeddedCells(), "translate", tx, ty, opt);
          } else {
            this.startBatch("translate", opt);
            this.set("position", translatedPosition, opt);
            invoke(this.getEmbeddedCells(), "translate", tx, ty, opt);
            this.stopBatch("translate", opt);
          }
          return this;
        },
        size: function(width2, height2, opt) {
          var currentSize = this.get("size");
          if (width2 === void 0) {
            return {
              width: currentSize.width,
              height: currentSize.height
            };
          }
          if (isObject(width2)) {
            opt = height2;
            height2 = isNumber(width2.height) ? width2.height : currentSize.height;
            width2 = isNumber(width2.width) ? width2.width : currentSize.width;
          }
          return this.resize(width2, height2, opt);
        },
        resize: function(width2, height2, opt) {
          opt = opt || {};
          this.startBatch("resize", opt);
          if (opt.direction) {
            var currentSize = this.get("size");
            switch (opt.direction) {
              case "left":
              case "right":
                height2 = currentSize.height;
                break;
              case "top":
              case "bottom":
                width2 = currentSize.width;
                break;
            }
            var angle = normalizeAngle(this.get("angle") || 0);
            var bbox2 = this.getBBox();
            var origin;
            if (angle) {
              var quadrant = {
                "top-right": 0,
                "right": 0,
                "top-left": 1,
                "top": 1,
                "bottom-left": 2,
                "left": 2,
                "bottom-right": 3,
                "bottom": 3
              }[opt.direction];
              if (opt.absolute) {
                quadrant += Math.floor((angle + 45) / 90);
                quadrant %= 4;
              }
              var fixedPoint = bbox2[["bottomLeft", "corner", "topRight", "origin"][quadrant]]();
              var imageFixedPoint = Point(fixedPoint).rotate(bbox2.center(), -angle);
              var radius = Math.sqrt(width2 * width2 + height2 * height2) / 2;
              var alpha = quadrant * Math.PI / 2;
              alpha += Math.atan(quadrant % 2 == 0 ? height2 / width2 : width2 / height2);
              alpha -= toRad(angle);
              var center2 = Point.fromPolar(radius, alpha, imageFixedPoint);
              origin = Point(center2).offset(width2 / -2, height2 / -2);
            } else {
              origin = bbox2.topLeft();
              switch (opt.direction) {
                case "top":
                case "top-right":
                  origin.offset(0, bbox2.height - height2);
                  break;
                case "left":
                case "bottom-left":
                  origin.offset(bbox2.width - width2, 0);
                  break;
                case "top-left":
                  origin.offset(bbox2.width - width2, bbox2.height - height2);
                  break;
              }
            }
            this.set("size", {
              width: width2,
              height: height2
            }, opt);
            this.position(origin.x, origin.y, opt);
          } else {
            this.set("size", {
              width: width2,
              height: height2
            }, opt);
          }
          this.stopBatch("resize", opt);
          return this;
        },
        scale: function(sx, sy, origin, opt) {
          var scaledBBox = this.getBBox().scale(sx, sy, origin);
          this.startBatch("scale", opt);
          this.position(scaledBBox.x, scaledBBox.y, opt);
          this.resize(scaledBBox.width, scaledBBox.height, opt);
          this.stopBatch("scale");
          return this;
        },
        fitEmbeds: function(opt) {
          return this.fitToChildren(opt);
        },
        fitToChildren: function(opt = {}) {
          const {
            graph
          } = this;
          if (!graph) throw new Error("Element must be part of a graph.");
          const filteredChildElements = this._getFilteredChildElements(opt.filter);
          this.startBatch("fit-embeds", opt);
          if (opt.deep) {
            invoke(filteredChildElements, "fitToChildren", omit(opt, "minRect"));
          }
          this._fitToElements(Object.assign({
            elements: filteredChildElements
          }, opt));
          this.stopBatch("fit-embeds");
          return this;
        },
        fitParent: function(opt = {}) {
          const {
            graph
          } = this;
          if (!graph) throw new Error("Element must be part of a graph.");
          if (opt.deep && opt.terminator && (opt.terminator === this || opt.terminator === this.id)) return this;
          const parentElement = this.getParentCell();
          if (!parentElement || !parentElement.isElement()) return this;
          const filteredSiblingElements = parentElement._getFilteredChildElements(opt.filter);
          this.startBatch("fit-parent", opt);
          parentElement._fitToElements(Object.assign({
            elements: filteredSiblingElements
          }, opt));
          if (opt.deep) {
            parentElement.fitParent(omit(opt, "minRect"));
          }
          this.stopBatch("fit-parent");
          return this;
        },
        _getFilteredChildElements: function(filter2) {
          let filterFn;
          if (typeof filter2 === "function") {
            filterFn = (cell) => cell.isElement() && filter2(cell);
          } else {
            filterFn = (cell) => cell.isElement();
          }
          return this.getEmbeddedCells().filter(filterFn);
        },
        // Assumption: This element is part of a graph.
        _fitToElements: function(opt = {}) {
          let minBBox = null;
          if (opt.minRect) {
            const minRect = assign(this.getBBox(), opt.minRect);
            minBBox = new Rect(minRect);
          }
          const elementsBBox = this.graph.getCellsBBox(opt.elements);
          if (!elementsBBox) {
            this._setBBox(minBBox, opt);
            return;
          }
          const {
            expandOnly,
            shrinkOnly
          } = opt;
          if (expandOnly && shrinkOnly) {
            this._setBBox(minBBox, opt);
            return;
          }
          let {
            x,
            y,
            width: width2,
            height: height2
          } = elementsBBox;
          const {
            left: left2,
            right: right2,
            top: top2,
            bottom: bottom2
          } = normalizeSides(opt.padding);
          x -= left2;
          y -= top2;
          width2 += left2 + right2;
          height2 += bottom2 + top2;
          let contentBBox = new Rect(x, y, width2, height2);
          if (expandOnly) {
            contentBBox = this.getBBox().union(contentBBox);
          } else if (shrinkOnly) {
            const intersectionBBox = this.getBBox().intersect(contentBBox);
            if (!intersectionBBox) {
              this._setBBox(minBBox, opt);
              return;
            }
            contentBBox = intersectionBBox;
          }
          let resultBBox = contentBBox;
          if (minBBox) {
            resultBBox = resultBBox.union(minBBox);
          }
          this._setBBox(resultBBox, opt);
        },
        _setBBox: function(bbox2, opt) {
          if (!bbox2) return;
          const {
            x,
            y,
            width: width2,
            height: height2
          } = bbox2;
          this.set({
            position: {
              x,
              y
            },
            size: {
              width: width2,
              height: height2
            }
          }, opt);
        },
        // Rotate element by `angle` degrees, optionally around `origin` point.
        // If `origin` is not provided, it is considered to be the center of the element.
        // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not
        // the difference from the previous angle.
        rotate: function(angle, absolute2, origin, opt) {
          if (origin) {
            var center2 = this.getCenter();
            var size = this.get("size");
            var position2 = this.get("position");
            center2.rotate(origin, this.get("angle") - angle);
            var dx = center2.x - size.width / 2 - position2.x;
            var dy = center2.y - size.height / 2 - position2.y;
            this.startBatch("rotate", {
              angle,
              absolute: absolute2,
              origin
            });
            this.position(position2.x + dx, position2.y + dy, opt);
            this.rotate(angle, absolute2, null, opt);
            this.stopBatch("rotate");
          } else {
            this.set("angle", absolute2 ? angle : (this.get("angle") + angle) % 360, opt);
          }
          return this;
        },
        angle: function() {
          return normalizeAngle(this.get("angle") || 0);
        },
        getBBox: function(opt = {}) {
          const {
            graph,
            attributes: attributes2
          } = this;
          const {
            deep,
            rotate
          } = opt;
          if (deep && graph) {
            const elements = this.getEmbeddedCells({
              deep: true,
              breadthFirst: true
            });
            elements.push(this);
            return graph.getCellsBBox(elements, opt);
          }
          const {
            angle = 0,
            position: {
              x,
              y
            },
            size: {
              width: width2,
              height: height2
            }
          } = attributes2;
          const bbox2 = new Rect(x, y, width2, height2);
          if (rotate) {
            bbox2.rotateAroundCenter(angle);
          }
          return bbox2;
        },
        getCenter: function() {
          const {
            position: {
              x,
              y
            },
            size: {
              width: width2,
              height: height2
            }
          } = this.attributes;
          return new Point(x + width2 / 2, y + height2 / 2);
        },
        getPointFromConnectedLink: function(link, endType) {
          var bbox2 = this.getBBox();
          var center2 = bbox2.center();
          var endDef = link.get(endType);
          if (!endDef) return center2;
          var portId = endDef.port;
          if (!portId || !this.hasPort(portId)) return center2;
          return this.getPortCenter(portId);
        }
      });
      assign(Element$1.prototype, elementPortPrototype);
      const Link$1 = Cell.extend({
        // may be overwritten by user to change default label (its markup, size, attrs, position)
        defaultLabel: void 0,
        // deprecated
        // may be overwritten by user to change default label markup
        // lower priority than defaultLabel.markup
        labelMarkup: void 0,
        // private
        _builtins: {
          defaultLabel: {
            // builtin default markup:
            // used if neither defaultLabel.markup
            // nor label.markup is set
            markup: [{
              tagName: "rect",
              selector: "rect"
              // faster than tagName CSS selector
            }, {
              tagName: "text",
              selector: "text"
              // faster than tagName CSS selector
            }],
            // builtin default attributes:
            // applied only if builtin default markup is used
            attrs: {
              text: {
                fill: "#000000",
                fontSize: 14,
                textAnchor: "middle",
                textVerticalAnchor: "middle",
                pointerEvents: "none"
              },
              rect: {
                ref: "text",
                fill: "#ffffff",
                rx: 3,
                ry: 3,
                x: "calc(x)",
                y: "calc(y)",
                width: "calc(w)",
                height: "calc(h)"
              }
            },
            // builtin default position:
            // used if neither defaultLabel.position
            // nor label.position is set
            position: {
              distance: 0.5
            }
          }
        },
        defaults: {
          source: {},
          target: {}
        },
        isLink: function() {
          return true;
        },
        disconnect: function(opt) {
          return this.set({
            source: {
              x: 0,
              y: 0
            },
            target: {
              x: 0,
              y: 0
            }
          }, opt);
        },
        source: function(source, args, opt) {
          if (source === void 0) {
            return clone$1(this.get("source"));
          }
          var setSource;
          var setOpt;
          var isCellProvided = source instanceof Cell;
          if (isCellProvided) {
            setSource = clone$1(args) || {};
            setSource.id = source.id;
            setOpt = opt;
            return this.set("source", setSource, setOpt);
          }
          var isPointProvided = !isPlainObject(source);
          if (isPointProvided) {
            setSource = clone$1(args) || {};
            setSource.x = source.x;
            setSource.y = source.y;
            setOpt = opt;
            return this.set("source", setSource, setOpt);
          }
          setSource = source;
          setOpt = args;
          return this.set("source", setSource, setOpt);
        },
        target: function(target, args, opt) {
          if (target === void 0) {
            return clone$1(this.get("target"));
          }
          var setTarget;
          var setOpt;
          var isCellProvided = target instanceof Cell;
          if (isCellProvided) {
            setTarget = clone$1(args) || {};
            setTarget.id = target.id;
            setOpt = opt;
            return this.set("target", setTarget, setOpt);
          }
          var isPointProvided = !isPlainObject(target);
          if (isPointProvided) {
            setTarget = clone$1(args) || {};
            setTarget.x = target.x;
            setTarget.y = target.y;
            setOpt = opt;
            return this.set("target", setTarget, setOpt);
          }
          setTarget = target;
          setOpt = args;
          return this.set("target", setTarget, setOpt);
        },
        router: function(name, args, opt) {
          if (name === void 0) {
            var router2 = this.get("router");
            if (!router2) {
              return null;
            }
            if (typeof router2 === "object") return clone$1(router2);
            return router2;
          }
          var isRouterProvided = typeof name === "object" || typeof name === "function";
          var localRouter = isRouterProvided ? name : {
            name,
            args
          };
          var localOpt = isRouterProvided ? args : opt;
          return this.set("router", localRouter, localOpt);
        },
        connector: function(name, args, opt) {
          if (name === void 0) {
            var connector = this.get("connector");
            if (!connector) {
              return null;
            }
            if (typeof connector === "object") return clone$1(connector);
            return connector;
          }
          var isConnectorProvided = typeof name === "object" || typeof name === "function";
          var localConnector = isConnectorProvided ? name : {
            name,
            args
          };
          var localOpt = isConnectorProvided ? args : opt;
          return this.set("connector", localConnector, localOpt);
        },
        // Labels API
        // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.
        label: function(idx, label, opt) {
          var labels = this.labels();
          idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
          if (idx < 0) idx = labels.length + idx;
          if (arguments.length <= 1) return this.prop(["labels", idx]);
          return this.prop(["labels", idx], label, opt);
        },
        labels: function(labels, opt) {
          if (arguments.length === 0) {
            labels = this.get("labels");
            if (!Array.isArray(labels)) return [];
            return labels.slice();
          }
          if (!Array.isArray(labels)) labels = [];
          return this.set("labels", labels, opt);
        },
        hasLabels: function() {
          const {
            labels
          } = this.attributes;
          return Array.isArray(labels) && labels.length > 0;
        },
        insertLabel: function(idx, label, opt) {
          if (!label) throw new Error("dia.Link: no label provided");
          var labels = this.labels();
          var n = labels.length;
          idx = isFinite(idx) && idx !== null ? idx | 0 : n;
          if (idx < 0) idx = n + idx + 1;
          labels.splice(idx, 0, label);
          return this.labels(labels, opt);
        },
        // convenience function
        // add label to end of labels array
        appendLabel: function(label, opt) {
          return this.insertLabel(-1, label, opt);
        },
        removeLabel: function(idx, opt) {
          var labels = this.labels();
          idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
          labels.splice(idx, 1);
          return this.labels(labels, opt);
        },
        // Vertices API
        vertex: function(idx, vertex, opt) {
          var vertices = this.vertices();
          idx = isFinite(idx) && idx !== null ? idx | 0 : 0;
          if (idx < 0) idx = vertices.length + idx;
          if (arguments.length <= 1) return this.prop(["vertices", idx]);
          var setVertex = this._normalizeVertex(vertex);
          return this.prop(["vertices", idx], setVertex, opt);
        },
        vertices: function(vertices, opt) {
          if (arguments.length === 0) {
            vertices = this.get("vertices");
            if (!Array.isArray(vertices)) return [];
            return vertices.slice();
          }
          if (!Array.isArray(vertices)) vertices = [];
          var setVertices = [];
          for (var i = 0; i < vertices.length; i++) {
            var vertex = vertices[i];
            var setVertex = this._normalizeVertex(vertex);
            setVertices.push(setVertex);
          }
          return this.set("vertices", setVertices, opt);
        },
        insertVertex: function(idx, vertex, opt) {
          if (!vertex) throw new Error("dia.Link: no vertex provided");
          var vertices = this.vertices();
          var n = vertices.length;
          idx = isFinite(idx) && idx !== null ? idx | 0 : n;
          if (idx < 0) idx = n + idx + 1;
          var setVertex = this._normalizeVertex(vertex);
          vertices.splice(idx, 0, setVertex);
          return this.vertices(vertices, opt);
        },
        removeVertex: function(idx, opt) {
          var vertices = this.vertices();
          idx = isFinite(idx) && idx !== null ? idx | 0 : -1;
          vertices.splice(idx, 1);
          return this.vertices(vertices, opt);
        },
        _normalizeVertex: function(vertex) {
          var isPointProvided = !isPlainObject(vertex);
          if (isPointProvided) return {
            x: vertex.x,
            y: vertex.y
          };
          return vertex;
        },
        // Transformations
        translate: function(tx, ty, opt) {
          opt = opt || {};
          opt.translateBy = opt.translateBy || this.id;
          opt.tx = tx;
          opt.ty = ty;
          return this.applyToPoints(function(p) {
            return {
              x: (p.x || 0) + tx,
              y: (p.y || 0) + ty
            };
          }, opt);
        },
        scale: function(sx, sy, origin, opt) {
          return this.applyToPoints(function(p) {
            return Point(p).scale(sx, sy, origin).toJSON();
          }, opt);
        },
        applyToPoints: function(fn2, opt) {
          if (!isFunction(fn2)) {
            throw new TypeError("dia.Link: applyToPoints expects its first parameter to be a function.");
          }
          var attrs = {};
          var {
            source,
            target
          } = this.attributes;
          if (!source.id) {
            attrs.source = fn2(source);
          }
          if (!target.id) {
            attrs.target = fn2(target);
          }
          var vertices = this.vertices();
          if (vertices.length > 0) {
            attrs.vertices = vertices.map(fn2);
          }
          return this.set(attrs, opt);
        },
        getSourcePoint: function() {
          var sourceCell = this.getSourceCell();
          if (!sourceCell) return new Point(this.source());
          return sourceCell.getPointFromConnectedLink(this, "source");
        },
        getTargetPoint: function() {
          var targetCell = this.getTargetCell();
          if (!targetCell) return new Point(this.target());
          return targetCell.getPointFromConnectedLink(this, "target");
        },
        getPointFromConnectedLink: function() {
          return this.getPolyline().pointAt(0.5);
        },
        getPolyline: function() {
          const points = [this.getSourcePoint(), ...this.vertices().map(Point), this.getTargetPoint()];
          return new Polyline$1(points);
        },
        getBBox: function() {
          return this.getPolyline().bbox();
        },
        reparent: function(opt) {
          var newParent;
          if (this.graph) {
            var source = this.getSourceElement();
            var target = this.getTargetElement();
            var prevParent = this.getParentCell();
            if (source && target) {
              if (source === target || source.isEmbeddedIn(target)) {
                newParent = target;
              } else if (target.isEmbeddedIn(source)) {
                newParent = source;
              } else {
                newParent = this.graph.getCommonAncestor(source, target);
              }
            }
            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {
              prevParent.unembed(this, opt);
            }
            if (newParent) {
              newParent.embed(this, opt);
            }
          }
          return newParent;
        },
        hasLoop: function(opt) {
          opt = opt || {};
          var {
            source,
            target
          } = this.attributes;
          var sourceId = source.id;
          var targetId = target.id;
          if (!sourceId || !targetId) {
            return false;
          }
          var loop = sourceId === targetId;
          if (!loop && opt.deep && this.graph) {
            var sourceElement = this.getSourceCell();
            var targetElement = this.getTargetCell();
            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);
          }
          return loop;
        },
        // unlike source(), this method returns null if source is a point
        getSourceCell: function() {
          const {
            graph,
            attributes: attributes2
          } = this;
          var source = attributes2.source;
          return source && source.id && graph && graph.getCell(source.id) || null;
        },
        getSourceElement: function() {
          var cell = this;
          var visited = {};
          do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getSourceCell();
          } while (cell && cell.isLink());
          return cell;
        },
        // unlike target(), this method returns null if target is a point
        getTargetCell: function() {
          const {
            graph,
            attributes: attributes2
          } = this;
          var target = attributes2.target;
          return target && target.id && graph && graph.getCell(target.id) || null;
        },
        getTargetElement: function() {
          var cell = this;
          var visited = {};
          do {
            if (visited[cell.id]) return null;
            visited[cell.id] = true;
            cell = cell.getTargetCell();
          } while (cell && cell.isLink());
          return cell;
        },
        // Returns the common ancestor for the source element,
        // target element and the link itself.
        getRelationshipAncestor: function() {
          var connectionAncestor;
          if (this.graph) {
            var cells = [
              this,
              this.getSourceElement(),
              // null if source is a point
              this.getTargetElement()
              // null if target is a point
            ].filter(function(item) {
              return !!item;
            });
            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);
          }
          return connectionAncestor || null;
        },
        // Is source, target and the link itself embedded in a given cell?
        isRelationshipEmbeddedIn: function(cell) {
          var cellId = isString(cell) || isNumber(cell) ? cell : cell.id;
          var ancestor = this.getRelationshipAncestor();
          return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));
        },
        // Get resolved default label.
        _getDefaultLabel: function() {
          var defaultLabel = this.get("defaultLabel") || this.defaultLabel || {};
          var label = {};
          label.markup = defaultLabel.markup || this.get("labelMarkup") || this.labelMarkup;
          label.position = defaultLabel.position;
          label.attrs = defaultLabel.attrs;
          label.size = defaultLabel.size;
          return label;
        }
      }, {
        endsEqual: function(a, b) {
          var portsEqual = a.port === b.port || !a.port && !b.port;
          return a.id === b.id && portsEqual;
        }
      });
      const env = {
        _results: {},
        _tests: {
          svgforeignobject: function() {
            return !!document.createElementNS && /SVGForeignObject/.test({}.toString.call(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")));
          },
          // works for: (1) macOS Safari, (2) any WKWebView, (3) any iOS browser (including Safari, CriOS, EdgiOS, OPR, FxiOS)
          isAppleWebKit: function() {
            const userAgent = navigator.userAgent;
            const isAppleWebKit = /applewebkit/i.test(userAgent);
            const isChromium = /chrome/i.test(userAgent);
            return isAppleWebKit && !isChromium;
          }
        },
        addTest: function(name, fn2) {
          return this._tests[name] = fn2;
        },
        test: function(name) {
          var fn2 = this._tests[name];
          if (!fn2) {
            throw new Error('Test not defined ("' + name + '"). Use `joint.env.addTest(name, fn) to add a new test.`');
          }
          var result2 = this._results[name];
          if (typeof result2 !== "undefined") {
            return result2;
          }
          try {
            result2 = fn2();
          } catch {
            result2 = false;
          }
          this._results[name] = result2;
          return result2;
        }
      };
      const Rectangle = Element$1.define("standard.Rectangle", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            width: "calc(w)",
            height: "calc(h)",
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "rect",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Circle = Element$1.define("standard.Circle", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            cx: "calc(s/2)",
            cy: "calc(s/2)",
            r: "calc(s/2)",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "circle",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Ellipse = Element$1.define("standard.Ellipse", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            cx: "calc(w/2)",
            cy: "calc(h/2)",
            rx: "calc(w/2)",
            ry: "calc(h/2)",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "ellipse",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Path = Element$1.define("standard.Path", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            d: "M 0 0 H calc(w) V calc(h) H 0 Z",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "path",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Polygon = Element$1.define("standard.Polygon", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            points: "0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "polygon",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Polyline = Element$1.define("standard.Polyline", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            points: "0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)",
            strokeWidth: 2,
            stroke: "#333333",
            fill: "#FFFFFF"
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "polyline",
          selector: "body"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const Image = Element$1.define("standard.Image", {
        attrs: {
          root: {
            cursor: "move"
          },
          image: {
            width: "calc(w)",
            height: "calc(h)"
            // xlinkHref: '[URL]'
          },
          label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h+10)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "image",
          selector: "image"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const BorderedImage = Element$1.define("standard.BorderedImage", {
        attrs: {
          root: {
            cursor: "move"
          },
          border: {
            width: "calc(w)",
            height: "calc(h)",
            stroke: "#333333",
            strokeWidth: 2
          },
          background: {
            width: "calc(w-1)",
            height: "calc(h-1)",
            x: 0.5,
            y: 0.5,
            fill: "#FFFFFF"
          },
          image: {
            // xlinkHref: '[URL]'
            width: "calc(w-1)",
            height: "calc(h-1)",
            x: 0.5,
            y: 0.5
          },
          label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h+10)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "rect",
          selector: "background",
          attributes: {
            "stroke": "none"
          }
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "rect",
          selector: "border",
          attributes: {
            "fill": "none"
          }
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const EmbeddedImage = Element$1.define("standard.EmbeddedImage", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            width: "calc(w)",
            height: "calc(h)",
            stroke: "#333333",
            fill: "#FFFFFF",
            strokeWidth: 2
          },
          image: {
            // xlinkHref: '[URL]'
            width: "calc(0.3*w)",
            height: "calc(h-20)",
            x: 10,
            y: 10,
            preserveAspectRatio: "xMidYMin"
          },
          label: {
            textVerticalAnchor: "top",
            textAnchor: "left",
            x: "calc(0.3*w+20)",
            // 10 + 10
            y: 10,
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "rect",
          selector: "body"
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const InscribedImage = Element$1.define("standard.InscribedImage", {
        attrs: {
          root: {
            cursor: "move"
          },
          border: {
            rx: "calc(w/2)",
            ry: "calc(h/2)",
            cx: "calc(w/2)",
            cy: "calc(h/2)",
            stroke: "#333333",
            strokeWidth: 2
          },
          background: {
            rx: "calc(w/2)",
            ry: "calc(h/2)",
            cx: "calc(w/2)",
            cy: "calc(h/2)",
            fill: "#FFFFFF"
          },
          image: {
            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%
            width: "calc(0.68*w)",
            height: "calc(0.68*h)",
            // The image offset is calculated as (100% - 68%) / 2
            x: "calc(0.16*w)",
            y: "calc(0.16*h)",
            preserveAspectRatio: "xMidYMid"
            // xlinkHref: '[URL]'
          },
          label: {
            textVerticalAnchor: "top",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h+10)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "ellipse",
          selector: "background"
        }, {
          tagName: "image",
          selector: "image"
        }, {
          tagName: "ellipse",
          selector: "border",
          attributes: {
            "fill": "none"
          }
        }, {
          tagName: "text",
          selector: "label"
        }]
      });
      const HeaderedRectangle = Element$1.define("standard.HeaderedRectangle", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            width: "calc(w)",
            height: "calc(h)",
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
          },
          header: {
            width: "calc(w)",
            height: 30,
            strokeWidth: 2,
            stroke: "#000000",
            fill: "#FFFFFF"
          },
          headerText: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: 15,
            fontSize: 16,
            fill: "#333333"
          },
          bodyText: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h/2+15)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "rect",
          selector: "body"
        }, {
          tagName: "rect",
          selector: "header"
        }, {
          tagName: "text",
          selector: "headerText"
        }, {
          tagName: "text",
          selector: "bodyText"
        }]
      });
      var CYLINDER_TILT = 10;
      const Cylinder = Element$1.define("standard.Cylinder", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            lateralArea: CYLINDER_TILT,
            fill: "#FFFFFF",
            stroke: "#333333",
            strokeWidth: 2
          },
          top: {
            cx: "calc(w/2)",
            cy: CYLINDER_TILT,
            rx: "calc(w/2)",
            ry: CYLINDER_TILT,
            fill: "#FFFFFF",
            stroke: "#333333",
            strokeWidth: 2
          },
          label: {
            textVerticalAnchor: "middle",
            textAnchor: "middle",
            x: "calc(w/2)",
            y: "calc(h+15)",
            fontSize: 14,
            fill: "#333333"
          }
        }
      }, {
        markup: [{
          tagName: "path",
          selector: "body"
        }, {
          tagName: "ellipse",
          selector: "top"
        }, {
          tagName: "text",
          selector: "label"
        }],
        topRy: function(t, opt) {
          if (t === void 0) return this.attr("body/lateralArea");
          var bodyAttrs = {
            lateralArea: t
          };
          var isPercentageSetter = isPercentage(t);
          var ty = isPercentageSetter ? `calc(${parseFloat(t) / 100}*h)` : t;
          var topAttrs = {
            cy: ty,
            ry: ty
          };
          return this.attr({
            body: bodyAttrs,
            top: topAttrs
          }, opt);
        }
      }, {
        attributes: {
          "lateral-area": {
            set: function(t, refBBox) {
              var isPercentageSetter = isPercentage(t);
              if (isPercentageSetter) t = parseFloat(t) / 100;
              var x = refBBox.x;
              var y = refBBox.y;
              var w = refBBox.width;
              var h = refBBox.height;
              var rx = w / 2;
              var ry = isPercentageSetter ? h * t : t;
              var kappa = V2.KAPPA;
              var cx = kappa * rx;
              var cy = kappa * (isPercentageSetter ? h * t : t);
              var xLeft = x;
              var xCenter = x + w / 2;
              var xRight = x + w;
              var ySideTop = y + ry;
              var yCurveTop = ySideTop - ry;
              var ySideBottom = y + h - ry;
              var yCurveBottom = y + h;
              var data2 = ["M", xLeft, ySideTop, "L", xLeft, ySideBottom, "C", x, ySideBottom + cy, xCenter - cx, yCurveBottom, xCenter, yCurveBottom, "C", xCenter + cx, yCurveBottom, xRight, ySideBottom + cy, xRight, ySideBottom, "L", xRight, ySideTop, "C", xRight, ySideTop - cy, xCenter + cx, yCurveTop, xCenter, yCurveTop, "C", xCenter - cx, yCurveTop, xLeft, ySideTop - cy, xLeft, ySideTop, "Z"];
              return {
                d: data2.join(" ")
              };
            },
            unset: "d"
          }
        }
      });
      var foLabelMarkup = {
        tagName: "foreignObject",
        selector: "foreignObject",
        attributes: {
          "overflow": "hidden"
        },
        children: [{
          tagName: "div",
          namespaceURI: "http://www.w3.org/1999/xhtml",
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }]
      };
      var svgLabelMarkup = {
        tagName: "text",
        selector: "label",
        attributes: {
          "text-anchor": "middle"
        }
      };
      var labelMarkup = env.test("svgforeignobject") ? foLabelMarkup : svgLabelMarkup;
      const TextBlock = Element$1.define("standard.TextBlock", {
        attrs: {
          root: {
            cursor: "move"
          },
          body: {
            width: "calc(w)",
            height: "calc(h)",
            stroke: "#333333",
            fill: "#ffffff",
            strokeWidth: 2
          },
          foreignObject: {
            width: "calc(w)",
            height: "calc(h)"
          },
          label: {
            style: {
              fontSize: 14
            }
          }
        }
      }, {
        markup: [{
          tagName: "rect",
          selector: "body"
        }, labelMarkup]
      }, {
        attributes: {
          text: {
            set: function(text, refBBox, node, attrs) {
              if (node instanceof HTMLElement) {
                node.textContent = text;
              } else {
                var style = attrs["style"] || {};
                var wrapValue = {
                  text,
                  width: -5,
                  height: "100%"
                };
                var wrapAttrs = assign({
                  "text-vertical-anchor": "middle"
                }, style);
                attributes["text-wrap"].set.call(this, wrapValue, refBBox, node, wrapAttrs);
                return {
                  fill: style.color || null
                };
              }
            },
            unset: function(node) {
              node.textContent = "";
              if (node instanceof SVGElement) {
                return "fill";
              }
            },
            position: function(text, refBBox, node) {
              if (node instanceof SVGElement) return refBBox.center();
            }
          }
        }
      });
      const Link = Link$1.define("standard.Link", {
        attrs: {
          line: {
            connection: true,
            stroke: "#333333",
            strokeWidth: 2,
            strokeLinejoin: "round",
            targetMarker: {
              "type": "path",
              "d": "M 10 -5 0 0 10 5 z"
            }
          },
          wrapper: {
            connection: true,
            strokeWidth: 10,
            strokeLinejoin: "round"
          }
        }
      }, {
        markup: [{
          tagName: "path",
          selector: "wrapper",
          attributes: {
            "fill": "none",
            "cursor": "pointer",
            "stroke": "transparent",
            "stroke-linecap": "round"
          }
        }, {
          tagName: "path",
          selector: "line",
          attributes: {
            "fill": "none",
            "pointer-events": "none"
          }
        }]
      });
      const DoubleLink = Link$1.define("standard.DoubleLink", {
        attrs: {
          line: {
            connection: true,
            stroke: "#DDDDDD",
            strokeWidth: 4,
            strokeLinejoin: "round",
            targetMarker: {
              type: "path",
              stroke: "#000000",
              d: "M 10 -3 10 -10 -2 0 10 10 10 3"
            }
          },
          outline: {
            connection: true,
            stroke: "#000000",
            strokeWidth: 6,
            strokeLinejoin: "round"
          }
        }
      }, {
        markup: [{
          tagName: "path",
          selector: "outline",
          attributes: {
            "fill": "none",
            "cursor": "pointer"
          }
        }, {
          tagName: "path",
          selector: "line",
          attributes: {
            "fill": "none",
            "pointer-events": "none"
          }
        }]
      });
      const ShadowLink = Link$1.define("standard.ShadowLink", {
        attrs: {
          line: {
            connection: true,
            stroke: "#FF0000",
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
              "type": "path",
              "stroke": "none",
              "d": "M 0 -10 -10 0 0 10 z"
            },
            sourceMarker: {
              "type": "path",
              "stroke": "none",
              "d": "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
          },
          shadow: {
            connection: true,
            transform: "translate(3,6)",
            stroke: "#000000",
            strokeOpacity: 0.2,
            strokeWidth: 20,
            strokeLinejoin: "round",
            targetMarker: {
              "type": "path",
              "d": "M 0 -10 -10 0 0 10 z",
              "stroke": "none"
            },
            sourceMarker: {
              "type": "path",
              "stroke": "none",
              "d": "M -10 -10 0 0 -10 10 0 10 0 -10 z"
            }
          }
        }
      }, {
        markup: [{
          tagName: "path",
          selector: "shadow",
          attributes: {
            "fill": "none",
            "pointer-events": "none"
          }
        }, {
          tagName: "path",
          selector: "line",
          attributes: {
            "fill": "none",
            "cursor": "pointer"
          }
        }]
      });
      var standard = {
        __proto__: null,
        BorderedImage,
        Circle,
        Cylinder,
        DoubleLink,
        Ellipse,
        EmbeddedImage,
        HeaderedRectangle,
        Image,
        InscribedImage,
        Link,
        Path,
        Polygon,
        Polyline,
        Rectangle,
        ShadowLink,
        TextBlock
      };
      var index$5 = {
        __proto__: null,
        standard
      };
      const CornerTypes = {
        POINT: "point",
        CUBIC: "cubic",
        LINE: "line",
        GAP: "gap"
      };
      const DEFINED_CORNER_TYPES = Object.values(CornerTypes);
      const CORNER_RADIUS$1 = 10;
      const PRECISION$1 = 1;
      const straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {
        const {
          cornerType = CornerTypes.POINT,
          cornerRadius = CORNER_RADIUS$1,
          cornerPreserveAspectRatio = false,
          precision = PRECISION$1,
          raw = false
        } = opt;
        if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {
          throw new Error("Invalid `cornerType` provided to `straight` connector.");
        }
        let path2;
        if (cornerType === CornerTypes.POINT || !cornerRadius) {
          const points = [sourcePoint].concat(routePoints).concat([targetPoint]);
          const polyline = new Polyline$1(points);
          path2 = new Path$1(polyline);
        } else {
          path2 = new Path$1();
          path2.appendSegment(Path$1.createSegment("M", sourcePoint));
          let nextDistance;
          const routePointsLength = routePoints.length;
          for (let i = 0; i < routePointsLength; i++) {
            const curr = new Point(routePoints[i]);
            const prev = routePoints[i - 1] || sourcePoint;
            const next = routePoints[i + 1] || targetPoint;
            const prevDistance = nextDistance || curr.distance(prev) / 2;
            nextDistance = curr.distance(next) / 2;
            let startMove, endMove;
            if (!cornerPreserveAspectRatio) {
              startMove = -Math.min(cornerRadius, prevDistance);
              endMove = -Math.min(cornerRadius, nextDistance);
            } else {
              startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);
            }
            const cornerStart = curr.clone().move(prev, startMove).round(precision);
            const cornerEnd = curr.clone().move(next, endMove).round(precision);
            path2.appendSegment(Path$1.createSegment("L", cornerStart));
            switch (cornerType) {
              case CornerTypes.CUBIC: {
                const _132 = 1 / 3;
                const _232 = 2 / 3;
                const control1 = new Point(_132 * cornerStart.x + _232 * curr.x, _232 * curr.y + _132 * cornerStart.y);
                const control2 = new Point(_132 * cornerEnd.x + _232 * curr.x, _232 * curr.y + _132 * cornerEnd.y);
                path2.appendSegment(Path$1.createSegment("C", control1, control2, cornerEnd));
                break;
              }
              case CornerTypes.LINE: {
                path2.appendSegment(Path$1.createSegment("L", cornerEnd));
                break;
              }
              case CornerTypes.GAP: {
                path2.appendSegment(Path$1.createSegment("M", cornerEnd));
                break;
              }
            }
          }
          path2.appendSegment(Path$1.createSegment("L", targetPoint));
        }
        return raw ? path2 : path2.serialize();
      };
      var JUMP_SIZE = 5;
      var JUMP_TYPES = ["arc", "gap", "cubic"];
      var RADIUS = 0;
      var CLOSE_PROXIMITY_PADDING = 1;
      var IGNORED_CONNECTORS = ["smooth"];
      var _13 = 1 / 3;
      var _23 = 2 / 3;
      function sortPointsAscending(p1, p2) {
        let {
          x: x1,
          y: y1
        } = p1;
        let {
          x: x2,
          y: y2
        } = p2;
        if (x1 > x2) {
          let swap = x1;
          x1 = x2;
          x2 = swap;
          swap = y1;
          y1 = y2;
          y2 = swap;
        }
        if (y1 > y2) {
          let swap = x1;
          x1 = x2;
          x2 = swap;
          swap = y1;
          y1 = y2;
          y2 = swap;
        }
        return [new Point(x1, y1), new Point(x2, y2)];
      }
      function overlapExists(line1, line2) {
        const [{
          x: x1,
          y: y1
        }, {
          x: x2,
          y: y2
        }] = sortPointsAscending(line1.start, line1.end);
        const [{
          x: x3,
          y: y3
        }, {
          x: x4,
          y: y4
        }] = sortPointsAscending(line2.start, line2.end);
        const xMatch = x1 <= x4 && x3 <= x2;
        const yMatch = y1 <= y4 && y3 <= y2;
        return xMatch && yMatch;
      }
      function createLines(sourcePoint, targetPoint, route) {
        var points = [].concat(sourcePoint, route, targetPoint);
        return points.reduce(function(resultLines, point2, idx) {
          var nextPoint = points[idx + 1];
          if (nextPoint != null) {
            resultLines[idx] = line$1(point2, nextPoint);
          }
          return resultLines;
        }, []);
      }
      function setupUpdating(jumpOverLinkView) {
        var paper = jumpOverLinkView.paper;
        var updateList = paper._jumpOverUpdateList;
        if (updateList == null) {
          updateList = paper._jumpOverUpdateList = [];
          var graph = paper.model;
          graph.on("batch:stop", function() {
            if (this.hasActiveBatch()) return;
            updateJumpOver(paper);
          });
          graph.on("reset", function() {
            updateList = paper._jumpOverUpdateList = [];
          });
        }
        if (updateList.indexOf(jumpOverLinkView) < 0) {
          updateList.push(jumpOverLinkView);
          jumpOverLinkView.listenToOnce(jumpOverLinkView.model, "change:connector remove", function() {
            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);
          });
        }
      }
      function updateJumpOver(paper) {
        var updateList = paper._jumpOverUpdateList;
        for (var i = 0; i < updateList.length; i++) {
          const linkView = updateList[i];
          const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);
          linkView.requestUpdate(updateFlag);
        }
      }
      function findLineIntersections(line2, crossCheckLines) {
        return toArray$1(crossCheckLines).reduce(function(res, crossCheckLine) {
          var intersection2 = line2.intersection(crossCheckLine);
          if (intersection2) {
            res.push(intersection2);
          }
          return res;
        }, []);
      }
      function sortPoints(p1, p2) {
        return line$1(p1, p2).squaredLength();
      }
      function createJumps(line2, intersections, jumpSize) {
        return intersections.reduce(function(resultLines, point$1, idx) {
          if (point$1.skip === true) {
            return resultLines;
          }
          var lastLine = resultLines.pop() || line2;
          var jumpStart = point(point$1).move(lastLine.start, -jumpSize);
          var jumpEnd = point(point$1).move(lastLine.start, +jumpSize);
          var nextPoint = intersections[idx + 1];
          if (nextPoint != null) {
            var distance = jumpEnd.distance(nextPoint);
            if (distance <= jumpSize) {
              jumpEnd = nextPoint.move(lastLine.start, distance);
              nextPoint.skip = true;
            }
          } else {
            var endDistance = jumpStart.distance(lastLine.end);
            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
              resultLines.push(lastLine);
              return resultLines;
            }
          }
          var startDistance = jumpEnd.distance(lastLine.start);
          if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {
            resultLines.push(lastLine);
            return resultLines;
          }
          var jumpLine = line$1(jumpStart, jumpEnd);
          jumpLine.isJump = true;
          resultLines.push(line$1(lastLine.start, jumpStart), jumpLine, line$1(jumpEnd, lastLine.end));
          return resultLines;
        }, []);
      }
      function buildPath(lines, jumpSize, jumpType, radius) {
        var path2 = new Path$1();
        var segment;
        segment = Path$1.createSegment("M", lines[0].start);
        path2.appendSegment(segment);
        toArray$1(lines).forEach(function(line2, index2) {
          if (line2.isJump) {
            var angle, diff2;
            var control1, control2;
            if (jumpType === "arc") {
              angle = -90;
              diff2 = line2.start.difference(line2.end);
              var xAxisRotate = Number(diff2.x < 0 || diff2.x === 0 && diff2.y < 0);
              if (xAxisRotate) angle += 180;
              var midpoint = line2.midpoint();
              var centerLine = new Line(midpoint, line2.end).rotate(midpoint, angle);
              var halfLine;
              halfLine = new Line(line2.start, midpoint);
              control1 = halfLine.pointAt(2 / 3).rotate(line2.start, angle);
              control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);
              segment = Path$1.createSegment("C", control1, control2, centerLine.end);
              path2.appendSegment(segment);
              halfLine = new Line(midpoint, line2.end);
              control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);
              control2 = halfLine.pointAt(1 / 3).rotate(line2.end, -angle);
              segment = Path$1.createSegment("C", control1, control2, line2.end);
              path2.appendSegment(segment);
            } else if (jumpType === "gap") {
              segment = Path$1.createSegment("M", line2.end);
              path2.appendSegment(segment);
            } else if (jumpType === "cubic") {
              angle = line2.start.theta(line2.end);
              var xOffset = jumpSize * 0.6;
              var yOffset = jumpSize * 1.35;
              diff2 = line2.start.difference(line2.end);
              xAxisRotate = Number(diff2.x < 0 || diff2.x === 0 && diff2.y < 0);
              if (xAxisRotate) yOffset *= -1;
              control1 = Point(line2.start.x + xOffset, line2.start.y + yOffset).rotate(line2.start, angle);
              control2 = Point(line2.end.x - xOffset, line2.end.y + yOffset).rotate(line2.end, angle);
              segment = Path$1.createSegment("C", control1, control2, line2.end);
              path2.appendSegment(segment);
            }
          } else {
            var nextLine = lines[index2 + 1];
            if (radius == 0 || !nextLine || nextLine.isJump) {
              segment = Path$1.createSegment("L", line2.end);
              path2.appendSegment(segment);
            } else {
              buildRoundedSegment(radius, path2, line2.end, line2.start, nextLine.end);
            }
          }
        });
        return path2;
      }
      function buildRoundedSegment(offset2, path2, curr, prev, next) {
        var prevDistance = curr.distance(prev) / 2;
        var nextDistance = curr.distance(next) / 2;
        var startMove = -Math.min(offset2, prevDistance);
        var endMove = -Math.min(offset2, nextDistance);
        var roundedStart = curr.clone().move(prev, startMove).round();
        var roundedEnd = curr.clone().move(next, endMove).round();
        var control1 = new Point(_13 * roundedStart.x + _23 * curr.x, _23 * curr.y + _13 * roundedStart.y);
        var control2 = new Point(_13 * roundedEnd.x + _23 * curr.x, _23 * curr.y + _13 * roundedEnd.y);
        var segment;
        segment = Path$1.createSegment("L", roundedStart);
        path2.appendSegment(segment);
        segment = Path$1.createSegment("C", control1, control2, roundedEnd);
        path2.appendSegment(segment);
      }
      const jumpover = function(sourcePoint, targetPoint, route, opt) {
        setupUpdating(this);
        var raw = opt.raw;
        var jumpSize = opt.size || JUMP_SIZE;
        var jumpType = opt.jump && ("" + opt.jump).toLowerCase();
        var radius = opt.radius || RADIUS;
        var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;
        if (JUMP_TYPES.indexOf(jumpType) === -1) {
          jumpType = JUMP_TYPES[0];
        }
        var paper = this.paper;
        var graph = paper.model;
        var allLinks = graph.getLinks();
        if (allLinks.length === 1) {
          return buildPath(createLines(sourcePoint, targetPoint, route), jumpSize, jumpType, radius);
        }
        var thisModel = this.model;
        var thisIndex = allLinks.indexOf(thisModel);
        var defaultConnector = paper.options.defaultConnector || {};
        var links = allLinks.filter(function(link, idx) {
          var connector = link.get("connector") || defaultConnector;
          if (toArray$1(ignoreConnectors).includes(connector.name)) {
            return false;
          }
          if (idx > thisIndex) {
            return connector.name !== "jumpover";
          }
          return true;
        });
        var linkViews = links.map(function(link) {
          return paper.findViewByModel(link);
        });
        var thisLines = createLines(sourcePoint, targetPoint, route);
        var linkLines = linkViews.map(function(linkView) {
          if (linkView == null) {
            return [];
          }
          if (linkView === this) {
            return thisLines;
          }
          return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.route);
        }, this);
        var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {
          var intersections = links.reduce(function(res, link, i) {
            if (link !== thisModel) {
              const linkLinesToTest = linkLines[i].slice();
              const overlapIndex = linkLinesToTest.findIndex((line2) => overlapExists(thisLine, line2));
              if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {
                linkLinesToTest.splice(overlapIndex + 1, 1);
              }
              const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);
              res.push.apply(res, lineIntersections);
            }
            return res;
          }, []).sort(function(a, b) {
            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);
          });
          if (intersections.length > 0) {
            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));
          } else {
            resultLines.push(thisLine);
          }
          return resultLines;
        }, []);
        var path2 = buildPath(jumpingLines, jumpSize, jumpType, radius);
        return raw ? path2 : path2.serialize();
      };
      const normal$1 = function(sourcePoint, targetPoint, route = [], opt = {}) {
        const {
          raw
        } = opt;
        const localOpt = {
          cornerType: "point",
          raw
        };
        return straight(sourcePoint, targetPoint, route, localOpt);
      };
      const CORNER_RADIUS = 10;
      const PRECISION = 0;
      const rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {
        const {
          radius = CORNER_RADIUS,
          raw
        } = opt;
        const localOpt = {
          cornerType: "cubic",
          cornerRadius: radius,
          precision: PRECISION,
          raw
        };
        return straight(sourcePoint, targetPoint, route, localOpt);
      };
      const smooth = function(sourcePoint, targetPoint, route, opt) {
        var raw = opt && opt.raw;
        var path2;
        if (route && route.length !== 0) {
          var points = [sourcePoint].concat(route).concat([targetPoint]);
          var curves = Curve.throughPoints(points);
          path2 = new Path$1(curves);
        } else {
          path2 = new Path$1();
          var segment;
          segment = Path$1.createSegment("M", sourcePoint);
          path2.appendSegment(segment);
          if (Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y)) {
            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;
            segment = Path$1.createSegment("C", controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);
            path2.appendSegment(segment);
          } else {
            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;
            segment = Path$1.createSegment("C", sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);
            path2.appendSegment(segment);
          }
        }
        return raw ? path2 : path2.serialize();
      };
      const Directions$2 = {
        AUTO: "auto",
        HORIZONTAL: "horizontal",
        VERTICAL: "vertical",
        CLOSEST_POINT: "closest-point",
        OUTWARDS: "outwards"
      };
      const TangentDirections = {
        UP: "up",
        DOWN: "down",
        LEFT: "left",
        RIGHT: "right",
        AUTO: "auto",
        CLOSEST_POINT: "closest-point",
        OUTWARDS: "outwards"
      };
      const curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {
        const raw = Boolean(opt.raw);
        const {
          direction = Directions$2.AUTO,
          precision = 3
        } = opt;
        const options = {
          coeff: opt.distanceCoefficient || 0.6,
          angleTangentCoefficient: opt.angleTangentCoefficient || 80,
          tau: opt.tension || 0.5,
          sourceTangent: opt.sourceTangent ? new Point(opt.sourceTangent) : null,
          targetTangent: opt.targetTangent ? new Point(opt.targetTangent) : null,
          rotate: Boolean(opt.rotate)
        };
        if (typeof opt.sourceDirection === "string") options.sourceDirection = opt.sourceDirection;
        else if (typeof opt.sourceDirection === "number") options.sourceDirection = new Point(1, 0).rotate(null, opt.sourceDirection);
        else options.sourceDirection = opt.sourceDirection ? new Point(opt.sourceDirection).normalize() : null;
        if (typeof opt.targetDirection === "string") options.targetDirection = opt.targetDirection;
        else if (typeof opt.targetDirection === "number") options.targetDirection = new Point(1, 0).rotate(null, opt.targetDirection);
        else options.targetDirection = opt.targetDirection ? new Point(opt.targetDirection).normalize() : null;
        const completeRoute = [sourcePoint, ...route, targetPoint].map((p) => new Point(p));
        let sourceTangent;
        if (options.sourceTangent) {
          sourceTangent = options.sourceTangent;
        } else {
          const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);
          const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;
          const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();
          const angle = angleBetweenVectors(sourceDirection, pointsVector);
          if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);
          } else {
            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);
          }
        }
        let targetTangent;
        if (options.targetTangent) {
          targetTangent = options.targetTangent;
        } else {
          const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);
          const last2 = completeRoute.length - 1;
          const tangentLength = completeRoute[last2 - 1].distance(completeRoute[last2]) * options.coeff;
          const pointsVector = completeRoute[last2 - 1].difference(completeRoute[last2]).normalize();
          const angle = angleBetweenVectors(targetDirection, pointsVector);
          if (angle > Math.PI / 4) {
            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;
            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);
          } else {
            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);
          }
        }
        const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);
        const bezierCurves = catmullRomCurves.map((curve2) => catmullRomToBezier(curve2, options));
        const path2 = new Path$1(bezierCurves).round(precision);
        return raw ? path2 : path2.serialize();
      };
      curve.Directions = Directions$2;
      curve.TangentDirections = TangentDirections;
      function getHorizontalSourceDirection(linkView, route, options) {
        const {
          sourceBBox
        } = linkView;
        let sourceSide;
        let rotation;
        if (!linkView.sourceView) {
          if (sourceBBox.x > route[1].x) sourceSide = "right";
          else sourceSide = "left";
        } else {
          rotation = linkView.sourceView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
          } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
          }
        }
        let direction;
        switch (sourceSide) {
          case "left":
            direction = new Point(-1, 0);
            break;
          case "right":
          default:
            direction = new Point(1, 0);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getHorizontalTargetDirection(linkView, route, options) {
        const {
          targetBBox
        } = linkView;
        let targetSide;
        let rotation;
        if (!linkView.targetView) {
          if (targetBBox.x > route[route.length - 2].x) targetSide = "left";
          else targetSide = "right";
        } else {
          rotation = linkView.targetView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
          } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
          }
        }
        let direction;
        switch (targetSide) {
          case "left":
            direction = new Point(-1, 0);
            break;
          case "right":
          default:
            direction = new Point(1, 0);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getVerticalSourceDirection(linkView, route, options) {
        const {
          sourceBBox
        } = linkView;
        let sourceSide;
        let rotation;
        if (!linkView.sourceView) {
          if (sourceBBox.y > route[1].y) sourceSide = "bottom";
          else sourceSide = "top";
        } else {
          rotation = linkView.sourceView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
          } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
          }
        }
        let direction;
        switch (sourceSide) {
          case "top":
            direction = new Point(0, -1);
            break;
          case "bottom":
          default:
            direction = new Point(0, 1);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getVerticalTargetDirection(linkView, route, options) {
        const {
          targetBBox
        } = linkView;
        let targetSide;
        let rotation;
        if (!linkView.targetView) {
          if (targetBBox.y > route[route.length - 2].y) targetSide = "top";
          else targetSide = "bottom";
        } else {
          rotation = linkView.targetView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
          } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
          }
        }
        let direction;
        switch (targetSide) {
          case "top":
            direction = new Point(0, -1);
            break;
          case "bottom":
          default:
            direction = new Point(0, 1);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getAutoSourceDirection(linkView, route, options) {
        const {
          sourceBBox
        } = linkView;
        let sourceSide;
        let rotation;
        if (!linkView.sourceView) {
          sourceSide = sourceBBox.sideNearestToPoint(route[1]);
        } else {
          rotation = linkView.sourceView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);
            const sourcePoint = route[0].clone();
            sourcePoint.rotate(sourceBBox.center(), rotation);
            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);
          } else {
            sourceSide = sourceBBox.sideNearestToPoint(route[0]);
          }
        }
        let direction;
        switch (sourceSide) {
          case "top":
            direction = new Point(0, -1);
            break;
          case "bottom":
            direction = new Point(0, 1);
            break;
          case "right":
            direction = new Point(1, 0);
            break;
          case "left":
            direction = new Point(-1, 0);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getAutoTargetDirection(linkView, route, options) {
        const {
          targetBBox
        } = linkView;
        let targetSide;
        let rotation;
        if (!linkView.targetView) {
          targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);
        } else {
          rotation = linkView.targetView.model.angle();
          if (options.rotate && rotation) {
            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);
            const targetPoint = route[route.length - 1].clone();
            targetPoint.rotate(targetBBox.center(), rotation);
            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);
          } else {
            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);
          }
        }
        let direction;
        switch (targetSide) {
          case "top":
            direction = new Point(0, -1);
            break;
          case "bottom":
            direction = new Point(0, 1);
            break;
          case "right":
            direction = new Point(1, 0);
            break;
          case "left":
            direction = new Point(-1, 0);
            break;
        }
        if (options.rotate && rotation) {
          direction.rotate(null, -rotation);
        }
        return direction;
      }
      function getClosestPointSourceDirection(linkView, route, options) {
        return route[1].difference(route[0]).normalize();
      }
      function getClosestPointTargetDirection(linkView, route, options) {
        const last2 = route.length - 1;
        return route[last2 - 1].difference(route[last2]).normalize();
      }
      function getOutwardsSourceDirection(linkView, route, options) {
        const {
          sourceBBox
        } = linkView;
        const sourceCenter = sourceBBox.center();
        return route[0].difference(sourceCenter).normalize();
      }
      function getOutwardsTargetDirection(linkView, route, options) {
        const {
          targetBBox
        } = linkView;
        const targetCenter = targetBBox.center();
        return route[route.length - 1].difference(targetCenter).normalize();
      }
      function getSourceTangentDirection(linkView, route, direction, options) {
        if (options.sourceDirection) {
          switch (options.sourceDirection) {
            case TangentDirections.UP:
              return new Point(0, -1);
            case TangentDirections.DOWN:
              return new Point(0, 1);
            case TangentDirections.LEFT:
              return new Point(-1, 0);
            case TangentDirections.RIGHT:
              return new Point(1, 0);
            case TangentDirections.AUTO:
              return getAutoSourceDirection(linkView, route, options);
            case TangentDirections.CLOSEST_POINT:
              return getClosestPointSourceDirection(linkView, route, options);
            case TangentDirections.OUTWARDS:
              return getOutwardsSourceDirection(linkView, route, options);
            default:
              return options.sourceDirection;
          }
        }
        switch (direction) {
          case Directions$2.HORIZONTAL:
            return getHorizontalSourceDirection(linkView, route, options);
          case Directions$2.VERTICAL:
            return getVerticalSourceDirection(linkView, route, options);
          case Directions$2.CLOSEST_POINT:
            return getClosestPointSourceDirection(linkView, route, options);
          case Directions$2.OUTWARDS:
            return getOutwardsSourceDirection(linkView, route, options);
          case Directions$2.AUTO:
          default:
            return getAutoSourceDirection(linkView, route, options);
        }
      }
      function getTargetTangentDirection(linkView, route, direction, options) {
        if (options.targetDirection) {
          switch (options.targetDirection) {
            case TangentDirections.UP:
              return new Point(0, -1);
            case TangentDirections.DOWN:
              return new Point(0, 1);
            case TangentDirections.LEFT:
              return new Point(-1, 0);
            case TangentDirections.RIGHT:
              return new Point(1, 0);
            case TangentDirections.AUTO:
              return getAutoTargetDirection(linkView, route, options);
            case TangentDirections.CLOSEST_POINT:
              return getClosestPointTargetDirection(linkView, route, options);
            case TangentDirections.OUTWARDS:
              return getOutwardsTargetDirection(linkView, route, options);
            default:
              return options.targetDirection;
          }
        }
        switch (direction) {
          case Directions$2.HORIZONTAL:
            return getHorizontalTargetDirection(linkView, route, options);
          case Directions$2.VERTICAL:
            return getVerticalTargetDirection(linkView, route, options);
          case Directions$2.CLOSEST_POINT:
            return getClosestPointTargetDirection(linkView, route, options);
          case Directions$2.OUTWARDS:
            return getOutwardsTargetDirection(linkView, route, options);
          case Directions$2.AUTO:
          default:
            return getAutoTargetDirection(linkView, route, options);
        }
      }
      function rotateVector(vector, angle) {
        const cos2 = Math.cos(angle);
        const sin2 = Math.sin(angle);
        const x = cos2 * vector.x - sin2 * vector.y;
        const y = sin2 * vector.x + cos2 * vector.y;
        vector.x = x;
        vector.y = y;
      }
      function angleBetweenVectors(v1, v2) {
        let cos2 = v1.dot(v2) / (v1.magnitude() * v2.magnitude());
        if (cos2 < -1) cos2 = -1;
        if (cos2 > 1) cos2 = 1;
        return Math.acos(cos2);
      }
      function determinant(v1, v2) {
        return v1.x * v2.y - v1.y * v2.x;
      }
      function createCatmullRomCurves(points, sourceTangent, targetTangent, options) {
        const {
          tau,
          coeff
        } = options;
        const distances = [];
        const tangents = [];
        const catmullRomCurves = [];
        const n = points.length - 1;
        for (let i = 0; i < n; i++) {
          distances[i] = points[i].distance(points[i + 1]);
        }
        tangents[0] = sourceTangent;
        tangents[n] = targetTangent;
        for (let i = 1; i < n; i++) {
          let tpPrev;
          let tpNext;
          if (i === 1) {
            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);
          } else {
            tpPrev = points[i - 1].clone();
          }
          if (i === n - 1) {
            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);
          } else {
            tpNext = points[i + 1].clone();
          }
          const v1 = tpPrev.difference(points[i]).normalize();
          const v2 = tpNext.difference(points[i]).normalize();
          const vAngle = angleBetweenVectors(v1, v2);
          let rot = (Math.PI - vAngle) / 2;
          let t;
          const vectorDeterminant = determinant(v1, v2);
          let pointsDeterminant;
          pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));
          if (vectorDeterminant < 0) {
            rot = -rot;
          }
          if (vAngle < Math.PI / 2 && (rot < 0 && pointsDeterminant < 0 || rot > 0 && pointsDeterminant > 0)) {
            rot = rot - Math.PI;
          }
          t = v2.clone();
          rotateVector(t, rot);
          const t1 = t.clone();
          const t2 = t.clone();
          const scaleFactor1 = distances[i - 1] * coeff;
          const scaleFactor2 = distances[i] * coeff;
          t1.scale(scaleFactor1, scaleFactor1);
          t2.scale(scaleFactor2, scaleFactor2);
          tangents[i] = [t1, t2];
        }
        for (let i = 0; i < n; i++) {
          let p0;
          let p3;
          if (i === 0) {
            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);
          } else {
            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);
          }
          if (i === n - 1) {
            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);
          } else {
            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);
          }
          catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];
        }
        return catmullRomCurves;
      }
      function catmullRomToBezier(points, options) {
        const {
          tau
        } = options;
        const bcp1 = new Point();
        bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);
        bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);
        const bcp2 = new Point();
        bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);
        bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);
        return new Curve(points[1], bcp1, bcp2, points[2]);
      }
      var connectors = {
        __proto__: null,
        curve,
        jumpover,
        normal: normal$1,
        rounded,
        smooth,
        straight
      };
      var ViewBase = function(options) {
        this.cid = options && options.cid || uniqueId("view");
        this.preinitialize.apply(this, arguments);
        assign(this, pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events", "style"];
      assign(ViewBase.prototype, Events, {
        // The default `tagName` of a View's element is `"div"`.
        tagName: "div",
        // mvc.$ delegate for element lookup, scoped to DOM elements within the
        // current view. This should be preferred to global lookups where possible.
        $: function(selector) {
          return this.$el.find(selector);
        },
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the View
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // **render** is the core function that your view should override, in order
        // to populate its element (`this.el`), with the appropriate HTML. The
        // convention is for **render** to always return `this`.
        render: function() {
          return this;
        },
        // Remove this view by taking the element out of the DOM, and removing any
        // applicable Events listeners.
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        // Remove this view's element from the document and all event listeners
        // attached to it. Exposed for subclasses using an alternative DOM
        // manipulation API.
        _removeElement: function() {
          this.$el.remove();
        },
        // Change the view's element (`this.el` property) and re-delegate the
        // view's events on the new element.
        setElement: function(element) {
          this.undelegateEvents();
          this._setElement(element);
          this.delegateEvents();
          return this;
        },
        // Creates the `this.el` and `this.$el` references for this view using the
        // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$
        // context or an element. Subclasses can override this to utilize an
        // alternative DOM manipulation API and are only required to set the
        // `this.el` property.
        _setElement: function(el) {
          this.$el = el instanceof $ ? el : $(el);
          this.el = this.$el[0];
        },
        // Set callbacks, where `this.events` is a hash of
        //
        // *{"event selector": "callback"}*
        //
        //     {
        //       'mousedown .title':  'edit',
        //       'click .button':     'save',
        //       'click .open':       function(e) { ... }
        //     }
        //
        // pairs. Callbacks will be bound to the view, with `this` set properly.
        // Uses event delegation for efficiency.
        // Omitting the selector binds the event to `this.el`.
        delegateEvents: function(events) {
          events || (events = result(this, "events"));
          if (!events) return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!isFunction(method)) method = this[method];
            if (!method) continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], method.bind(this));
          }
          return this;
        },
        // Add a single event listener to the view's element (or a child element
        // using `selector`). This only works for delegate-able events: not `focus`,
        // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Clears all callbacks previously bound to the view by `delegateEvents`.
        // You usually don't need to use this, but may wish to if you have multiple
        // viewbases attached to the same DOM element.
        undelegateEvents: function() {
          if (this.$el) this.$el.off(".delegateEvents" + this.cid);
          return this;
        },
        // A finer-grained `undelegateEvents` for removing a single delegated event.
        // `selector` and `listener` are both optional.
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + ".delegateEvents" + this.cid, selector, listener);
          return this;
        },
        // Produces a DOM element to be assigned to your view. Exposed for
        // subclasses using an alternative DOM manipulation API.
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        // Ensure that the View has a DOM element to render into.
        // If `this.el` is a string, pass it through `$()`, take the first
        // matching element, and re-assign it to `el`. Otherwise, create
        // an element from the `id`, `className` and `tagName` properties.
        _ensureElement: function() {
          if (!this.el) {
            var attrs = assign({}, result(this, "attributes"));
            if (this.id) attrs.id = result(this, "id");
            if (this.className) attrs["class"] = result(this, "className");
            this.setElement(this._createElement(result(this, "tagName")));
            this._setAttributes(attrs);
          } else {
            this.setElement(result(this, "el"));
          }
        },
        // Set attributes from a hash on this view's element.  Exposed for
        // subclasses using an alternative DOM manipulation API.
        _setAttributes: function(attributes2) {
          this.$el.attr(attributes2);
        }
      });
      ViewBase.extend = extend;
      const views = {};
      const View = ViewBase.extend({
        options: {},
        theme: null,
        themeClassNamePrefix: addClassNamePrefix("theme-"),
        requireSetThemeOverride: false,
        defaultTheme: config$3.defaultTheme,
        children: null,
        childNodes: null,
        DETACHABLE: true,
        UPDATE_PRIORITY: 2,
        /** @deprecated is no longer used (moved to Paper) */
        FLAG_INSERT: 1 << 30,
        /** @deprecated is no longer used */
        FLAG_REMOVE: 1 << 29,
        /** @deprecated is no longer used */
        FLAG_INIT: 1 << 28,
        constructor: function(options) {
          this.requireSetThemeOverride = options && !!options.theme;
          this.options = assign({}, this.options, options);
          ViewBase.call(this, options);
        },
        initialize: function() {
          views[this.cid] = this;
          this.setTheme(this.options.theme || this.defaultTheme);
          this.init();
        },
        unmount: function() {
          if (this.svgElement) {
            this.vel.remove();
          } else {
            this.$el.remove();
          }
        },
        isMounted: function() {
          return this.el.parentNode !== null;
        },
        renderChildren: function(children2) {
          children2 || (children2 = result(this, "children"));
          if (children2) {
            var isSVG = this.svgElement;
            var namespace = V2.namespace[isSVG ? "svg" : "xhtml"];
            var doc = parseDOMJSON(children2, namespace);
            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);
            this.childNodes = doc.selectors;
          }
          return this;
        },
        findAttributeNode: function(attributeName, node) {
          let currentNode = node;
          while (currentNode && currentNode.nodeType === 1) {
            if (currentNode.getAttribute(attributeName)) return currentNode;
            if (currentNode === this.el) return null;
            currentNode = currentNode.parentNode;
          }
          return null;
        },
        findAttribute: function(attributeName, node) {
          const matchedNode = this.findAttributeNode(attributeName, node);
          return matchedNode && matchedNode.getAttribute(attributeName);
        },
        // Override the mvc ViewBase `_ensureElement()` method in order to create an
        // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.
        // Expose class name setter as a separate method.
        _ensureElement: function() {
          if (!this.el) {
            var tagName = result(this, "tagName");
            var attrs = assign({}, result(this, "attributes"));
            var style = assign({}, result(this, "style"));
            if (this.id) attrs.id = result(this, "id");
            this.setElement(this._createElement(tagName));
            this._setAttributes(attrs);
            this._setStyle(style);
          } else {
            this.setElement(result(this, "el"));
          }
          this._ensureElClassName();
        },
        _setAttributes: function(attrs) {
          if (this.svgElement) {
            this.vel.attr(attrs);
          } else {
            this.$el.attr(attrs);
          }
        },
        _setStyle: function(style) {
          this.$el.css(style);
        },
        _createElement: function(tagName) {
          if (this.svgElement) {
            return document.createElementNS(V2.namespace.svg, tagName);
          } else {
            return document.createElement(tagName);
          }
        },
        // Utilize an alternative DOM manipulation API by
        // adding an element reference wrapped in Vectorizer.
        _setElement: function(el) {
          this.$el = el instanceof $ ? el : $(el);
          this.el = this.$el[0];
          if (this.svgElement) this.vel = V2(this.el);
        },
        _ensureElClassName: function() {
          var className2 = result(this, "className");
          if (!className2) return;
          var prefixedClassName = addClassNamePrefix(className2);
          if (this.svgElement) {
            this.vel.removeClass(className2).addClass(prefixedClassName);
          } else {
            this.$el.removeClass(className2).addClass(prefixedClassName);
          }
        },
        init: function() {
        },
        onRender: function() {
        },
        confirmUpdate: function() {
          return 0;
        },
        setTheme: function(theme, opt) {
          opt = opt || {};
          if (this.theme && this.requireSetThemeOverride && !opt.override) {
            return this;
          }
          this.removeThemeClassName();
          this.addThemeClassName(theme);
          this.onSetTheme(
            this.theme,
            theme
            /* newTheme */
          );
          this.theme = theme;
          return this;
        },
        addThemeClassName: function(theme) {
          theme = theme || this.theme;
          if (!theme) return this;
          var className2 = this.themeClassNamePrefix + theme;
          if (this.svgElement) {
            this.vel.addClass(className2);
          } else {
            this.$el.addClass(className2);
          }
          return this;
        },
        removeThemeClassName: function(theme) {
          theme = theme || this.theme;
          var className2 = this.themeClassNamePrefix + theme;
          if (this.svgElement) {
            this.vel.removeClass(className2);
          } else {
            this.$el.removeClass(className2);
          }
          return this;
        },
        onSetTheme: function(oldTheme, newTheme) {
        },
        remove: function() {
          this.onRemove();
          this.undelegateDocumentEvents();
          views[this.cid] = null;
          ViewBase.prototype.remove.apply(this, arguments);
          return this;
        },
        onRemove: function() {
        },
        getEventNamespace: function() {
          return ".joint-event-ns-" + this.cid;
        },
        delegateElementEvents: function(element, events, data2) {
          if (!events) return this;
          data2 || (data2 = {});
          var eventNS = this.getEventNamespace();
          for (var eventName in events) {
            var method = events[eventName];
            if (typeof method !== "function") method = this[method];
            if (!method) continue;
            $(element).on(eventName + eventNS, data2, method.bind(this));
          }
          return this;
        },
        undelegateElementEvents: function(element) {
          $(element).off(this.getEventNamespace());
          return this;
        },
        delegateDocumentEvents: function(events, data2) {
          events || (events = result(this, "documentEvents"));
          return this.delegateElementEvents(document, events, data2);
        },
        undelegateDocumentEvents: function() {
          return this.undelegateElementEvents(document);
        },
        eventData: function(evt, data2) {
          if (!evt) throw new Error("eventData(): event object required.");
          var currentData = evt.data;
          var key = "__" + this.cid + "__";
          if (data2 === void 0) {
            if (!currentData) return {};
            return currentData[key] || {};
          }
          currentData || (currentData = evt.data = {});
          currentData[key] || (currentData[key] = {});
          assign(currentData[key], data2);
          return this;
        },
        stopPropagation: function(evt) {
          this.eventData(evt, {
            propagationStopped: true
          });
          return this;
        },
        isPropagationStopped: function(evt) {
          return !!this.eventData(evt).propagationStopped;
        }
      }, {
        extend: function() {
          var args = Array.from(arguments);
          var protoProps = args[0] && assign({}, args[0]) || {};
          var staticProps = args[1] && assign({}, args[1]) || {};
          var renderFn = protoProps.render || this.prototype && this.prototype.render || null;
          protoProps.render = function() {
            if (typeof renderFn === "function") {
              renderFn.apply(this, arguments);
            }
            if (this.render.__render__ === renderFn) {
              this.onRender();
            }
            return this;
          };
          protoProps.render.__render__ = renderFn;
          return ViewBase.extend.call(this, protoProps, staticProps);
        }
      });
      class Listener {
        constructor(...callbackArguments) {
          this.callbackArguments = callbackArguments;
        }
        listenTo(object, evt, ...args) {
          const {
            callbackArguments
          } = this;
          if (evt && typeof evt === "object") {
            const [context = null] = args;
            Object.entries(evt).forEach(([eventName, cb2]) => {
              if (typeof cb2 !== "function") return;
              if (context || callbackArguments.length > 0) cb2 = cb2.bind(context, ...callbackArguments);
              Events.listenTo.call(this, object, eventName, cb2);
            });
          } else if (typeof evt === "string" && typeof args[0] === "function") {
            let [cb2, context = null] = args;
            if (context || callbackArguments.length > 0) cb2 = cb2.bind(context, ...callbackArguments);
            Events.listenTo.call(this, object, evt, cb2);
          }
        }
        stopListening() {
          Events.stopListening.call(this);
        }
      }
      var Collection = function(models, options) {
        options || (options = {});
        this.preinitialize.apply(this, arguments);
        if (options.model) this.model = options.model;
        if (options.comparator !== void 0) this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models) this.reset(models, assign({
          silent: true
        }, options));
      };
      var setOptions = {
        add: true,
        remove: true,
        merge: true
      };
      var addOptions = {
        add: true,
        remove: false
      };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length2 = insert.length;
        var i;
        for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
        for (i = 0; i < length2; i++) array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++) array[i + length2 + at] = tail[i];
      };
      assign(Collection.prototype, Events, {
        // The default model for a collection is just a **Model**.
        // This should be overridden in most cases.
        model: Model,
        // preinitialize is an empty function by default. You can override it with a function
        // or object.  preinitialize will run before any instantiation logic is run in the Collection.
        preinitialize: function() {
        },
        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {
        },
        // The JSON representation of a Collection is an array of the
        // models' attributes.
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        // Add a model, or list of models to the set. `models` may be
        // Models or raw JavaScript objects to be converted to Models, or any
        // combination of the two.
        add: function(models, options) {
          return this.set(models, assign({
            merge: false
          }, options, addOptions));
        },
        // Remove a model, or a list of models from the set.
        remove: function(models, options) {
          options = assign({}, options);
          var singular = !Array.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = {
              added: [],
              merged: [],
              removed
            };
            this.trigger("update", this, options);
          }
          return singular ? removed[0] : removed;
        },
        // Update a collection by `set`-ing a new list of models, adding new ones,
        // removing models that are no longer present, and merging models that
        // already exist in the collection, as necessary. Similar to **Model#set**,
        // the core operation for updating the data contained by the collection.
        set: function(models, options) {
          if (models == null) return;
          options = assign({}, setOptions, options);
          var singular = !Array.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null) at = +at;
          if (at > this.length) at = this.length;
          if (at < 0) at += this.length + 1;
          var set2 = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge2 = options.merge;
          var remove2 = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = isString(this.comparator) ? this.comparator : null;
          var model, i;
          for (i = 0; i < models.length; i++) {
            model = models[i];
            var existing = this.get(model);
            if (existing) {
              if (merge2 && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort) sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set2.push(existing);
              }
              models[i] = existing;
            } else if (add) {
              model = models[i] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set2.push(model);
              }
            }
          }
          if (remove2) {
            for (i = 0; i < this.length; i++) {
              model = this.models[i];
              if (!modelMap[model.cid]) toRemove.push(model);
            }
            if (toRemove.length) this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove2;
          if (set2.length && replace) {
            orderChanged = this.length !== set2.length || this.models.some(function(m, index2) {
              return m !== set2[index2];
            });
            this.models.length = 0;
            splice(this.models, set2, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable) sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort) this.sort({
            silent: true
          });
          if (!options.silent) {
            for (i = 0; i < toAdd.length; i++) {
              if (at != null) options.index = at + i;
              model = toAdd[i];
              model.trigger(model.eventPrefix + "add", model, this, options);
            }
            if (sort || orderChanged) this.trigger("sort", this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger("update", this, options);
            }
          }
          return singular ? models[0] : models;
        },
        // When you have more items than you want to add or remove individually,
        // you can reset the entire set with a new list of models, without firing
        // any granular `add` or `remove` events. Fires `reset` when finished.
        // Useful for bulk operations and optimizations.
        reset: function(models, options) {
          options = options ? clone$1(options) : {};
          for (var i = 0; i < this.models.length; i++) {
            this._removeReference(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, assign({
            silent: true
          }, options));
          if (!options.silent) this.trigger("reset", this, options);
          return models;
        },
        // Add a model to the end of the collection.
        push: function(model, options) {
          return this.add(model, assign({
            at: this.length
          }, options));
        },
        // Remove a model from the end of the collection.
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        // Add a model to the beginning of the collection.
        unshift: function(model, options) {
          return this.add(model, assign({
            at: 0
          }, options));
        },
        // Remove a model from the beginning of the collection.
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        // Slice out a sub-array of models from the collection.
        slice: function() {
          return Array.prototype.slice.apply(this.models, arguments);
        },
        // Get a model from the set by id, cid, model object with id or cid
        // properties, or an attributes object that is transformed through modelId.
        get: function(obj) {
          if (obj == null) return void 0;
          return this._byId.get(obj) || this._byId.get(this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)) || obj.cid && this._byId.get(obj.cid);
        },
        // Returns `true` if the model is in the collection.
        has: function(obj) {
          return this.get(obj) != null;
        },
        // Get the model at the given index.
        at: function(index2) {
          if (index2 < 0) index2 += this.length;
          return this.models[index2];
        },
        // Force the collection to re-sort itself. You don't need to call this under
        // normal circumstances, as the set will maintain sort order as each item
        // is added.
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator) throw new Error("Cannot sort a set without a comparator");
          options || (options = {});
          var length2 = comparator.length;
          if (isFunction(comparator)) comparator = comparator.bind(this);
          if (length2 === 1 || isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent) this.trigger("sort", this, options);
          return this;
        },
        // Create a new collection with an identical list of models as this one.
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        // Define how to uniquely identify models in the collection.
        modelId: function(attrs, idAttribute) {
          var _this$model$prototype;
          return attrs[idAttribute || ((_this$model$prototype = this.model.prototype) === null || _this$model$prototype === void 0 ? void 0 : _this$model$prototype.idAttribute) || "id"];
        },
        // Get an iterator of all models in this collection.
        values: function() {
          return new CollectionIterator(this, ITERATOR_VALUES);
        },
        // Get an iterator of all model IDs in this collection.
        keys: function() {
          return new CollectionIterator(this, ITERATOR_KEYS);
        },
        // Get an iterator of all [ID, model] tuples in this collection.
        entries: function() {
          return new CollectionIterator(this, ITERATOR_KEYSVALUES);
        },
        // Iterate over elements of the collection, and invoke fn for each element
        each: function(fn2, context) {
          this.models.forEach(fn2, context);
        },
        // Iterate over elements of collection, and return an array of all elements fn returns truthy for
        filter: function(fn2, context) {
          return this.models.filter(fn2, context);
        },
        find: function(fn2, context) {
          return this.models.find(fn2, context);
        },
        findIndex: function(fn2, context) {
          return this.models.findIndex(fn2, context);
        },
        // Return the first model of the collection
        first: function() {
          return this.models[0];
        },
        // Return true if value is in the collection
        includes: function(value) {
          return this.models.includes(value);
        },
        // Return the last model of the collection
        last: function() {
          return this.models[this.models.length - 1];
        },
        // Return true if collection has no elements
        isEmpty: function() {
          return !this.models.length;
        },
        // Create an array of values by running each element in the collection through fn
        map: function(fn2, context) {
          return this.models.map(fn2, context);
        },
        // Runs "reducer" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value
        reduce: function(fn2, initAcc = this.first()) {
          return this.models.reduce(fn2, initAcc);
        },
        // Private method to reset all internal state. Called when the collection
        // is first initialized or reset.
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = /* @__PURE__ */ new Map();
        },
        // Prepare a hash of attributes (or other model) to be added to this
        // collection.
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!options.dry && !attrs.collection) attrs.collection = this;
            return attrs;
          }
          options = options ? clone$1(options) : {};
          if (!options.dry) options.collection = this;
          var model;
          if (this.model.prototype) {
            model = new this.model(attrs, options);
          } else {
            model = this.model(attrs, options);
          }
          if (!model.validationError) return model;
          this.trigger("invalid", this, model.validationError, options);
          return false;
        },
        // Internal method called by both remove and set.
        _removeModels: function(models, options) {
          var removed = [];
          for (var i = 0; i < models.length; i++) {
            var model = this.get(models[i]);
            if (!model) continue;
            var index2 = this.models.indexOf(model);
            this.models.splice(index2, 1);
            this.length--;
            this._byId.delete(model.cid);
            var id2 = this.modelId(model.attributes, model.idAttribute);
            if (id2 != null) this._byId.delete(id2);
            if (!options.silent) {
              options.index = index2;
              model.trigger(model.eventPrefix + "remove", model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          if (models.length > 0 && !options.silent) delete options.index;
          return removed;
        },
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel: function(model) {
          return model instanceof Model;
        },
        // Internal method to create a model's ties to a collection.
        _addReference: function(model, options) {
          this._byId.set(model.cid, model);
          var id2 = this.modelId(model.attributes, model.idAttribute);
          if (id2 != null) this._byId.set(id2, model);
          model.on("all", this._onModelEvent, this);
        },
        // Internal method to sever a model's ties to a collection.
        _removeReference: function(model, options) {
          this._byId.delete(model.cid);
          var id2 = this.modelId(model.attributes, model.idAttribute);
          if (id2 != null) this._byId.delete(id2);
          if (!options.dry && this === model.collection) delete model.collection;
          model.off("all", this._onModelEvent, this);
        },
        // Internal method called every time a model in the set fires an event.
        // Sets need to update their indexes when models change ids. All other
        // events simply proxy through. "add" and "remove" events that originate
        // in other collections are ignored.
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === model.eventPrefix + "add" || event === model.eventPrefix + "remove") && collection !== this) return;
            if (event === "changeId") {
              var prevId = this.modelId(model.previousAttributes(), model.idAttribute);
              var id2 = this.modelId(model.attributes, model.idAttribute);
              if (prevId != null) this._byId.delete(prevId);
              if (id2 != null) this._byId.set(id2, model);
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var $$iterator = typeof Symbol === "function" && Symbol.iterator;
      if ($$iterator) {
        Collection.prototype[$$iterator] = Collection.prototype.values;
      }
      var CollectionIterator = function(collection, kind) {
        this._collection = collection;
        this._kind = kind;
        this._index = 0;
      };
      var ITERATOR_VALUES = 1;
      var ITERATOR_KEYS = 2;
      var ITERATOR_KEYSVALUES = 3;
      if ($$iterator) {
        CollectionIterator.prototype[$$iterator] = function() {
          return this;
        };
      }
      CollectionIterator.prototype.next = function() {
        if (this._collection) {
          if (this._index < this._collection.length) {
            var model = this._collection.at(this._index);
            this._index++;
            var value;
            if (this._kind === ITERATOR_VALUES) {
              value = model;
            } else {
              var id2 = this._collection.modelId(model.attributes, model.idAttribute);
              if (this._kind === ITERATOR_KEYS) {
                value = id2;
              } else {
                value = [id2, model];
              }
            }
            return {
              value,
              done: false
            };
          }
          this._collection = void 0;
        }
        return {
          value: void 0,
          done: true
        };
      };
      var collectionMethods = {
        toArray: 1,
        sortBy: 3
      };
      var config$2 = [Collection, collectionMethods, "models"];
      function addMethods(config2) {
        var Base = config2[0], methods2 = config2[1], attribute = config2[2];
        const methodsToAdd = {
          sortBy,
          toArray: toArray$1
        };
        addMethodsUtil(Base, methodsToAdd, methods2, attribute);
      }
      addMethods(config$2);
      Collection.extend = extend;
      var index$4 = {
        __proto__: null,
        $,
        Collection,
        Data,
        Event,
        Events,
        Listener,
        Model,
        View,
        ViewBase,
        views
      };
      function toArray(obj) {
        if (!obj) return [];
        if (Array.isArray(obj)) return obj;
        return [obj];
      }
      const HighlighterView = View.extend({
        tagName: "g",
        svgElement: true,
        className: "highlight",
        HIGHLIGHT_FLAG: 1,
        UPDATE_PRIORITY: 3,
        DETACHABLE: false,
        UPDATABLE: true,
        MOUNTABLE: true,
        cellView: null,
        nodeSelector: null,
        node: null,
        updateRequested: false,
        postponedUpdate: false,
        transformGroup: null,
        detachedTransformGroup: null,
        requestUpdate(cellView, nodeSelector) {
          const {
            paper
          } = cellView;
          this.cellView = cellView;
          this.nodeSelector = nodeSelector;
          if (paper) {
            this.updateRequested = true;
            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
          }
        },
        confirmUpdate() {
          this.updateRequested = false;
          const {
            cellView,
            nodeSelector
          } = this;
          if (cellView.isMounted()) {
            this.update(cellView, nodeSelector);
            this.mount();
            this.transform();
          } else {
            this.postponedUpdate = true;
          }
          return 0;
        },
        findNode(cellView, nodeSelector = null) {
          let el;
          if (typeof nodeSelector === "string") {
            el = cellView.findNode(nodeSelector);
          } else if (isPlainObject(nodeSelector)) {
            const isLink = cellView.model.isLink();
            const {
              label = null,
              port,
              selector
            } = nodeSelector;
            if (isLink && label !== null) {
              el = cellView.findLabelNode(label, selector);
            } else if (!isLink && port) {
              el = cellView.findPortNode(port, selector);
            } else {
              el = cellView.findNode(selector);
            }
          } else if (nodeSelector) {
            el = V2.toNode(nodeSelector);
            if (!(el instanceof SVGElement) || !cellView.el.contains(el)) el = null;
          }
          return el ? el : null;
        },
        getNodeMatrix(cellView, node) {
          const {
            options
          } = this;
          const {
            layer
          } = options;
          const {
            rotatableNode
          } = cellView;
          const nodeMatrix = cellView.getNodeMatrix(node);
          if (rotatableNode) {
            if (layer) {
              if (rotatableNode.contains(node)) {
                return nodeMatrix;
              }
              return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);
            } else {
              return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);
            }
          }
          return nodeMatrix;
        },
        mount() {
          const {
            MOUNTABLE,
            cellView,
            el,
            options,
            transformGroup,
            detachedTransformGroup,
            postponedUpdate,
            nodeSelector
          } = this;
          if (!MOUNTABLE || transformGroup) return;
          if (postponedUpdate) {
            this.update(cellView, nodeSelector);
            this.transform();
            return;
          }
          const {
            paper
          } = cellView;
          const {
            layer: layerName,
            z
          } = options;
          if (layerName) {
            let vGroup;
            if (detachedTransformGroup) {
              vGroup = detachedTransformGroup;
              this.detachedTransformGroup = null;
            } else {
              vGroup = V2("g").addClass("highlight-transform").append(el);
            }
            this.transformGroup = vGroup;
            paper.getLayerView(layerName).insertSortedNode(vGroup.node, z);
          } else {
            const children2 = cellView.el.children;
            const index2 = Math.max(z, 0);
            const beforeChild = children2[index2];
            const toBeInserted = isNumber(z) && beforeChild;
            const isElementAtTargetPosition = toBeInserted ? el === beforeChild : !el.nextElementSibling;
            if (el.parentNode && isElementAtTargetPosition) return;
            if (toBeInserted) {
              cellView.el.insertBefore(el, beforeChild);
            } else {
              cellView.el.appendChild(el);
            }
          }
        },
        unmount() {
          const {
            MOUNTABLE,
            transformGroup,
            vel,
            options
          } = this;
          if (!MOUNTABLE) return;
          if (options.layer) {
            if (!transformGroup) return;
            this.transformGroup = null;
            this.detachedTransformGroup = transformGroup;
            transformGroup.remove();
          } else {
            vel.remove();
          }
        },
        transform() {
          const {
            transformGroup,
            cellView,
            updateRequested
          } = this;
          if (!transformGroup || cellView.model.isLink() || updateRequested) return;
          const translateMatrix = cellView.getRootTranslateMatrix();
          const rotateMatrix = cellView.getRootRotateMatrix();
          const transformMatrix = translateMatrix.multiply(rotateMatrix);
          transformGroup.attr("transform", V2.matrixToTransformString(transformMatrix));
        },
        update() {
          const {
            node: prevNode,
            cellView,
            nodeSelector,
            updateRequested,
            id: id2
          } = this;
          if (updateRequested) return;
          this.postponedUpdate = false;
          const node = this.node = this.findNode(cellView, nodeSelector);
          if (prevNode) {
            this.unhighlight(cellView, prevNode);
          }
          if (node) {
            this.highlight(cellView, node);
            this.mount();
          } else {
            this.unmount();
            cellView.notify("cell:highlight:invalid", id2, this);
          }
        },
        onRemove() {
          const {
            node,
            cellView,
            id: id2,
            constructor
          } = this;
          if (node) {
            this.unhighlight(cellView, node);
          }
          this.unmount();
          constructor._removeRef(cellView, id2);
        },
        highlight(_cellView, _node) {
        },
        unhighlight(_cellView, _node) {
        },
        // Update Attributes
        listenToUpdateAttributes(cellView) {
          const attributes2 = result(this, "UPDATE_ATTRIBUTES");
          if (!Array.isArray(attributes2) || attributes2.length === 0) return;
          this.listenTo(cellView.model, "change", this.onCellAttributeChange);
        },
        onCellAttributeChange() {
          const {
            cellView
          } = this;
          if (!cellView) return;
          const {
            model,
            paper
          } = cellView;
          const attributes2 = result(this, "UPDATE_ATTRIBUTES");
          if (!attributes2.some((attribute) => model.hasChanged(attribute))) return;
          paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);
        }
      }, {
        _views: {},
        // Used internally by CellView highlight()
        highlight: function(cellView, node, opt) {
          const id2 = this.uniqueId(node, opt);
          this.add(cellView, node, id2, opt);
        },
        // Used internally by CellView unhighlight()
        unhighlight: function(cellView, node, opt) {
          const id2 = this.uniqueId(node, opt);
          this.remove(cellView, id2);
        },
        get(cellView, id2 = null) {
          const {
            cid
          } = cellView;
          const {
            _views
          } = this;
          const refs = _views[cid];
          if (id2 === null) {
            const views2 = [];
            if (!refs) return views2;
            for (let hid in refs) {
              const ref = refs[hid];
              if (ref instanceof this) {
                views2.push(ref);
              }
            }
            return views2;
          } else {
            if (!refs) return null;
            if (id2 in refs) {
              const ref = refs[id2];
              if (ref instanceof this) return ref;
            }
            return null;
          }
        },
        // Check if the cellView has a highlighter with the given `id`.
        // If no `id` is provided, it checks if the cellView has any highlighter.
        has(cellView, id2 = null) {
          const {
            cid
          } = cellView;
          const {
            _views
          } = this;
          const refs = _views[cid];
          if (!refs) return false;
          if (id2 === null) {
            for (let hid in refs) {
              if (refs[hid] instanceof this) return true;
            }
            return false;
          } else {
            if (id2 in refs) {
              if (refs[id2] instanceof this) return true;
            }
            return false;
          }
        },
        add(cellView, nodeSelector, id2, opt = {}) {
          if (!id2) throw new Error("dia.HighlighterView: An ID required.");
          const previousView = HighlighterView.get(cellView, id2);
          if (previousView) previousView.remove();
          const view = new this(opt);
          view.id = id2;
          this._addRef(cellView, id2, view);
          view.requestUpdate(cellView, nodeSelector);
          view.listenToUpdateAttributes(cellView);
          return view;
        },
        _addRef(cellView, id2, view) {
          const {
            cid
          } = cellView;
          const {
            _views
          } = this;
          let refs = _views[cid];
          if (!refs) refs = _views[cid] = {};
          refs[id2] = view;
        },
        _removeRef(cellView, id2) {
          const {
            cid
          } = cellView;
          const {
            _views
          } = this;
          const refs = _views[cid];
          if (!refs) return;
          if (id2) delete refs[id2];
          for (let _ in refs) return;
          delete _views[cid];
        },
        remove(cellView, id2 = null) {
          toArray(this.get(cellView, id2)).forEach((view) => {
            view.remove();
          });
        },
        getAll(paper, id2 = null) {
          const views2 = [];
          const {
            _views
          } = this;
          for (let cid in _views) {
            for (let hid in _views[cid]) {
              const view = _views[cid][hid];
              if (view.cellView.paper === paper && view instanceof this && (id2 === null || hid === id2)) {
                views2.push(view);
              }
            }
          }
          return views2;
        },
        removeAll(paper, id2 = null) {
          this.getAll(paper, id2).forEach((view) => view.remove());
        },
        update(cellView, id2 = null, dirty = false) {
          toArray(this.get(cellView, id2)).forEach((view) => {
            if (dirty || view.UPDATABLE) view.update();
          });
        },
        transform(cellView, id2 = null) {
          toArray(this.get(cellView, id2)).forEach((view) => {
            if (view.UPDATABLE) view.transform();
          });
        },
        unmount(cellView, id2 = null) {
          toArray(this.get(cellView, id2)).forEach((view) => view.unmount());
        },
        mount(cellView, id2 = null) {
          toArray(this.get(cellView, id2)).forEach((view) => view.mount());
        },
        uniqueId(node, opt = "") {
          return V2.ensureId(node) + JSON.stringify(opt);
        }
      });
      const stroke$1 = HighlighterView.extend({
        tagName: "path",
        className: "highlight-stroke",
        attributes: {
          "pointer-events": "none",
          "fill": "none"
        },
        options: {
          padding: 3,
          rx: 0,
          ry: 0,
          useFirstSubpath: false,
          attrs: {
            "stroke-width": 3,
            "stroke": "#FEB663"
          }
        },
        getPathData(cellView, node) {
          const {
            options
          } = this;
          const {
            useFirstSubpath
          } = options;
          let d;
          try {
            const vNode = V2(node);
            d = vNode.convertToPathData().trim();
            if (vNode.tagName() === "PATH" && useFirstSubpath) {
              const secondSubpathIndex = d.search(/.M/i) + 1;
              if (secondSubpathIndex > 0) {
                d = d.substr(0, secondSubpathIndex);
              }
            }
          } catch {
            const nodeBBox = cellView.getNodeBoundingRect(node);
            d = V2.rectToPath(assign({}, options, nodeBBox.toJSON()));
          }
          return d;
        },
        highlightConnection(cellView) {
          this.vel.attr("d", cellView.getSerializedConnection());
        },
        highlightNode(cellView, node) {
          const {
            vel,
            options
          } = this;
          const {
            padding,
            layer
          } = options;
          let highlightMatrix = this.getNodeMatrix(cellView, node);
          if (padding) {
            if (!layer && node === cellView.el) {
              vel.remove();
            }
            let nodeBBox = cellView.getNodeBoundingRect(node);
            const cx = nodeBBox.x + nodeBBox.width / 2;
            const cy = nodeBBox.y + nodeBBox.height / 2;
            nodeBBox = V2.transformRect(nodeBBox, highlightMatrix);
            const width2 = Math.max(nodeBBox.width, 1);
            const height2 = Math.max(nodeBBox.height, 1);
            const sx = (width2 + padding) / width2;
            const sy = (height2 + padding) / height2;
            const paddingMatrix = V2.createSVGMatrix({
              a: sx,
              b: 0,
              c: 0,
              d: sy,
              e: cx - sx * cx,
              f: cy - sy * cy
            });
            highlightMatrix = highlightMatrix.multiply(paddingMatrix);
          }
          vel.attr({
            "d": this.getPathData(cellView, node),
            "transform": V2.matrixToTransformString(highlightMatrix)
          });
        },
        highlight(cellView, node) {
          const {
            vel,
            options
          } = this;
          vel.attr(options.attrs);
          if (options.nonScalingStroke) {
            vel.attr("vector-effect", "non-scaling-stroke");
          }
          if (cellView.isNodeConnection(node)) {
            this.highlightConnection(cellView);
          } else {
            this.highlightNode(cellView, node);
          }
        }
      });
      const MASK_CLIP = 20;
      function forEachDescendant(vel, fn2) {
        const descendants = vel.children();
        while (descendants.length > 0) {
          const descendant = descendants.shift();
          if (fn2(descendant)) {
            descendants.push(...descendant.children());
          }
        }
      }
      const mask = HighlighterView.extend({
        tagName: "rect",
        className: "highlight-mask",
        attributes: {
          "pointer-events": "none"
        },
        options: {
          padding: 3,
          maskClip: MASK_CLIP,
          deep: false,
          attrs: {
            "stroke": "#FEB663",
            "stroke-width": 3,
            "stroke-linecap": "butt",
            "stroke-linejoin": "miter"
          }
        },
        VISIBLE: "white",
        INVISIBLE: "black",
        MASK_ROOT_ATTRIBUTE_BLACKLIST: ["marker-start", "marker-end", "marker-mid", "transform", "stroke-dasharray", "class"],
        MASK_CHILD_ATTRIBUTE_BLACKLIST: ["stroke", "fill", "stroke-width", "stroke-opacity", "stroke-dasharray", "fill-opacity", "marker-start", "marker-end", "marker-mid", "class"],
        // TODO: change the list to a function callback
        MASK_REPLACE_TAGS: ["FOREIGNOBJECT", "IMAGE", "USE", "TEXT", "TSPAN", "TEXTPATH"],
        // TODO: change the list to a function callback
        MASK_REMOVE_TAGS: ["TEXT", "TSPAN", "TEXTPATH"],
        transformMaskChild(cellView, childEl) {
          const {
            MASK_CHILD_ATTRIBUTE_BLACKLIST,
            MASK_REPLACE_TAGS,
            MASK_REMOVE_TAGS
          } = this;
          const childTagName = childEl.tagName();
          if (!V2.isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {
            childEl.remove();
            return false;
          }
          if (MASK_REPLACE_TAGS.includes(childTagName)) {
            const originalChild = cellView.vel.findOne(`#${childEl.id}`);
            if (originalChild) {
              const {
                node: originalNode
              } = originalChild;
              let childBBox = cellView.getNodeBoundingRect(originalNode);
              if (cellView.model.isElement()) {
                childBBox = V2.transformRect(childBBox, cellView.getNodeMatrix(originalNode));
              }
              const replacement2 = V2("rect", childBBox.toJSON());
              const {
                x: ox,
                y: oy
              } = childBBox.center();
              const {
                angle,
                cx = ox,
                cy = oy
              } = originalChild.rotate();
              if (angle) replacement2.rotate(angle, cx, cy);
              childEl.parent().append(replacement2);
            }
            childEl.remove();
            return false;
          }
          MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach((attrName) => {
            if (attrName === "fill" && childEl.attr("fill") === "none") return;
            childEl.removeAttr(attrName);
          });
          return true;
        },
        transformMaskRoot(_cellView, rootEl) {
          const {
            MASK_ROOT_ATTRIBUTE_BLACKLIST
          } = this;
          MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach((attrName) => {
            rootEl.removeAttr(attrName);
          });
        },
        getMaskShape(cellView, vel) {
          const {
            options,
            MASK_REPLACE_TAGS
          } = this;
          const {
            deep
          } = options;
          const tagName = vel.tagName();
          let maskRoot;
          if (tagName === "G") {
            if (!deep) return null;
            maskRoot = vel.clone();
            forEachDescendant(maskRoot, (maskChild) => this.transformMaskChild(cellView, maskChild));
          } else {
            if (MASK_REPLACE_TAGS.includes(tagName)) return null;
            maskRoot = vel.clone();
          }
          this.transformMaskRoot(cellView, maskRoot);
          return maskRoot;
        },
        getMaskId() {
          return `highlight-mask-${this.cid}`;
        },
        getMask(cellView, vNode) {
          const {
            VISIBLE,
            INVISIBLE,
            options
          } = this;
          const {
            padding,
            attrs
          } = options;
          const strokeWidth = parseFloat(V2("g").attr(attrs).attr("stroke-width"));
          const hasNodeFill = vNode.attr("fill") !== "none";
          let magnetStrokeWidth = parseFloat(vNode.attr("stroke-width"));
          if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;
          const minStrokeWidth = magnetStrokeWidth + padding * 2;
          const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;
          let maskEl = this.getMaskShape(cellView, vNode);
          if (!maskEl) {
            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);
            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);
            maskEl = V2("rect", nodeBBox.toJSON());
          }
          maskEl.attr(attrs);
          return V2("mask", {
            "id": this.getMaskId()
          }).append([maskEl.clone().attr({
            "fill": hasNodeFill ? VISIBLE : "none",
            "stroke": VISIBLE,
            "stroke-width": maxStrokeWidth
          }), maskEl.clone().attr({
            "fill": hasNodeFill ? INVISIBLE : "none",
            "stroke": INVISIBLE,
            "stroke-width": minStrokeWidth
          })]);
        },
        removeMask(paper) {
          const maskNode = paper.svg.getElementById(this.getMaskId());
          if (maskNode) {
            paper.defs.removeChild(maskNode);
          }
        },
        addMask(paper, maskEl) {
          paper.defs.appendChild(maskEl.node);
        },
        highlight(cellView, node) {
          const {
            options,
            vel
          } = this;
          const {
            padding,
            attrs,
            maskClip = MASK_CLIP,
            layer
          } = options;
          const color = "stroke" in attrs ? attrs["stroke"] : "#000000";
          if (!layer && node === cellView.el) {
            vel.remove();
          }
          const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);
          const highlightMatrix = this.getNodeMatrix(cellView, node);
          const maskEl = this.getMask(cellView, V2(node));
          this.addMask(cellView.paper, maskEl);
          vel.attr(highlighterBBox.toJSON());
          vel.attr({
            "transform": V2.matrixToTransformString(highlightMatrix),
            "mask": `url(#${maskEl.id})`,
            "fill": color
          });
        },
        unhighlight(cellView) {
          this.removeMask(cellView.paper);
        }
      });
      const opacity = HighlighterView.extend({
        UPDATABLE: false,
        MOUNTABLE: false,
        highlight: function(_cellView, node) {
          const {
            alphaValue = 0.3
          } = this.options;
          node.style.opacity = alphaValue;
        },
        unhighlight: function(_cellView, node) {
          node.style.opacity = "";
        }
      });
      const className = addClassNamePrefix("highlighted");
      const addClass = HighlighterView.extend({
        UPDATABLE: false,
        MOUNTABLE: false,
        options: {
          className
        },
        highlight: function(_cellView, node) {
          V2(node).addClass(this.options.className);
        },
        unhighlight: function(_cellView, node) {
          V2(node).removeClass(this.options.className);
        }
      }, {
        // Backwards Compatibility
        className
      });
      const Directions$1 = {
        ROW: "row",
        COLUMN: "column"
      };
      const list = HighlighterView.extend({
        tagName: "g",
        MOUNTABLE: true,
        UPDATE_ATTRIBUTES: function() {
          return [this.options.attribute];
        },
        _prevItems: null,
        highlight(elementView, node) {
          const element = elementView.model;
          const {
            attribute,
            size = 20,
            gap = 5,
            direction = Directions$1.ROW
          } = this.options;
          if (!attribute) throw new Error("List: attribute is required");
          const normalizedSize = typeof size === "number" ? {
            width: size,
            height: size
          } : size;
          const isRowDirection = direction === Directions$1.ROW;
          const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;
          let items = element.get(attribute);
          if (!Array.isArray(items)) items = [];
          const prevItems = this._prevItems || [];
          const comparison = items.map((item, index2) => isEqual(prevItems[index2], items[index2]));
          if (prevItems.length !== items.length || comparison.some((unchanged) => !unchanged)) {
            const prevEls = this.vel.children();
            const itemsEls = items.map((item, index2) => {
              const prevEl = index2 in prevEls ? prevEls[index2].node : null;
              if (comparison[index2]) return prevEl;
              const itemEl = this.createListItem(item, normalizedSize, prevEl);
              if (!itemEl) return null;
              if (!(itemEl instanceof SVGElement)) throw new Error("List: item must be an SVGElement");
              itemEl.dataset.index = index2;
              itemEl.dataset.attribute = attribute;
              const offset2 = index2 * (itemWidth + gap);
              itemEl.setAttribute("transform", isRowDirection ? `translate(${offset2}, 0)` : `translate(0, ${offset2})`);
              return itemEl;
            });
            this.vel.empty().append(itemsEls);
            this._prevItems = items;
          }
          const itemsCount = items.length;
          const length2 = itemsCount === 0 ? 0 : itemsCount * itemWidth + (itemsCount - 1) * gap;
          const listSize = isRowDirection ? {
            width: length2,
            height: normalizedSize.height
          } : {
            width: normalizedSize.width,
            height: length2
          };
          this.position(element, listSize);
        },
        position(element, listSize) {
          const {
            vel,
            options
          } = this;
          const {
            margin = 5,
            position: position2 = "top-left"
          } = options;
          const {
            width: width2,
            height: height2
          } = element.size();
          const {
            left: left2,
            right: right2,
            top: top2,
            bottom: bottom2
          } = normalizeSides(margin);
          const bbox2 = new Rect(left2, top2, width2 - (left2 + right2), height2 - (top2 + bottom2));
          let {
            x,
            y
          } = getRectPoint(bbox2, position2);
          switch (position2) {
            case Positions.CENTER:
            case Positions.TOP:
            case Positions.BOTTOM: {
              x -= listSize.width / 2;
              break;
            }
            case Positions.RIGHT:
            case Positions.BOTTOM_RIGHT:
            case Positions.TOP_RIGHT: {
              x -= listSize.width;
              break;
            }
          }
          switch (position2) {
            case Positions.CENTER:
            case Positions.RIGHT:
            case Positions.LEFT: {
              y -= listSize.height / 2;
              break;
            }
            case Positions.BOTTOM:
            case Positions.BOTTOM_RIGHT:
            case Positions.BOTTOM_LEFT: {
              y -= listSize.height;
              break;
            }
          }
          vel.attr("transform", `translate(${x}, ${y})`);
        }
      }, {
        Directions: Directions$1,
        Positions
      });
      var highlighters = {
        __proto__: null,
        addClass,
        list,
        mask,
        opacity,
        stroke: stroke$1
      };
      function offsetPoint(p1, p2, offset2) {
        if (isPlainObject(offset2)) {
          const {
            x,
            y
          } = offset2;
          if (isFinite(y)) {
            const line2 = new Line(p2, p1);
            const {
              start,
              end
            } = line2.parallel(y);
            p2 = start;
            p1 = end;
          }
          offset2 = x;
        }
        if (!isFinite(offset2)) return p1;
        var length2 = p1.distance(p2);
        if (offset2 === 0 && length2 > 0) return p1;
        return p1.move(p2, -Math.min(offset2, length2 - 1));
      }
      function stroke(magnet) {
        var stroke2 = magnet.getAttribute("stroke-width");
        if (stroke2 === null) return 0;
        return parseFloat(stroke2) || 0;
      }
      function alignLine(line2, type, offset2 = 0) {
        let coordinate, a, b, direction;
        const {
          start,
          end
        } = line2;
        switch (type) {
          case "left":
            coordinate = "x";
            a = end;
            b = start;
            direction = -1;
            break;
          case "right":
            coordinate = "x";
            a = start;
            b = end;
            direction = 1;
            break;
          case "top":
            coordinate = "y";
            a = end;
            b = start;
            direction = -1;
            break;
          case "bottom":
            coordinate = "y";
            a = start;
            b = end;
            direction = 1;
            break;
          default:
            return;
        }
        if (start[coordinate] < end[coordinate]) {
          a[coordinate] = b[coordinate];
        } else {
          b[coordinate] = a[coordinate];
        }
        if (isFinite(offset2)) {
          a[coordinate] += direction * offset2;
          b[coordinate] += direction * offset2;
        }
      }
      function anchorConnectionPoint(line2, _view, _magnet, opt) {
        let {
          offset: offset2,
          alignOffset,
          align: align2
        } = opt;
        if (align2) alignLine(line2, align2, alignOffset);
        return offsetPoint(line2.end, line2.start, offset2);
      }
      function bboxIntersection(line2, view, magnet, opt) {
        const bbox2 = opt.useModelGeometry ? getNodeModelBBox(view, magnet, true) : view.getNodeBBox(magnet);
        if (opt.stroke) bbox2.inflate(stroke(magnet) / 2);
        const intersections = line2.intersect(bbox2);
        const cp = intersections ? line2.start.chooseClosest(intersections) : line2.end;
        return offsetPoint(cp, line2.start, opt.offset);
      }
      function rectangleIntersection(line2, view, magnet, opt) {
        const angle = view.model.angle();
        if (angle === 0) {
          return bboxIntersection(line2, view, magnet, opt);
        }
        const bboxWORotation = opt.useModelGeometry ? getNodeModelBBox(view, magnet, false) : view.getNodeUnrotatedBBox(magnet);
        if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);
        const center2 = bboxWORotation.center();
        const lineWORotation = line2.clone().rotate(center2, angle);
        const intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);
        const cp = intersections ? lineWORotation.start.chooseClosest(intersections).rotate(center2, -angle) : line2.end;
        return offsetPoint(cp, line2.start, opt.offset);
      }
      function getNodeModelBBox(elementView, magnet, rotate) {
        const element = elementView.model;
        const portId = elementView.findAttribute("port", magnet);
        if (element.hasPort(portId)) {
          return element.getPortBBox(portId, {
            rotate
          });
        }
        return element.getBBox({
          rotate
        });
      }
      function findShapeNode(magnet) {
        if (!magnet) return null;
        var node = magnet;
        do {
          var tagName = node.tagName;
          if (typeof tagName !== "string") return null;
          tagName = tagName.toUpperCase();
          if (tagName === "G") {
            node = node.firstElementChild;
          } else if (tagName === "TITLE") {
            node = node.nextElementSibling;
          } else break;
        } while (node);
        return node;
      }
      var BNDR_SUBDIVISIONS = "segmentSubdivisons";
      var BNDR_SHAPE_BBOX = "shapeBBox";
      function boundaryIntersection(line2, view, magnet, opt) {
        var node, intersection2;
        var selector = opt.selector;
        var anchor2 = line2.end;
        if (typeof selector === "string") {
          node = view.findNode(selector);
        } else if (selector === false) {
          node = magnet;
        } else if (Array.isArray(selector)) {
          node = getByPath(magnet, selector);
        } else {
          node = findShapeNode(magnet);
        }
        if (!V2.isSVGGraphicsElement(node)) {
          if (node === magnet || !V2.isSVGGraphicsElement(magnet)) return anchor2;
          node = magnet;
        }
        var localShape = view.getNodeShape(node);
        var magnetMatrix = view.getNodeMatrix(node);
        var translateMatrix = view.getRootTranslateMatrix();
        var rotateMatrix = view.getRootRotateMatrix();
        var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);
        var localMatrix = targetMatrix.inverse();
        var localLine = V2.transformLine(line2, localMatrix);
        var localRef = localLine.start.clone();
        var data2 = view.getNodeData(node);
        if (opt.insideout === false) {
          if (!data2[BNDR_SHAPE_BBOX]) data2[BNDR_SHAPE_BBOX] = localShape.bbox();
          var localBBox = data2[BNDR_SHAPE_BBOX];
          if (localBBox.containsPoint(localRef)) return anchor2;
        }
        var pathOpt;
        if (localShape instanceof Path$1) {
          var precision = opt.precision || 2;
          if (!data2[BNDR_SUBDIVISIONS]) data2[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({
            precision
          });
          pathOpt = {
            precision,
            segmentSubdivisions: data2[BNDR_SUBDIVISIONS]
          };
        }
        if (opt.extrapolate === true) localLine.setLength(1e6);
        intersection2 = localLine.intersect(localShape, pathOpt);
        if (intersection2) {
          if (V2.isArray(intersection2)) intersection2 = localRef.chooseClosest(intersection2);
        } else if (opt.sticky === true) {
          if (localShape instanceof Rect) {
            intersection2 = localShape.pointNearestToPoint(localRef);
          } else if (localShape instanceof Ellipse$1) {
            intersection2 = localShape.intersectionWithLineFromCenterToPoint(localRef);
          } else {
            intersection2 = localShape.closestPoint(localRef, pathOpt);
          }
        }
        var cp = intersection2 ? V2.transformPoint(intersection2, targetMatrix) : anchor2;
        var cpOffset = opt.offset || 0;
        if (opt.stroke) cpOffset += stroke(node) / 2;
        return offsetPoint(cp, line2.start, cpOffset);
      }
      const anchor = anchorConnectionPoint;
      const bbox = bboxIntersection;
      const rectangle = rectangleIntersection;
      const boundary = boundaryIntersection;
      var connectionPoints = {
        __proto__: null,
        anchor,
        bbox,
        boundary,
        rectangle
      };
      function abs2rel(absolute2, max2) {
        if (max2 === 0) return "0%";
        const dp = 1e3;
        const relative = Math.round(absolute2 / max2 * 100 * dp) / dp;
        return `${relative}%`;
      }
      function pin(relative) {
        return function(end, view, magnet, coords) {
          var fn2 = view.isNodeConnection(magnet) ? pinnedLinkEnd : pinnedElementEnd;
          return fn2(relative, end, view, magnet, coords);
        };
      }
      function pinnedElementEnd(relative, end, view, magnet, coords) {
        var angle = view.model.angle();
        var bbox2 = view.getNodeUnrotatedBBox(magnet);
        var origin = view.model.getCenter();
        coords.rotate(origin, angle);
        var dx = coords.x - bbox2.x;
        var dy = coords.y - bbox2.y;
        if (relative) {
          dx = abs2rel(dx, bbox2.width);
          dy = abs2rel(dy, bbox2.height);
        }
        end.anchor = {
          name: "topLeft",
          args: {
            dx,
            dy,
            rotate: true
          }
        };
        return end;
      }
      function pinnedLinkEnd(relative, end, view, _magnet, coords) {
        var connection = view.getConnection();
        if (!connection) return end;
        var length2 = connection.closestPointLength(coords);
        if (relative) {
          var totalLength = connection.length();
          end.anchor = {
            name: "connectionRatio",
            args: {
              ratio: length2 / totalLength
            }
          };
        } else {
          end.anchor = {
            name: "connectionLength",
            args: {
              length: length2
            }
          };
        }
        return end;
      }
      const useDefaults = noop;
      const pinAbsolute = pin(false);
      const pinRelative = pin(true);
      var index$3 = {
        __proto__: null,
        pinAbsolute,
        pinRelative,
        useDefaults
      };
      const normal = function(vertices, opt, linkView) {
        return vertices;
      };
      const oneSide = function(vertices, opt, linkView) {
        var side = opt.side || "bottom";
        var padding = normalizeSides(opt.padding || 40);
        var sourceBBox = linkView.sourceBBox;
        var targetBBox = linkView.targetBBox;
        var sourcePoint = sourceBBox.center();
        var targetPoint = targetBBox.center();
        var coordinate, dimension, direction;
        switch (side) {
          case "bottom":
            direction = 1;
            coordinate = "y";
            dimension = "height";
            break;
          case "top":
            direction = -1;
            coordinate = "y";
            dimension = "height";
            break;
          case "left":
            direction = -1;
            coordinate = "x";
            dimension = "width";
            break;
          case "right":
            direction = 1;
            coordinate = "x";
            dimension = "width";
            break;
          default:
            throw new Error("Router: invalid side");
        }
        sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);
        targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);
        if (direction * (sourcePoint[coordinate] - targetPoint[coordinate]) > 0) {
          targetPoint[coordinate] = sourcePoint[coordinate];
        } else {
          sourcePoint[coordinate] = targetPoint[coordinate];
        }
        return [sourcePoint].concat(vertices, targetPoint);
      };
      var opposites = {
        N: "S",
        S: "N",
        E: "W",
        W: "E"
      };
      var radians = {
        N: -Math.PI / 2 * 3,
        S: -Math.PI / 2,
        E: 0,
        W: Math.PI
      };
      function freeJoin(p1, p2, bbox2) {
        var p = new Point(p1.x, p2.y);
        if (bbox2.containsPoint(p)) p = new Point(p2.x, p1.y);
        return p;
      }
      function getBBoxSize(bbox2, bearing2) {
        return bbox2[bearing2 === "W" || bearing2 === "E" ? "width" : "height"];
      }
      function getBearing(from, to) {
        if (from.x === to.x) return from.y > to.y ? "N" : "S";
        if (from.y === to.y) return from.x > to.x ? "W" : "E";
        return null;
      }
      function getPointBox(p) {
        return new Rect(p.x, p.y, 0, 0);
      }
      function getPaddingBox(opt) {
        var sides = normalizeSides(opt.padding || opt.elementPadding || 20);
        return {
          x: -sides.left,
          y: -sides.top,
          width: sides.left + sides.right,
          height: sides.top + sides.bottom
        };
      }
      function getSourceBBox$1(linkView, opt) {
        return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));
      }
      function getTargetBBox$1(linkView, opt) {
        return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));
      }
      function getSourceAnchor$1(linkView, opt) {
        if (linkView.sourceAnchor) return linkView.sourceAnchor;
        var sourceBBox = getSourceBBox$1(linkView, opt);
        return sourceBBox.center();
      }
      function getTargetAnchor$1(linkView, opt) {
        if (linkView.targetAnchor) return linkView.targetAnchor;
        var targetBBox = getTargetBBox$1(linkView, opt);
        return targetBBox.center();
      }
      function vertexVertex(from, to, bearing2) {
        var p1 = new Point(from.x, to.y);
        var p2 = new Point(to.x, from.y);
        var d1 = getBearing(from, p1);
        var d2 = getBearing(from, p2);
        var opposite = opposites[bearing2];
        var p = d1 === bearing2 || d1 !== opposite && (d2 === opposite || d2 !== bearing2) ? p1 : p2;
        return {
          points: [p],
          direction: getBearing(p, to)
        };
      }
      function elementVertex(from, to, fromBBox) {
        var p = freeJoin(from, to, fromBBox);
        return {
          points: [p],
          direction: getBearing(p, to)
        };
      }
      function vertexElement(from, to, toBBox, bearing2) {
        var route = {};
        var points = [new Point(from.x, to.y), new Point(to.x, from.y)];
        var freePoints = points.filter(function(pt) {
          return !toBBox.containsPoint(pt);
        });
        var freeBearingPoints = freePoints.filter(function(pt) {
          return getBearing(pt, from) !== bearing2;
        });
        var p;
        if (freeBearingPoints.length > 0) {
          p = freeBearingPoints.filter(function(pt) {
            return getBearing(from, pt) === bearing2;
          }).pop();
          p = p || freeBearingPoints[0];
          route.points = [p];
          route.direction = getBearing(p, to);
        } else {
          p = difference(points, freePoints)[0];
          var p2 = new Point(to).move(p, -getBBoxSize(toBBox, bearing2) / 2);
          var p1 = freeJoin(p2, from, toBBox);
          route.points = [p1, p2];
          route.direction = getBearing(p2, to);
        }
        return route;
      }
      function elementElement(from, to, fromBBox, toBBox) {
        var route = elementVertex(to, from, toBBox);
        var p1 = route.points[0];
        if (fromBBox.containsPoint(p1)) {
          route = elementVertex(from, to, fromBBox);
          var p2 = route.points[0];
          if (toBBox.containsPoint(p2)) {
            var fromBorder = new Point(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);
            var toBorder = new Point(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);
            var mid = new Line(fromBorder, toBorder).midpoint();
            var startRoute = elementVertex(from, mid, fromBBox);
            var endRoute = vertexVertex(mid, to, startRoute.direction);
            route.points = [startRoute.points[0], endRoute.points[0]];
            route.direction = endRoute.direction;
          }
        }
        return route;
      }
      function insideElement(from, to, fromBBox, toBBox, bearing2) {
        var route = {};
        var boundary2 = fromBBox.union(toBBox).inflate(1);
        var reversed = boundary2.center().distance(to) > boundary2.center().distance(from);
        var start = reversed ? to : from;
        var end = reversed ? from : to;
        var p1, p2, p3;
        if (bearing2) {
          p1 = Point.fromPolar(boundary2.width + boundary2.height, radians[bearing2], start);
          p1 = boundary2.pointNearestToPoint(p1).move(p1, -1);
        } else {
          p1 = boundary2.pointNearestToPoint(start).move(start, 1);
        }
        p2 = freeJoin(p1, end, boundary2);
        if (p1.round().equals(p2.round())) {
          p2 = Point.fromPolar(boundary2.width + boundary2.height, toRad(p1.theta(start)) + Math.PI / 2, end);
          p2 = boundary2.pointNearestToPoint(p2).move(end, 1).round();
          p3 = freeJoin(p1, p2, boundary2);
          route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];
        } else {
          route.points = reversed ? [p2, p1] : [p1, p2];
        }
        route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);
        return route;
      }
      function orthogonal(vertices, opt, linkView) {
        var sourceBBox = getSourceBBox$1(linkView, opt);
        var targetBBox = getTargetBBox$1(linkView, opt);
        var sourceAnchor = getSourceAnchor$1(linkView, opt);
        var targetAnchor = getTargetAnchor$1(linkView, opt);
        sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));
        targetBBox = targetBBox.union(getPointBox(targetAnchor));
        vertices = toArray$1(vertices).map(Point);
        vertices.unshift(sourceAnchor);
        vertices.push(targetAnchor);
        var bearing2;
        var orthogonalVertices = [];
        for (var i = 0, max2 = vertices.length - 1; i < max2; i++) {
          var route = null;
          var from = vertices[i];
          var to = vertices[i + 1];
          var isOrthogonal = !!getBearing(from, to);
          if (i === 0) {
            if (i + 1 === max2) {
              if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {
                route = insideElement(from, to, sourceBBox, targetBBox);
              } else if (!isOrthogonal) {
                route = elementElement(from, to, sourceBBox, targetBBox);
              }
            } else {
              if (sourceBBox.containsPoint(to)) {
                route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));
              } else if (!isOrthogonal) {
                route = elementVertex(from, to, sourceBBox);
              }
            }
          } else if (i + 1 === max2) {
            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing2;
            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {
              route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing2);
            } else if (!isOrthogonal) {
              route = vertexElement(from, to, targetBBox, bearing2);
            }
          } else if (!isOrthogonal) {
            route = vertexVertex(from, to, bearing2);
          }
          if (route) {
            Array.prototype.push.apply(orthogonalVertices, route.points);
            bearing2 = route.direction;
          } else {
            bearing2 = getBearing(from, to);
          }
          if (i + 1 < max2) {
            orthogonalVertices.push(to);
          }
        }
        return orthogonalVertices;
      }
      var config$1 = {
        // size of the step to find a route (the grid of the manhattan pathfinder)
        step: 10,
        // the number of route finding loops that cause the router to abort
        // returns fallback route instead
        maximumLoops: 2e3,
        // the number of decimal places to round floating point coordinates
        precision: 1,
        // maximum change of direction
        maxAllowedDirectionChange: 90,
        // should the router use perpendicular linkView option?
        // does not connect anchor of element but rather a point close-by that is orthogonal
        // this looks much better
        perpendicular: true,
        // should the source and/or target not be considered as obstacles?
        excludeEnds: [],
        // 'source', 'target'
        // should certain types of elements not be considered as obstacles?
        excludeTypes: [],
        // possible starting directions from an element
        startDirections: ["top", "right", "bottom", "left"],
        // possible ending directions to an element
        endDirections: ["top", "right", "bottom", "left"],
        // specify the directions used above and what they mean
        directionMap: {
          top: {
            x: 0,
            y: -1
          },
          right: {
            x: 1,
            y: 0
          },
          bottom: {
            x: 0,
            y: 1
          },
          left: {
            x: -1,
            y: 0
          }
        },
        // cost of an orthogonal step
        cost: function() {
          return this.step;
        },
        // an array of directions to find next points on the route
        // different from start/end directions
        directions: function() {
          var step = this.step;
          var cost = this.cost();
          return [{
            offsetX: step,
            offsetY: 0,
            cost
          }, {
            offsetX: -step,
            offsetY: 0,
            cost
          }, {
            offsetX: 0,
            offsetY: step,
            cost
          }, {
            offsetX: 0,
            offsetY: -step,
            cost
          }];
        },
        // a penalty received for direction change
        penalties: function() {
          return {
            0: 0,
            45: this.step / 2,
            90: this.step / 2
          };
        },
        // padding applied on the element bounding boxes
        paddingBox: function() {
          var step = this.step;
          return {
            x: -step,
            y: -step,
            width: 2 * step,
            height: 2 * step
          };
        },
        // A function that determines whether a given point is an obstacle or not.
        // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.
        // (point: dia.Point) => boolean;
        isPointObstacle: null,
        // a router to use when the manhattan router fails
        // (one of the partial routes returns null)
        fallbackRouter: function(vertices, opt, linkView) {
          if (!isFunction(orthogonal)) {
            throw new Error("Manhattan requires the orthogonal router as default fallback.");
          }
          return orthogonal(vertices, assign({}, config$1, opt), linkView);
        },
        /* Deprecated */
        // a simple route used in situations when main routing method fails
        // (exceed max number of loop iterations, inaccessible)
        fallbackRoute: function(from, to, opt) {
          return null;
        },
        // if a function is provided, it's used to route the link while dragging an end
        // i.e. function(from, to, opt) { return []; }
        draggingRoute: null
      };
      function ObstacleMap(opt) {
        this.map = {};
        this.options = opt;
        this.mapGridSize = 100;
      }
      ObstacleMap.prototype.build = function(graph, link) {
        var opt = this.options;
        var excludedEnds = toArray$1(opt.excludeEnds).reduce(function(res, item) {
          var end = link.get(item);
          if (end) {
            var cell = graph.getCell(end.id);
            if (cell) {
              res.push(cell);
            }
          }
          return res;
        }, []);
        var excludedAncestors = [];
        var source = graph.getCell(link.get("source").id);
        if (source) {
          excludedAncestors = union(excludedAncestors, source.getAncestors().map(function(cell) {
            return cell.id;
          }));
        }
        var target = graph.getCell(link.get("target").id);
        if (target) {
          excludedAncestors = union(excludedAncestors, target.getAncestors().map(function(cell) {
            return cell.id;
          }));
        }
        var mapGridSize = this.mapGridSize;
        graph.getElements().reduce(function(map, element) {
          var isExcludedType = toArray$1(opt.excludeTypes).includes(element.get("type"));
          var isExcludedEnd = excludedEnds.find(function(excluded) {
            return excluded.id === element.id;
          });
          var isExcludedAncestor = excludedAncestors.includes(element.id);
          var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;
          if (!isExcluded) {
            var bbox2 = element.getBBox().moveAndExpand(opt.paddingBox);
            var origin = bbox2.origin().snapToGrid(mapGridSize);
            var corner = bbox2.corner().snapToGrid(mapGridSize);
            for (var x = origin.x; x <= corner.x; x += mapGridSize) {
              for (var y = origin.y; y <= corner.y; y += mapGridSize) {
                var gridKey = x + "@" + y;
                map[gridKey] = map[gridKey] || [];
                map[gridKey].push(bbox2);
              }
            }
          }
          return map;
        }, this.map);
        return this;
      };
      ObstacleMap.prototype.isPointAccessible = function(point2) {
        var mapKey = point2.clone().snapToGrid(this.mapGridSize).toString();
        return toArray$1(this.map[mapKey]).every(function(obstacle) {
          return !obstacle.containsPoint(point2);
        });
      };
      function SortedSet() {
        this.items = [];
        this.hash = {};
        this.values = {};
        this.OPEN = 1;
        this.CLOSE = 2;
      }
      SortedSet.prototype.add = function(item, value) {
        if (this.hash[item]) {
          this.items.splice(this.items.indexOf(item), 1);
        } else {
          this.hash[item] = this.OPEN;
        }
        this.values[item] = value;
        var index2 = sortedIndex(this.items, item, (function(i) {
          return this.values[i];
        }).bind(this));
        this.items.splice(index2, 0, item);
      };
      SortedSet.prototype.remove = function(item) {
        this.hash[item] = this.CLOSE;
      };
      SortedSet.prototype.isOpen = function(item) {
        return this.hash[item] === this.OPEN;
      };
      SortedSet.prototype.isClose = function(item) {
        return this.hash[item] === this.CLOSE;
      };
      SortedSet.prototype.isEmpty = function() {
        return this.items.length === 0;
      };
      SortedSet.prototype.pop = function() {
        var item = this.items.shift();
        this.remove(item);
        return item;
      };
      function getSourceBBox(linkView, opt) {
        if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);
        return linkView.sourceBBox.clone();
      }
      function getTargetBBox(linkView, opt) {
        if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);
        return linkView.targetBBox.clone();
      }
      function getSourceAnchor(linkView, opt) {
        if (linkView.sourceAnchor) return linkView.sourceAnchor;
        var sourceBBox = getSourceBBox(linkView, opt);
        return sourceBBox.center();
      }
      function getTargetAnchor(linkView, opt) {
        if (linkView.targetAnchor) return linkView.targetAnchor;
        var targetBBox = getTargetBBox(linkView, opt);
        return targetBBox.center();
      }
      function getDirectionAngle(start, end, numDirections, grid, opt) {
        var quadrant = 360 / numDirections;
        var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));
        var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);
        return quadrant * Math.floor(normalizedAngle / quadrant);
      }
      function fixAngleEnd(start, end, grid, opt) {
        var step = opt.step;
        var diffX = end.x - start.x;
        var diffY = end.y - start.y;
        var gridStepsX = diffX / grid.x;
        var gridStepsY = diffY / grid.y;
        var distanceX = gridStepsX * step;
        var distanceY = gridStepsY * step;
        return new Point(start.x + distanceX, start.y + distanceY);
      }
      function getDirectionChange(angle1, angle2) {
        var directionChange = Math.abs(angle1 - angle2);
        return directionChange > 180 ? 360 - directionChange : directionChange;
      }
      function getGridOffsets(directions, grid, opt) {
        var step = opt.step;
        toArray$1(opt.directions).forEach(function(direction) {
          direction.gridOffsetX = direction.offsetX / step * grid.x;
          direction.gridOffsetY = direction.offsetY / step * grid.y;
        });
      }
      function getGrid(step, source, target) {
        return {
          source: source.clone(),
          x: getGridDimension(target.x - source.x, step),
          y: getGridDimension(target.y - source.y, step)
        };
      }
      function getGridDimension(diff2, step) {
        if (!diff2) return step;
        var absDiff = Math.abs(diff2);
        var numSteps = Math.round(absDiff / step);
        if (!numSteps) return absDiff;
        var roundedDiff = numSteps * step;
        var remainder = absDiff - roundedDiff;
        var stepCorrection = remainder / numSteps;
        return step + stepCorrection;
      }
      function snapToGrid(point2, grid) {
        var source = grid.source;
        var snappedX = snapToGrid$1(point2.x - source.x, grid.x) + source.x;
        var snappedY = snapToGrid$1(point2.y - source.y, grid.y) + source.y;
        return new Point(snappedX, snappedY);
      }
      function round(point2, precision) {
        return point2.round(precision);
      }
      function align(point2, grid, precision) {
        return round(snapToGrid(point2.clone(), grid), precision);
      }
      function getKey(point2) {
        return point2.clone().toString();
      }
      function normalizePoint(point2) {
        return new Point(point2.x === 0 ? 0 : Math.abs(point2.x) / point2.x, point2.y === 0 ? 0 : Math.abs(point2.y) / point2.y);
      }
      function reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {
        var route = [];
        var prevDiff = normalizePoint(to.difference(tailPoint));
        var currentKey = getKey(tailPoint);
        var parent2 = parents[currentKey];
        var point2;
        while (parent2) {
          point2 = points[currentKey];
          var diff2 = normalizePoint(point2.difference(parent2));
          if (!diff2.equals(prevDiff)) {
            route.unshift(point2);
            prevDiff = diff2;
          }
          currentKey = getKey(parent2);
          parent2 = parents[currentKey];
        }
        var leadPoint = points[currentKey];
        var fromDiff = normalizePoint(leadPoint.difference(from));
        if (!fromDiff.equals(prevDiff)) {
          route.unshift(leadPoint);
        }
        return route;
      }
      function estimateCost(from, endPoints) {
        var min2 = Infinity;
        for (var i = 0, len = endPoints.length; i < len; i++) {
          var cost = from.manhattanDistance(endPoints[i]);
          if (cost < min2) min2 = cost;
        }
        return min2;
      }
      function getRectPoints(anchor2, bbox2, directionList, grid, opt) {
        var precision = opt.precision;
        var directionMap = opt.directionMap;
        var anchorCenterVector = anchor2.difference(bbox2.center());
        var keys2 = isObject(directionMap) ? Object.keys(directionMap) : [];
        var dirList = toArray$1(directionList);
        var rectPoints = keys2.reduce(function(res, key) {
          if (dirList.includes(key)) {
            var direction = directionMap[key];
            var endpoint = new Point(anchor2.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox2.width), anchor2.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox2.height));
            var intersectionLine = new Line(anchor2, endpoint);
            var intersections = intersectionLine.intersect(bbox2) || [];
            var numIntersections = intersections.length;
            var farthestIntersectionDistance;
            var farthestIntersection = null;
            for (var i = 0; i < numIntersections; i++) {
              var currentIntersection = intersections[i];
              var distance = anchor2.squaredDistance(currentIntersection);
              if (farthestIntersectionDistance === void 0 || distance > farthestIntersectionDistance) {
                farthestIntersectionDistance = distance;
                farthestIntersection = currentIntersection;
              }
            }
            if (farthestIntersection) {
              var point2 = align(farthestIntersection, grid, precision);
              if (bbox2.containsPoint(point2)) {
                point2 = align(point2.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);
              }
              res.push(point2);
            }
          }
          return res;
        }, []);
        if (!bbox2.containsPoint(anchor2)) {
          rectPoints.push(align(anchor2, grid, precision));
        }
        return rectPoints;
      }
      function findRoute(from, to, isPointObstacle, opt) {
        var precision = opt.precision;
        var sourceAnchor, targetAnchor;
        if (from instanceof Rect) {
          sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);
        } else {
          sourceAnchor = round(from.clone(), precision);
        }
        if (to instanceof Rect) {
          targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);
        } else {
          targetAnchor = round(to.clone(), precision);
        }
        var grid = getGrid(opt.step, sourceAnchor, targetAnchor);
        var start, end;
        var startPoints, endPoints;
        if (from instanceof Rect) {
          start = sourceAnchor;
          startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);
        } else {
          start = sourceAnchor;
          startPoints = [start];
        }
        if (to instanceof Rect) {
          end = targetAnchor;
          endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);
        } else {
          end = targetAnchor;
          endPoints = [end];
        }
        startPoints = startPoints.filter((p) => !isPointObstacle(p));
        endPoints = endPoints.filter((p) => !isPointObstacle(p));
        if (startPoints.length > 0 && endPoints.length > 0) {
          var openSet = new SortedSet();
          var points = {};
          var parents = {};
          var costs = {};
          for (var i = 0, n = startPoints.length; i < n; i++) {
            var startPoint = startPoints[i];
            var key = getKey(startPoint);
            openSet.add(key, estimateCost(startPoint, endPoints));
            points[key] = startPoint;
            costs[key] = 0;
          }
          var previousRouteDirectionAngle = opt.previousDirectionAngle;
          var isPathBeginning = previousRouteDirectionAngle === void 0;
          var direction, directionChange;
          var directions = opt.directions;
          getGridOffsets(directions, grid, opt);
          var numDirections = directions.length;
          var endPointsKeys = toArray$1(endPoints).reduce(function(res, endPoint) {
            var key2 = getKey(endPoint);
            res.push(key2);
            return res;
          }, []);
          var loopsRemaining = opt.maximumLoops;
          while (!openSet.isEmpty() && loopsRemaining > 0) {
            var currentKey = openSet.pop();
            var currentPoint = points[currentKey];
            var currentParent = parents[currentKey];
            var currentCost = costs[currentKey];
            var isRouteBeginning = currentParent === void 0;
            var isStart = currentPoint.equals(start);
            var previousDirectionAngle;
            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt);
            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle;
            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt);
            else previousDirectionAngle = null;
            var samePoints = startPoints.length === endPoints.length;
            if (samePoints) {
              for (var j = 0; j < startPoints.length; j++) {
                if (!startPoints[j].equals(endPoints[j])) {
                  samePoints = false;
                  break;
                }
              }
            }
            var skipEndCheck = isRouteBeginning && samePoints;
            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {
              opt.previousDirectionAngle = previousDirectionAngle;
              return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);
            }
            for (i = 0; i < numDirections; i++) {
              direction = directions[i];
              var directionAngle = direction.angle;
              directionChange = getDirectionChange(previousDirectionAngle, directionAngle);
              if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;
              var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);
              var neighborKey = getKey(neighborPoint);
              if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;
              if (endPointsKeys.indexOf(neighborKey) >= 0) {
                var isNeighborEnd = neighborPoint.equals(end);
                if (!isNeighborEnd) {
                  var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);
                  var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);
                  if (endDirectionChange > opt.maxAllowedDirectionChange) continue;
                }
              }
              var neighborCost = direction.cost;
              var neighborPenalty = isStart ? 0 : opt.penalties[directionChange];
              var costFromStart = currentCost + neighborCost + neighborPenalty;
              if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {
                points[neighborKey] = neighborPoint;
                parents[neighborKey] = currentPoint;
                costs[neighborKey] = costFromStart;
                openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));
              }
            }
            loopsRemaining--;
          }
        }
        return opt.fallbackRoute.call(this, start, end, opt);
      }
      function resolveOptions(opt) {
        opt.directions = result(opt, "directions");
        opt.penalties = result(opt, "penalties");
        opt.paddingBox = result(opt, "paddingBox");
        opt.padding = result(opt, "padding");
        if (opt.padding) {
          var sides = normalizeSides(opt.padding);
          opt.paddingBox = {
            x: -sides.left,
            y: -sides.top,
            width: sides.left + sides.right,
            height: sides.top + sides.bottom
          };
        }
        toArray$1(opt.directions).forEach(function(direction) {
          var point1 = new Point(0, 0);
          var point2 = new Point(direction.offsetX, direction.offsetY);
          direction.angle = normalizeAngle(point1.theta(point2));
        });
      }
      function router(vertices, opt, linkView) {
        resolveOptions(opt);
        linkView.options.perpendicular = !!opt.perpendicular;
        var sourceBBox = getSourceBBox(linkView, opt);
        var targetBBox = getTargetBBox(linkView, opt);
        var sourceAnchor = getSourceAnchor(linkView, opt);
        let isPointObstacle;
        if (typeof opt.isPointObstacle === "function") {
          isPointObstacle = opt.isPointObstacle;
        } else {
          const map = new ObstacleMap(opt);
          map.build(linkView.paper.model, linkView.model);
          isPointObstacle = (point2) => !map.isPointAccessible(point2);
        }
        var oldVertices = toArray$1(vertices).map(Point);
        var newVertices = [];
        var tailPoint = sourceAnchor;
        var to, from;
        for (var i = 0, len = oldVertices.length; i <= len; i++) {
          var partialRoute = null;
          from = to || sourceBBox;
          to = oldVertices[i];
          if (!to) {
            to = targetBBox;
            var isEndingAtPoint = !linkView.model.get("source").id || !linkView.model.get("target").id;
            if (isEndingAtPoint && isFunction(opt.draggingRoute)) {
              var dragFrom = from === sourceBBox ? sourceAnchor : from;
              var dragTo = to.origin();
              partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);
            }
          }
          partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);
          if (partialRoute === null) {
            return opt.fallbackRouter(vertices, opt, linkView);
          }
          var leadPoint = partialRoute[0];
          if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();
          tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;
          Array.prototype.push.apply(newVertices, partialRoute);
        }
        return newVertices;
      }
      const manhattan = function(vertices, opt, linkView) {
        return router(vertices, assign({}, config$1, opt), linkView);
      };
      var config = {
        maxAllowedDirectionChange: 45,
        // cost of a diagonal step
        diagonalCost: function() {
          var step = this.step;
          return Math.ceil(Math.sqrt(step * step << 1));
        },
        // an array of directions to find next points on the route
        // different from start/end directions
        directions: function() {
          var step = this.step;
          var cost = this.cost();
          var diagonalCost = this.diagonalCost();
          return [{
            offsetX: step,
            offsetY: 0,
            cost
          }, {
            offsetX: step,
            offsetY: step,
            cost: diagonalCost
          }, {
            offsetX: 0,
            offsetY: step,
            cost
          }, {
            offsetX: -step,
            offsetY: step,
            cost: diagonalCost
          }, {
            offsetX: -step,
            offsetY: 0,
            cost
          }, {
            offsetX: -step,
            offsetY: -step,
            cost: diagonalCost
          }, {
            offsetX: 0,
            offsetY: -step,
            cost
          }, {
            offsetX: step,
            offsetY: -step,
            cost: diagonalCost
          }];
        },
        // a simple route used in situations when main routing method fails
        // (exceed max number of loop iterations, inaccessible)
        fallbackRoute: function(from, to, opt) {
          var theta = from.theta(to);
          var route = [];
          var a = {
            x: to.x,
            y: from.y
          };
          var b = {
            x: from.x,
            y: to.y
          };
          if (theta % 180 > 90) {
            var t = a;
            a = b;
            b = t;
          }
          var p1 = theta % 90 < 45 ? a : b;
          var l1 = new Line(from, p1);
          var alpha = 90 * Math.ceil(theta / 90);
          var p2 = Point.fromPolar(l1.squaredLength(), toRad(alpha + 135), p1);
          var l2 = new Line(to, p2);
          var intersectionPoint = l1.intersection(l2);
          var point2 = intersectionPoint ? intersectionPoint : to;
          var directionFrom = intersectionPoint ? point2 : from;
          var quadrant = 360 / opt.directions.length;
          var angleTheta = directionFrom.theta(to);
          var normalizedAngle = normalizeAngle(angleTheta + quadrant / 2);
          var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);
          opt.previousDirectionAngle = directionAngle;
          if (point2) route.push(point2.round());
          route.push(to);
          return route;
        }
      };
      const metro = function(vertices, opt, linkView) {
        if (!isFunction(manhattan)) {
          throw new Error("Metro requires the manhattan router.");
        }
        return manhattan(vertices, assign({}, config, opt), linkView);
      };
      const Directions = {
        AUTO: "auto",
        LEFT: "left",
        RIGHT: "right",
        TOP: "top",
        BOTTOM: "bottom",
        ANCHOR_SIDE: "anchor-side",
        MAGNET_SIDE: "magnet-side"
      };
      const DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];
      const OPPOSITE_DIRECTIONS = {
        [Directions.LEFT]: Directions.RIGHT,
        [Directions.RIGHT]: Directions.LEFT,
        [Directions.TOP]: Directions.BOTTOM,
        [Directions.BOTTOM]: Directions.TOP
      };
      const VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];
      const ANGLE_DIRECTION_MAP = {
        0: Directions.RIGHT,
        180: Directions.LEFT,
        270: Directions.TOP,
        90: Directions.BOTTOM
      };
      function getSegmentAngle(line2) {
        return line2.angle();
      }
      function simplifyPoints(points) {
        return new Polyline$1(points).simplify({
          threshold: 1
        }).points;
      }
      function resolveSides(source, target) {
        const {
          point: sourcePoint,
          x0: sx0,
          y0: sy0,
          view: sourceView,
          bbox: sourceBBox,
          direction: sourceDirection
        } = source;
        const {
          point: targetPoint,
          x0: tx0,
          y0: ty0,
          view: targetView,
          bbox: targetBBox,
          direction: targetDirection
        } = target;
        let sourceSide;
        if (!sourceView) {
          const sourceLinkAnchorBBox = new Rect(sx0, sy0, 0, 0);
          sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);
        } else if (sourceView.model.isLink()) {
          sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);
        } else if (sourceDirection === Directions.ANCHOR_SIDE) {
          sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);
        } else if (sourceDirection === Directions.MAGNET_SIDE) {
          sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);
        } else {
          sourceSide = sourceDirection;
        }
        let targetSide;
        if (!targetView) {
          const targetLinkAnchorBBox = new Rect(tx0, ty0, 0, 0);
          targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);
        } else if (targetView.model.isLink()) {
          targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);
        } else if (targetDirection === Directions.ANCHOR_SIDE) {
          targetSide = targetBBox.sideNearestToPoint(targetPoint);
        } else if (targetDirection === Directions.MAGNET_SIDE) {
          targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);
        } else {
          targetSide = targetDirection;
        }
        return [sourceSide, targetSide];
      }
      function resolveForTopSourceSide(source, target, nextInLine) {
        const {
          x0: sx0,
          y0: sy0,
          width: width2,
          height: height2,
          point: anchor2,
          margin
        } = source;
        const sx1 = sx0 + width2;
        const sy1 = sy0 + height2;
        const smx0 = sx0 - margin;
        const smx1 = sx1 + margin;
        const smy0 = sy0 - margin;
        const {
          x: ax
        } = anchor2;
        const {
          x0: tx,
          y0: ty
        } = target;
        if (tx === ax && ty < sy0) return Directions.BOTTOM;
        if (tx < ax && ty < smy0) {
          if (nextInLine.point.x === ax) return Directions.BOTTOM;
          return Directions.RIGHT;
        }
        if (tx > ax && ty < smy0) {
          if (nextInLine.point.x === ax) return Directions.BOTTOM;
          return Directions.LEFT;
        }
        if (tx < smx0 && ty > smy0) return Directions.TOP;
        if (tx > smx1 && ty > smy0) return Directions.TOP;
        if (tx >= smx0 && tx <= ax && ty > sy1) {
          if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
          }
          return Directions.LEFT;
        }
        if (tx <= smx1 && tx >= ax && ty > sy1) {
          if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
          }
          return Directions.LEFT;
        }
        return Directions.BOTTOM;
      }
      function resolveForBottomSourceSide(source, target, nextInLine) {
        const {
          x0: sx0,
          y0: sy0,
          width: width2,
          height: height2,
          point: anchor2,
          margin
        } = source;
        const sx1 = sx0 + width2;
        const sy1 = sy0 + height2;
        const smx0 = sx0 - margin;
        const smx1 = sx1 + margin;
        const smy1 = sy1 + margin;
        const {
          x: ax
        } = anchor2;
        const {
          x0: tx,
          y0: ty
        } = target;
        if (tx === ax && ty > sy1) return Directions.TOP;
        if (tx < ax && ty > smy1) {
          if (nextInLine.point.x === ax) return Directions.TOP;
          return Directions.RIGHT;
        }
        if (tx > ax && ty > smy1) {
          if (nextInLine.point.x === ax) return Directions.TOP;
          return Directions.LEFT;
        }
        if (tx < smx0 && ty < smy1) return Directions.BOTTOM;
        if (tx > smx1 && ty < smy1) return Directions.BOTTOM;
        if (tx >= smx0 && tx <= ax && ty < sy0) {
          if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
          }
          return Directions.LEFT;
        }
        if (tx <= smx1 && tx >= ax && ty < sy0) {
          if (nextInLine.point.x < tx) {
            return Directions.RIGHT;
          }
          return Directions.LEFT;
        }
        return Directions.TOP;
      }
      function resolveForLeftSourceSide(source, target, nextInLine) {
        const {
          y0: sy0,
          x0: sx0,
          width: width2,
          height: height2,
          point: anchor2,
          margin
        } = source;
        const sx1 = sx0 + width2;
        const sy1 = sy0 + height2;
        const smx0 = sx0 - margin;
        const smy0 = sy0 - margin;
        const smy1 = sy1 + margin;
        const {
          x: ax,
          y: ay
        } = anchor2;
        const {
          x0: tx,
          y0: ty
        } = target;
        if (tx < ax && ty === ay) return Directions.RIGHT;
        if (tx <= smx0 && ty < ay) return Directions.BOTTOM;
        if (tx <= smx0 && ty > ay) return Directions.TOP;
        if (tx >= smx0 && ty < smy0) return Directions.LEFT;
        if (tx >= smx0 && ty > smy1) return Directions.LEFT;
        if (tx > sx1 && ty >= smy0 && ty <= ay) {
          if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
          }
          return Directions.TOP;
        }
        if (tx > sx1 && ty <= smy1 && ty >= ay) {
          if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
          }
          return Directions.TOP;
        }
        return Directions.RIGHT;
      }
      function resolveForRightSourceSide(source, target, nextInLine) {
        const {
          y0: sy0,
          x0: sx0,
          width: width2,
          height: height2,
          point: anchor2,
          margin
        } = source;
        const sx1 = sx0 + width2;
        const sy1 = sy0 + height2;
        const smx1 = sx1 + margin;
        const smy0 = sy0 - margin;
        const smy1 = sy1 + margin;
        const {
          x: ax,
          y: ay
        } = anchor2;
        const {
          x0: tx,
          y0: ty
        } = target;
        if (tx > ax && ty === ay) return Directions.LEFT;
        if (tx >= smx1 && ty < ay) return Directions.BOTTOM;
        if (tx >= smx1 && ty > ay) return Directions.TOP;
        if (tx <= smx1 && ty < smy0) return Directions.RIGHT;
        if (tx <= smx1 && ty > smy1) return Directions.RIGHT;
        if (tx < sx0 && ty >= smy0 && ty <= ay) {
          if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
          }
          return Directions.TOP;
        }
        if (tx < sx0 && ty <= smy1 && ty >= ay) {
          if (nextInLine.point.y < ty) {
            return Directions.BOTTOM;
          }
          return Directions.TOP;
        }
        return Directions.LEFT;
      }
      function resolveInitialDirection(source, target, nextInLine) {
        const [sourceSide] = resolveSides(source, target);
        switch (sourceSide) {
          case Directions.TOP:
            return resolveForTopSourceSide(source, target, nextInLine);
          case Directions.RIGHT:
            return resolveForRightSourceSide(source, target, nextInLine);
          case Directions.BOTTOM:
            return resolveForBottomSourceSide(source, target, nextInLine);
          case Directions.LEFT:
            return resolveForLeftSourceSide(source, target, nextInLine);
        }
      }
      function getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {
        const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));
        const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;
        if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {
          return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
        } else if (linkOrigin.x === connectionPoint.x) {
          return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
        }
        switch (roundedAngle) {
          case 0:
          case 180:
          case 360:
            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;
          case 90:
          case 270:
            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;
        }
      }
      function pointDataFromAnchor(view, point2, bbox2, direction, isPort, fallBackAnchor, margin) {
        if (direction === Directions.AUTO) {
          direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;
        }
        const isElement = view && view.model.isElement();
        const {
          x: x0,
          y: y0,
          width: width2 = 0,
          height: height2 = 0
        } = isElement ? Rect.fromRectUnion(bbox2, view.model.getBBox()) : fallBackAnchor;
        return {
          point: point2,
          x0,
          y0,
          view,
          bbox: bbox2,
          width: width2,
          height: height2,
          direction,
          margin: isElement ? margin : 0
        };
      }
      function pointDataFromVertex({
        x,
        y
      }) {
        const point2 = new Point(x, y);
        return {
          point: point2,
          x0: point2.x,
          y0: point2.y,
          view: null,
          bbox: new Rect(x, y, 0, 0),
          width: 0,
          height: 0,
          direction: null,
          margin: 0
        };
      }
      function getOutsidePoint(side, pointData, margin) {
        const outsidePoint = pointData.point.clone();
        const {
          x0,
          y0,
          width: width2,
          height: height2
        } = pointData;
        switch (side) {
          case "left":
            outsidePoint.x = x0 - margin;
            break;
          case "right":
            outsidePoint.x = x0 + width2 + margin;
            break;
          case "top":
            outsidePoint.y = y0 - margin;
            break;
          case "bottom":
            outsidePoint.y = y0 + height2 + margin;
            break;
        }
        return outsidePoint;
      }
      function createLoop(from, to, {
        dx = 0,
        dy = 0
      }) {
        const p1 = {
          x: from.point.x + dx,
          y: from.point.y + dy
        };
        const p2 = {
          x: to.point.x + dx,
          y: to.point.y + dy
        };
        return [from.point, p1, p2, to.point];
      }
      function loopSegment(from, to, connectionSegmentAngle, margin) {
        const angle = normalizeAngle(connectionSegmentAngle - 90);
        let dx = 0;
        let dy = 0;
        if (angle === 90) {
          dy = -margin;
        } else if (angle === 180) {
          dx = -margin;
        } else if (angle === 270) {
          dy = margin;
        } else if (angle === 0) {
          dx = margin;
        }
        const loopRoute = createLoop(from, to, {
          dx,
          dy
        });
        const secondCreatedPoint = loopRoute[2];
        const loopEndSegment = new Line(to.point, secondCreatedPoint);
        const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
        return {
          loopRoute,
          continueDirection
        };
      }
      function getHorizontalDistance(source, target) {
        const {
          x0: sx0,
          x1: sx1,
          outsidePoint: sourcePoint
        } = source;
        const {
          x0: tx0,
          x1: tx1,
          outsidePoint: targetPoint
        } = target;
        let leftBoundary = Math.min(sx0, tx0);
        let rightBoundary = Math.max(sx1, tx1);
        if (source.direction === target.direction) {
          const aboveShape = source.y0 < target.y0 ? source : target;
          const belowShape = aboveShape === source ? target : source;
          const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;
          leftBoundary = boundaryDefiningShape.x0;
          rightBoundary = boundaryDefiningShape.x1;
        }
        const {
          x: sox
        } = sourcePoint;
        const {
          x: tox
        } = targetPoint;
        const leftDistance1 = Math.abs(sox - leftBoundary);
        const leftDistance2 = Math.abs(tox - leftBoundary);
        const leftD = leftDistance1 + leftDistance2;
        const rightDistance1 = Math.abs(sox - rightBoundary);
        const rightDistance2 = Math.abs(tox - rightBoundary);
        const rightD = rightDistance1 + rightDistance2;
        return [leftD, rightD];
      }
      function getVerticalDistance(source, target) {
        const {
          y0: sy0,
          y1: sy1,
          outsidePoint: sourcePoint
        } = source;
        const {
          y0: ty0,
          y1: ty1,
          outsidePoint: targetPoint
        } = target;
        let topBoundary = Math.min(sy0, ty0);
        let bottomBoundary = Math.max(sy1, ty1);
        if (source.direction === target.direction) {
          const leftShape = source.x0 < target.x0 ? source : target;
          const rightShape = leftShape === source ? target : source;
          const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;
          topBoundary = boundaryDefiningShape.y0;
          bottomBoundary = boundaryDefiningShape.y1;
        }
        const {
          y: soy
        } = sourcePoint;
        const {
          y: toy
        } = targetPoint;
        const topDistance1 = Math.abs(soy - topBoundary);
        const topDistance2 = Math.abs(toy - topBoundary);
        const topD = topDistance1 + topDistance2;
        const bottomDistance1 = Math.abs(soy - bottomBoundary);
        const bottomDistance2 = Math.abs(toy - bottomBoundary);
        const bottomD = bottomDistance1 + bottomDistance2;
        return [topD, bottomD];
      }
      function moveAndExpandBBox(bbox2, direction, margin) {
        switch (direction) {
          case Directions.LEFT:
            bbox2.inflate(0, margin).moveAndExpand({
              x: -margin,
              width: margin
            });
            break;
          case Directions.RIGHT:
            bbox2.inflate(0, margin).moveAndExpand({
              width: margin
            });
            break;
          case Directions.TOP:
            bbox2.inflate(margin, 0).moveAndExpand({
              y: -margin,
              height: margin
            });
            break;
          case Directions.BOTTOM:
            bbox2.inflate(margin, 0).moveAndExpand({
              height: margin
            });
            break;
        }
        return bbox2;
      }
      function routeBetweenPoints(source, target, opt = {}) {
        const {
          point: sourcePoint,
          x0: sx0,
          y0: sy0,
          width: sourceWidth,
          height: sourceHeight,
          margin: sourceMargin
        } = source;
        const {
          point: targetPoint,
          x0: tx0,
          y0: ty0,
          width: targetWidth,
          height: targetHeight,
          margin: targetMargin
        } = target;
        const {
          targetInSourceBBox = false
        } = opt;
        const tx1 = tx0 + targetWidth;
        const ty1 = ty0 + targetHeight;
        const sx1 = sx0 + sourceWidth;
        const sy1 = sy0 + sourceHeight;
        const smx0 = sx0 - sourceMargin;
        const smx1 = sx1 + sourceMargin;
        const smy0 = sy0 - sourceMargin;
        const smy1 = sy1 + sourceMargin;
        const tmx0 = tx0 - targetMargin;
        const tmx1 = tx1 + targetMargin;
        const tmy0 = ty0 - targetMargin;
        const tmy1 = ty1 + targetMargin;
        const [sourceSide, targetSide] = resolveSides(source, target);
        const sourceOutsidePoint = getOutsidePoint(sourceSide, {
          point: sourcePoint,
          x0: sx0,
          y0: sy0,
          width: sourceWidth,
          height: sourceHeight
        }, sourceMargin);
        const targetOutsidePoint = getOutsidePoint(targetSide, {
          point: targetPoint,
          x0: tx0,
          y0: ty0,
          width: targetWidth,
          height: targetHeight
        }, targetMargin);
        const {
          x: sox,
          y: soy
        } = sourceOutsidePoint;
        const {
          x: tox,
          y: toy
        } = targetOutsidePoint;
        const tcx = (tx0 + tx1) / 2;
        const tcy = (ty0 + ty1) / 2;
        const scx = (sx0 + sx1) / 2;
        const scy = (sy0 + sy1) / 2;
        const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;
        const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;
        const sourceBBox = new Rect(sx0, sy0, sourceWidth, sourceHeight);
        const targetBBox = new Rect(tx0, ty0, targetWidth, targetHeight);
        const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);
        const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);
        const sourceForDistance = Object.assign({}, source, {
          x1: sx1,
          y1: sy1,
          outsidePoint: sourceOutsidePoint,
          direction: sourceSide
        });
        const targetForDistance = Object.assign({}, target, {
          x1: tx1,
          y1: ty1,
          outsidePoint: targetOutsidePoint,
          direction: targetSide
        });
        const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);
        const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);
        if (sourceSide === "left" && targetSide === "right") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
          const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
          if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (soy + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: middleOfAnchors
            }, {
              x: tox,
              y: middleOfAnchors
            }, {
              x: tox,
              y: toy
            }];
          }
          if (smx0 < tox) {
            let y = middleOfHorizontalSides;
            let x1 = sox;
            let x2 = tox;
            const isUpwardsShorter = topD < bottomD;
            if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
              if (smy1 >= tmy0 && isUpwardsShorter) {
                y = Math.min(tmy0, smy0);
              } else if (smy0 <= tmy1 && !isUpwardsShorter) {
                y = Math.max(tmy1, smy1);
              }
              x1 = Math.min(sox, tmx0);
              x2 = Math.max(tox, smx1);
              if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
                x1 = sox;
              } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
                x2 = tox;
              }
            }
            return [{
              x: x1,
              y: soy
            }, {
              x: x1,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          const x = (sox + tox) / 2;
          return [{
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "right" && targetSide === "left") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
          const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
          if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (soy + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: middleOfAnchors
            }, {
              x: tox,
              y: middleOfAnchors
            }, {
              x: tox,
              y: toy
            }];
          }
          if (smx1 > tox) {
            let y = middleOfHorizontalSides;
            let x1 = sox;
            let x2 = tox;
            const isUpwardsShorter = topD < bottomD;
            if (y >= smy0 && y <= smy1 || y >= tmy0 && y <= tmy1) {
              if (smy1 >= tmy0 && isUpwardsShorter) {
                y = Math.min(tmy0, smy0);
              } else if (smy0 <= tmy1 && !isUpwardsShorter) {
                y = Math.max(tmy1, smy1);
              }
              x1 = Math.max(sox, tmx1);
              x2 = Math.min(tox, smx0);
              if (isUpwardsShorter && soy < ty0 || !isUpwardsShorter && soy > ty1) {
                x1 = sox;
              } else if (isUpwardsShorter && toy < sy0 || !isUpwardsShorter && toy > sy1) {
                x2 = tox;
              }
            }
            return [{
              x: x1,
              y: soy
            }, {
              x: x1,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          const x = (sox + tox) / 2;
          return [{
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "top" && targetSide === "bottom") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
          const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
          if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (sox + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: middleOfAnchors,
              y: soy
            }, {
              x: middleOfAnchors,
              y: toy
            }, {
              x: tox,
              y: toy
            }];
          }
          if (smy0 < toy) {
            let x = middleOfVerticalSides;
            let y1 = soy;
            let y2 = toy;
            const isLeftShorter = leftD < rightD;
            if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
              if (smx1 >= tmx0 && isLeftShorter) {
                x = Math.min(tmx0, smx0);
              } else if (smx0 <= tmx1 && !isLeftShorter) {
                x = Math.max(tmx1, smx1);
              }
              y1 = Math.min(soy, tmy0);
              y2 = Math.max(toy, smy1);
              if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
                y1 = soy;
              } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
                y2 = toy;
              }
            }
            return [{
              x: sox,
              y: y1
            }, {
              x,
              y: y1
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          const y = (soy + toy) / 2;
          return [{
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        } else if (sourceSide === "bottom" && targetSide === "top") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);
          const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);
          if (isPointInsideSource || isPointInsideTarget) {
            const middleOfAnchors = (sox + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: middleOfAnchors,
              y: soy
            }, {
              x: middleOfAnchors,
              y: toy
            }, {
              x: tox,
              y: toy
            }];
          }
          if (smy1 > toy) {
            let x = middleOfVerticalSides;
            let y1 = soy;
            let y2 = toy;
            const isLeftShorter = leftD < rightD;
            if (x >= smx0 && x <= smx1 || x >= tmx0 && x <= tmx1) {
              if (smx1 >= tmx0 && isLeftShorter) {
                x = Math.min(tmx0, smx0);
              } else if (smx0 <= tmx1 && !isLeftShorter) {
                x = Math.max(tmx1, smx1);
              }
              y1 = Math.max(soy, tmy1);
              y2 = Math.min(toy, smy0);
              if (isLeftShorter && sox < tx0 || !isLeftShorter && sox > tx1) {
                y1 = soy;
              } else if (isLeftShorter && tox < sx0 || !isLeftShorter && tox > sx1) {
                y2 = toy;
              }
            }
            return [{
              x: sox,
              y: y1
            }, {
              x,
              y: y1
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          const y = (soy + toy) / 2;
          return [{
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        } else if (sourceSide === "top" && targetSide === "top") {
          const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);
          if (useUShapeConnection && sox !== tox) {
            return [{
              x: sox,
              y: Math.min(soy, toy)
            }, {
              x: tox,
              y: Math.min(soy, toy)
            }];
          }
          let x;
          let y1 = Math.min((sy1 + ty0) / 2, toy);
          let y2 = Math.min((sy0 + ty1) / 2, soy);
          if (toy < soy) {
            if (rightD > leftD) {
              x = Math.min(sox, tmx0);
            } else {
              x = Math.max(sox, tmx1);
            }
          } else {
            if (rightD > leftD) {
              x = Math.min(tox, smx0);
            } else {
              x = Math.max(tox, smx1);
            }
          }
          return [{
            x: sox,
            y: y2
          }, {
            x,
            y: y2
          }, {
            x,
            y: y1
          }, {
            x: tox,
            y: y1
          }];
        } else if (sourceSide === "bottom" && targetSide === "bottom") {
          const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);
          if (useUShapeConnection && sox !== tox) {
            return [{
              x: sox,
              y: Math.max(soy, toy)
            }, {
              x: tox,
              y: Math.max(soy, toy)
            }];
          }
          let x;
          let y1 = Math.max((sy0 + ty1) / 2, toy);
          let y2 = Math.max((sy1 + ty0) / 2, soy);
          if (toy > soy) {
            if (rightD > leftD) {
              x = Math.min(sox, tmx0);
            } else {
              x = Math.max(sox, tmx1);
            }
          } else {
            if (rightD > leftD) {
              x = Math.min(tox, smx0);
            } else {
              x = Math.max(tox, smx1);
            }
          }
          return [{
            x: sox,
            y: y2
          }, {
            x,
            y: y2
          }, {
            x,
            y: y1
          }, {
            x: tox,
            y: y1
          }];
        } else if (sourceSide === "left" && targetSide === "left") {
          const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);
          if (useUShapeConnection && soy !== toy) {
            return [{
              x: Math.min(sox, tox),
              y: soy
            }, {
              x: Math.min(sox, tox),
              y: toy
            }];
          }
          let y;
          let x1 = Math.min((sx1 + tx0) / 2, tox);
          let x2 = Math.min((sx0 + tx1) / 2, sox);
          if (tox > sox) {
            if (topD <= bottomD) {
              y = Math.min(smy0, toy);
            } else {
              y = Math.max(smy1, toy);
            }
          } else {
            if (topD <= bottomD) {
              y = Math.min(tmy0, soy);
            } else {
              y = Math.max(tmy1, soy);
            }
          }
          return [{
            x: x2,
            y: soy
          }, {
            x: x2,
            y
          }, {
            x: x1,
            y
          }, {
            x: x1,
            y: toy
          }];
        } else if (sourceSide === "right" && targetSide === "right") {
          const useUShapeConnection = targetInSourceBBox || intersection$1.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);
          if (useUShapeConnection && soy !== toy) {
            return [{
              x: Math.max(sox, tox),
              y: soy
            }, {
              x: Math.max(sox, tox),
              y: toy
            }];
          }
          let y;
          let x1 = Math.max((sx0 + tx1) / 2, tox);
          let x2 = Math.max((sx1 + tx0) / 2, sox);
          if (tox <= sox) {
            if (topD <= bottomD) {
              y = Math.min(smy0, toy);
            } else {
              y = Math.max(smy1, toy);
            }
          } else {
            if (topD <= bottomD) {
              y = Math.min(tmy0, soy);
            } else {
              y = Math.max(tmy1, soy);
            }
          }
          return [{
            x: x2,
            y: soy
          }, {
            x: x2,
            y
          }, {
            x: x1,
            y
          }, {
            x: x1,
            y: toy
          }];
        } else if (sourceSide === "top" && targetSide === "right") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (sox <= tmx1) {
              const x2 = Math.max(sox + sourceMargin, tox);
              const y = Math.min(smy0, tmy0);
              return [{
                x: sox,
                y
              }, {
                x: x2,
                y
              }, {
                x: x2,
                y: toy
              }];
            }
            const anchorMiddleX = (sox - sourceMargin + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: anchorMiddleX,
              y: soy
            }, {
              x: anchorMiddleX,
              y: toy
            }];
          }
          if (smy0 > toy) {
            if (sox < tox) {
              let y = tmy0;
              if (tmy1 <= smy0 && tmx1 >= sox) {
                y = middleOfHorizontalSides;
              }
              return [{
                x: sox,
                y
              }, {
                x: tox,
                y
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: sox,
              y: toy
            }];
          }
          const x = Math.max(middleOfVerticalSides, tmx1);
          if (sox > tox && sy1 >= toy) {
            return [{
              x: sox,
              y: soy
            }, {
              x,
              y: soy
            }, {
              x,
              y: toy
            }];
          }
          if (x > smx0 && soy < ty1) {
            const y = Math.min(smy0, tmy0);
            const x2 = Math.max(smx1, tmx1);
            return [{
              x: sox,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "top" && targetSide === "left") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (sox >= tmx0) {
              const x2 = Math.min(sox - sourceMargin, tox);
              const y = Math.min(smy0, tmy0);
              return [{
                x: sox,
                y
              }, {
                x: x2,
                y
              }, {
                x: x2,
                y: toy
              }];
            }
            const anchorMiddleX = (sox + sourceMargin + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: anchorMiddleX,
              y: soy
            }, {
              x: anchorMiddleX,
              y: toy
            }];
          }
          if (smy0 > toy) {
            if (sox > tox) {
              let y = tmy0;
              if (tmy1 <= smy0 && tmx0 <= sox) {
                y = middleOfHorizontalSides;
              }
              return [{
                x: sox,
                y
              }, {
                x: tox,
                y
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: sox,
              y: toy
            }];
          }
          const x = Math.min(tmx0, middleOfVerticalSides);
          if (sox < tox && sy1 >= toy) {
            return [{
              x: sox,
              y: soy
            }, {
              x,
              y: soy
            }, {
              x,
              y: toy
            }];
          }
          if (x < smx1 && soy < ty1) {
            const y = Math.min(smy0, tmy0);
            const x2 = Math.min(smx0, tmx0);
            return [{
              x: sox,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "bottom" && targetSide === "right") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (sox <= tmx1) {
              const x2 = Math.max(sox + sourceMargin, tox);
              const y = Math.max(smy1, tmy1);
              return [{
                x: sox,
                y
              }, {
                x: x2,
                y
              }, {
                x: x2,
                y: toy
              }];
            }
            const anchorMiddleX = (sox - sourceMargin + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: anchorMiddleX,
              y: soy
            }, {
              x: anchorMiddleX,
              y: toy
            }];
          }
          if (smy1 < toy) {
            if (sox < tox) {
              let y = tmy1;
              if (tmy0 >= smy1 && tmx1 >= sox) {
                y = middleOfHorizontalSides;
              }
              return [{
                x: sox,
                y
              }, {
                x: tox,
                y
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: sox,
              y: toy
            }];
          }
          const x = Math.max(middleOfVerticalSides, tmx1);
          if (sox > tox && sy0 <= toy) {
            return [{
              x: sox,
              y: soy
            }, {
              x,
              y: soy
            }, {
              x,
              y: toy
            }];
          }
          if (x > smx0 && soy > ty0) {
            const y = Math.max(smy1, tmy1);
            const x2 = Math.max(smx1, tmx1);
            return [{
              x: sox,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "bottom" && targetSide === "left") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (sox >= tmx0) {
              const x2 = Math.min(sox - sourceMargin, tox);
              const y = Math.max(smy1, tmy1);
              return [{
                x: sox,
                y
              }, {
                x: x2,
                y
              }, {
                x: x2,
                y: toy
              }];
            }
            const anchorMiddleX = (sox + sourceMargin + tox) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: anchorMiddleX,
              y: soy
            }, {
              x: anchorMiddleX,
              y: toy
            }];
          }
          if (smy1 < toy) {
            if (sox > tox) {
              let y = tmy1;
              if (tmy0 >= smy1 && tmx0 <= sox) {
                y = middleOfHorizontalSides;
              }
              return [{
                x: sox,
                y
              }, {
                x: tox,
                y
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: sox,
              y: toy
            }];
          }
          const x = Math.min(tmx0, middleOfVerticalSides);
          if (sox < tox && sy0 <= toy) {
            return [{
              x: sox,
              y: soy
            }, {
              x,
              y: soy
            }, {
              x,
              y: toy
            }];
          }
          if (x < smx1 && soy > ty0) {
            const y = Math.max(smy1, tmy1);
            const x2 = Math.min(smx0, tmx0);
            return [{
              x: sox,
              y
            }, {
              x: x2,
              y
            }, {
              x: x2,
              y: toy
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x,
            y: soy
          }, {
            x,
            y: toy
          }];
        } else if (sourceSide === "left" && targetSide === "bottom") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (soy <= tmy1) {
              const x = Math.min(smx0, tmx0);
              const y2 = Math.max(soy + sourceMargin, toy);
              return [{
                x,
                y: soy
              }, {
                x,
                y: y2
              }, {
                x: tox,
                y: y2
              }];
            }
            const anchorMiddleY = (soy - sourceMargin + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: anchorMiddleY
            }, {
              x: tox,
              y: anchorMiddleY
            }];
          }
          if (smx0 > tox) {
            if (soy < toy) {
              let x = tmx0;
              if (tmx1 <= smx0 && tmy1 >= soy) {
                x = middleOfVerticalSides;
              }
              return [{
                x,
                y: soy
              }, {
                x,
                y: toy
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: tox,
              y: soy
            }];
          }
          const y = Math.max(tmy1, middleOfHorizontalSides);
          if (soy > toy && sx1 >= tox) {
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y
            }, {
              x: tox,
              y
            }];
          }
          if (y > smy0 && sox < tx1) {
            const x = Math.min(smx0, tmx0);
            const y2 = Math.max(smy1, tmy1);
            return [{
              x,
              y: soy
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        } else if (sourceSide === "left" && targetSide === "top") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (soy >= tmy0) {
              const y2 = Math.min(soy - sourceMargin, toy);
              const x = Math.min(smx0, tmx0);
              return [{
                x,
                y: soy
              }, {
                x,
                y: y2
              }, {
                x: tox,
                y: y2
              }];
            }
            const anchorMiddleY = (soy + sourceMargin + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: anchorMiddleY
            }, {
              x: tox,
              y: anchorMiddleY
            }];
          }
          if (smx0 > tox) {
            if (soy > toy) {
              let x = tmx0;
              if (tmx1 <= smx0 && tmy0 <= soy) {
                x = middleOfVerticalSides;
              }
              return [{
                x,
                y: soy
              }, {
                x,
                y: toy
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: tox,
              y: soy
            }];
          }
          const y = Math.min(tmy0, middleOfHorizontalSides);
          if (soy < toy && sx1 >= tox) {
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y
            }, {
              x: tox,
              y
            }];
          }
          if (y < smy1 && sox < tx1) {
            const x = Math.min(smx0, tmx0);
            const y2 = Math.min(smy0, tmy0);
            return [{
              x,
              y: soy
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        } else if (sourceSide === "right" && targetSide === "top") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (soy >= tmy0) {
              const x = Math.max(smx1, tmx1);
              const y2 = Math.min(soy - sourceMargin, toy);
              return [
                {
                  x,
                  y: soy
                },
                {
                  x,
                  y: y2
                },
                // Path adjustment for right side start
                {
                  x: tox,
                  y: y2
                }
              ];
            }
            const anchorMiddleY = (soy + sourceMargin + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: anchorMiddleY
            }, {
              x: tox,
              y: anchorMiddleY
            }];
          }
          if (smx1 < tox) {
            if (soy > toy) {
              let x = tmx1;
              if (tmx0 >= smx1 && tmy0 <= soy) {
                x = middleOfVerticalSides;
              }
              return [{
                x,
                y: soy
              }, {
                x,
                y: toy
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: tox,
              y: soy
            }];
          }
          const y = Math.min(tmy0, middleOfHorizontalSides);
          if (soy < toy && sx0 <= tox) {
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y
            }, {
              x: tox,
              y
            }];
          }
          if (y < smy1 && sox > tx0) {
            const x = Math.max(smx1, tmx1);
            const y2 = Math.min(smy0, tmy0);
            return [{
              x,
              y: soy
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        } else if (sourceSide === "right" && targetSide === "bottom") {
          const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);
          if (isPointInsideSource) {
            if (soy <= tmy1) {
              const x = Math.max(smx1, tmx1);
              const y2 = Math.max(soy + sourceMargin, toy);
              return [{
                x,
                y: soy
              }, {
                x,
                y: y2
              }, {
                x: tox,
                y: y2
              }];
            }
            const anchorMiddleY = (soy - sourceMargin + toy) / 2;
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y: anchorMiddleY
            }, {
              x: tox,
              y: anchorMiddleY
            }];
          }
          if (smx1 < tox) {
            if (soy < toy) {
              let x = tmx1;
              if (tmx0 >= smx1 && tmy1 >= soy) {
                x = middleOfVerticalSides;
              }
              return [{
                x,
                y: soy
              }, {
                x,
                y: toy
              }, {
                x: tox,
                y: toy
              }];
            }
            return [{
              x: tox,
              y: soy
            }];
          }
          const y = Math.max(tmy1, middleOfHorizontalSides);
          if (soy > toy && sx0 <= tox) {
            return [{
              x: sox,
              y: soy
            }, {
              x: sox,
              y
            }, {
              x: tox,
              y
            }];
          }
          if (y > smy0 && sox > tx0) {
            const x = Math.max(smx1, tmx1);
            const y2 = Math.max(smy1, tmy1);
            return [{
              x,
              y: soy
            }, {
              x,
              y: y2
            }, {
              x: tox,
              y: y2
            }];
          }
          return [{
            x: sox,
            y: soy
          }, {
            x: sox,
            y
          }, {
            x: tox,
            y
          }];
        }
      }
      function getLoopCoordinates(direction, angle, margin) {
        const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;
        let dx = 0;
        let dy = 0;
        switch (normalizeAngle(Math.round(angle))) {
          case 0:
          case 90:
            dx = isHorizontal ? 0 : margin;
            dy = isHorizontal ? margin : 0;
            break;
          case 180:
          case 270:
            dx = isHorizontal ? 0 : -margin;
            dy = isHorizontal ? -margin : 0;
            break;
        }
        return {
          dx,
          dy
        };
      }
      function rightAngleRouter(vertices, opt, linkView) {
        const {
          sourceDirection = Directions.AUTO,
          targetDirection = Directions.AUTO
        } = opt;
        const margin = opt.margin || 20;
        const useVertices = opt.useVertices || false;
        const isSourcePort = !!linkView.model.source().port;
        const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);
        const isTargetPort = !!linkView.model.target().port;
        const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);
        let resultVertices = [];
        if (!useVertices || vertices.length === 0) {
          return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));
        }
        const verticesData = vertices.map((v) => pointDataFromVertex(v));
        const [firstVertex] = verticesData;
        const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);
        const isElement = sourcePoint.view && sourcePoint.view.model.isElement();
        const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;
        const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;
        if (isVertexInside) {
          const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);
          const firstPointOverlap = outsidePoint.equals(firstVertex.point);
          const alignsVertically = sourcePoint.point.x === firstVertex.point.x;
          const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;
          const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);
          const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);
          const firstSegment = new Line(sourcePoint.point, outsidePoint);
          const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);
          const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);
          if (firstPointOverlap) {
            resultVertices.push(sourcePoint.point, firstVertex.point);
            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];
          } else if (isVertexOnSegment || isVertexAlignedAndInside) {
            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new Line(sourcePoint.point, firstVertex.point));
            const {
              dx,
              dy
            } = getLoopCoordinates(resolvedSourceDirection, angle, margin);
            const loop = createLoop({
              point: outsidePoint
            }, firstVertex, {
              dx,
              dy
            });
            const secondCreatedPoint = loop[2];
            const loopEndSegment = new Line(firstVertex.point, secondCreatedPoint);
            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];
            firstVertex.direction = accessDirection;
            resultVertices.push(...loop);
          } else {
            firstVertex.direction = resolvedSourceDirection;
            firstVertex.margin = margin;
            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, {
              targetInSourceBBox: true
            }), firstVertex.point);
          }
        } else {
          const next = verticesData[1] || targetPoint;
          const direction = resolveInitialDirection(sourcePoint, firstVertex, next);
          firstVertex.direction = direction;
          resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);
        }
        for (let i = 0; i < verticesData.length - 1; i++) {
          const from = verticesData[i];
          const to = verticesData[i + 1];
          const connectionSegment = new Line(from.point, to.point);
          const connectionSegmentAngle = getSegmentAngle(connectionSegment);
          if (connectionSegmentAngle % 90 === 0) {
            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
            const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);
            const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);
            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
              resultVertices.push(from.point, to.point);
              const [, toDirection2] = resolveSides(from, to);
              to.direction = toDirection2;
            } else {
              const {
                loopRoute,
                continueDirection
              } = loopSegment(from, to, connectionSegmentAngle, margin);
              to.direction = continueDirection;
              resultVertices.push(...loopRoute);
            }
            continue;
          }
          const [fromDirection, toDirection] = resolveDirection(from, to);
          from.direction = fromDirection;
          to.direction = toDirection;
          resultVertices.push(...routeBetweenPoints(from, to), to.point);
        }
        const lastVertex = verticesData[verticesData.length - 1];
        if (targetPoint.view && targetPoint.view.model.isElement()) {
          const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);
          const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);
          const simplified = simplifyPoints([...resultVertices, lastVertex.point]);
          const simplifiedSegment = new Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);
          const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));
          const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];
          const lastPointOverlap = outsidePoint.equals(lastVertex.point);
          if (!lastPointOverlap || lastPointOverlap && definedDirection === resolvedTargetDirection) {
            lastVertex.direction = definedDirection;
            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);
            const lastSegment = new Line(p1, p2);
            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));
            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];
            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);
            const alignsVertically = lastVertex.point.x === targetPoint.point.x;
            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;
            const isVertexInside2 = targetBBox.containsPoint(lastVertex.point);
            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);
            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);
            if (!lastPointOverlap && isVertexInside2 && (isHorizontalAndAligns || isVerticalAndAligns)) {
              const {
                dx,
                dy
              } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);
              lastSegmentRoute = createLoop(lastVertex, {
                point: outsidePoint
              }, {
                dx,
                dy
              });
            } else if (isVertexInside2 && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {
              lastVertex.margin = margin;
              lastVertex.direction = resolvedTargetDirection;
              lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {
              lastVertex.margin = margin;
              lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);
            }
            resultVertices.push(...lastSegmentRoute);
          }
        } else {
          const from = lastVertex;
          const to = targetPoint;
          const connectionSegment = new Line(from.point, to.point);
          const connectionSegmentAngle = getSegmentAngle(connectionSegment);
          if (connectionSegmentAngle % 90 === 0) {
            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];
            const simplifiedRoute = simplifyPoints(resultVertices);
            const accessSegment = new Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);
            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];
            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {
              resultVertices.push(from.point);
            } else {
              const {
                loopRoute
              } = loopSegment(from, to, connectionSegmentAngle, margin);
              loopRoute.pop();
              resultVertices.push(...loopRoute);
            }
          } else {
            const [fromDirection, toDirection] = resolveDirection(from, to);
            from.direction = fromDirection;
            to.direction = toDirection;
            resultVertices.push(...routeBetweenPoints(from, to));
          }
        }
        return simplifyPoints(resultVertices);
      }
      function resolveDirection(from, to) {
        const accessDirection = from.direction;
        const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);
        let sourceDirection = from.direction;
        let targetDirection = to.direction;
        if (isDirectionVertical) {
          const isToAbove = from.point.y > to.point.y;
          const dx = to.point.x - from.point.x;
          if (accessDirection === Directions.BOTTOM) {
            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;
            if (dx > 0) {
              targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;
            } else if (dx < 0) {
              targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;
            }
          } else {
            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];
            if (dx > 0) {
              targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;
            } else if (dx < 0) {
              targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;
            }
          }
        } else {
          const isToLeft = from.point.x > to.point.x;
          const dy = to.point.y - from.point.y;
          if (accessDirection === Directions.RIGHT) {
            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;
            if (dy > 0) {
              targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;
            } else if (dy < 0) {
              targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;
            }
          } else {
            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];
            if (dy > 0) {
              targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;
            } else if (dy < 0) {
              targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;
            }
          }
        }
        return [sourceDirection, targetDirection];
      }
      rightAngleRouter.Directions = Directions;
      const rightAngle = rightAngleRouter;
      var routers = {
        __proto__: null,
        manhattan,
        metro,
        normal,
        oneSide,
        orthogonal,
        rightAngle
      };
      function connectionRatio(view, _magnet, _refPoint, opt) {
        var ratio = "ratio" in opt ? opt.ratio : 0.5;
        return view.getPointAtRatio(ratio);
      }
      function connectionLength(view, _magnet, _refPoint, opt) {
        var length2 = "length" in opt ? opt.length : 20;
        return view.getPointAtLength(length2);
      }
      function _connectionPerpendicular(view, _magnet, refPoint, opt) {
        var OFFSET = 1e6;
        var path2 = view.getConnection();
        var segmentSubdivisions = view.getConnectionSubdivisions();
        var verticalLine = new Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));
        var horizontalLine = new Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));
        var verticalIntersections = verticalLine.intersect(path2, {
          segmentSubdivisions
        });
        var horizontalIntersections = horizontalLine.intersect(path2, {
          segmentSubdivisions
        });
        var intersections = [];
        if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);
        if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);
        if (intersections.length > 0) return refPoint.chooseClosest(intersections);
        if ("fallbackAt" in opt) {
          return getPointAtLink(view, opt.fallbackAt);
        }
        return connectionClosest(view, _magnet, refPoint, opt);
      }
      function _connectionClosest(view, _magnet, refPoint, _opt) {
        var closestPoint = view.getClosestPoint(refPoint);
        if (!closestPoint) return new Point();
        return closestPoint;
      }
      function resolveRef(fn2) {
        return function(view, magnet, ref, opt, endType, linkView) {
          if (ref instanceof Element) {
            var refView = this.paper.findView(ref);
            var refPoint;
            if (refView) {
              if (refView.isNodeConnection(ref)) {
                var distance = "fixedAt" in opt ? opt.fixedAt : "50%";
                refPoint = getPointAtLink(refView, distance);
              } else {
                refPoint = refView.getNodeBBox(ref).center();
              }
            } else {
              refPoint = new Point();
            }
            return fn2.call(this, view, magnet, refPoint, opt, endType, linkView);
          }
          return fn2.apply(this, arguments);
        };
      }
      function getPointAtLink(view, value) {
        var parsedValue = parseFloat(value);
        if (isPercentage(value)) {
          return view.getPointAtRatio(parsedValue / 100);
        } else {
          return view.getPointAtLength(parsedValue);
        }
      }
      const connectionPerpendicular = resolveRef(_connectionPerpendicular);
      const connectionClosest = resolveRef(_connectionClosest);
      var linkAnchors = {
        __proto__: null,
        connectionClosest,
        connectionLength,
        connectionPerpendicular,
        connectionRatio,
        resolveRef
      };
      const Side = {
        LEFT: "left",
        RIGHT: "right",
        TOP: "top",
        BOTTOM: "bottom"
      };
      const SideMode = {
        PREFER_HORIZONTAL: "prefer-horizontal",
        PREFER_VERTICAL: "prefer-vertical",
        HORIZONTAL: "horizontal",
        VERTICAL: "vertical",
        AUTO: "auto"
      };
      function getModelBBoxFromConnectedLink(element, link, endType, rotate) {
        const portId = link.get(endType).port;
        if (element.hasPort(portId)) {
          return element.getPortBBox(portId, {
            rotate
          });
        }
        return element.getBBox({
          rotate
        });
      }
      function getMiddleSide(rect2, point2, opt) {
        const {
          preferenceThreshold = 0,
          mode
        } = opt;
        const {
          x,
          y
        } = point2;
        const {
          x: left2,
          y: top2,
          width: width2,
          height: height2
        } = rect2;
        switch (mode) {
          case SideMode.PREFER_VERTICAL: {
            const {
              top: topThreshold,
              bottom: bottomThreshold
            } = normalizeSides(preferenceThreshold);
            const bottom2 = top2 + height2;
            if (y > top2 - topThreshold && y < bottom2 + bottomThreshold) {
              const cx = left2 + width2 / 2;
              return x < cx ? Side.LEFT : Side.RIGHT;
            }
          }
          // eslint-disable-next-line no-fallthrough
          case SideMode.VERTICAL: {
            const cy = top2 + height2 / 2;
            return y < cy ? Side.TOP : Side.BOTTOM;
          }
          case SideMode.PREFER_HORIZONTAL: {
            const {
              left: leftThreshold,
              right: rightThreshold
            } = normalizeSides(preferenceThreshold);
            const right2 = left2 + width2;
            if (x > left2 - leftThreshold && x < right2 + rightThreshold) {
              const cy = top2 + height2 / 2;
              return y < cy ? Side.TOP : Side.BOTTOM;
            }
          }
          // eslint-disable-next-line no-fallthrough
          case SideMode.HORIZONTAL: {
            const cx = left2 + width2 / 2;
            return x < cx ? Side.LEFT : Side.RIGHT;
          }
          case SideMode.AUTO:
          default: {
            return rect2.sideNearestToPoint(point2);
          }
        }
      }
      function bboxWrapper(method) {
        return function(elementView, magnet, ref, opt, endType, linkView) {
          const rotate = !!opt.rotate;
          const element = elementView.model;
          const link = linkView.model;
          const angle = element.angle();
          let bbox2, center2;
          if (opt.useModelGeometry) {
            bbox2 = getModelBBoxFromConnectedLink(element, link, endType, !rotate);
            center2 = bbox2.center();
          } else {
            center2 = element.getCenter();
            bbox2 = rotate ? elementView.getNodeUnrotatedBBox(magnet) : elementView.getNodeBBox(magnet);
          }
          const anchor2 = bbox2[method]();
          let dx = opt.dx;
          if (dx) {
            const isDxPercentage = isPercentage(dx);
            if (!isDxPercentage && isCalcExpression(dx)) {
              dx = Number(evalCalcExpression(dx, bbox2));
            } else {
              dx = parseFloat(dx);
            }
            if (isFinite(dx)) {
              if (isDxPercentage) {
                dx /= 100;
                dx *= bbox2.width;
              }
              anchor2.x += dx;
            }
          }
          let dy = opt.dy;
          if (dy) {
            const isDyPercentage = isPercentage(dy);
            if (!isDyPercentage && isCalcExpression(dy)) {
              dy = Number(evalCalcExpression(dy, bbox2));
            } else {
              dy = parseFloat(dy);
            }
            if (isFinite(dy)) {
              if (isDyPercentage) {
                dy /= 100;
                dy *= bbox2.height;
              }
              anchor2.y += dy;
            }
          }
          return rotate ? anchor2.rotate(center2, -angle) : anchor2;
        };
      }
      function _perpendicular(elementView, magnet, refPoint, opt, endType, linkView) {
        const element = elementView.model;
        const angle = element.angle();
        let bbox2;
        if (opt.useModelGeometry) {
          bbox2 = getModelBBoxFromConnectedLink(element, linkView.model, endType, true);
        } else {
          bbox2 = elementView.getNodeBBox(magnet);
        }
        const anchor2 = bbox2.center();
        const topLeft2 = bbox2.origin();
        const bottomRight2 = bbox2.corner();
        let padding = opt.padding;
        if (!isFinite(padding)) padding = 0;
        if (topLeft2.y + padding <= refPoint.y && refPoint.y <= bottomRight2.y - padding) {
          var dy = refPoint.y - anchor2.y;
          anchor2.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(toRad(angle));
          anchor2.y += dy;
        } else if (topLeft2.x + padding <= refPoint.x && refPoint.x <= bottomRight2.x - padding) {
          var dx = refPoint.x - anchor2.x;
          anchor2.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(toRad(angle));
          anchor2.x += dx;
        }
        return anchor2;
      }
      function _midSide(view, magnet, refPoint, opt, endType, linkView) {
        var rotate = !!opt.rotate;
        var angle = view.model.angle();
        var center2 = view.model.getCenter();
        var bbox2;
        if (opt.useModelGeometry) {
          bbox2 = getModelBBoxFromConnectedLink(view.model, linkView.model, endType, !rotate);
          center2 = bbox2.center();
        } else {
          bbox2 = rotate ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);
        }
        var padding = opt.padding;
        if (isFinite(padding)) bbox2.inflate(padding);
        if (rotate) refPoint.rotate(center2, angle);
        var side = getMiddleSide(bbox2, refPoint, opt);
        var anchor2;
        switch (side) {
          case Side.LEFT:
            anchor2 = bbox2.leftMiddle();
            break;
          case Side.RIGHT:
            anchor2 = bbox2.rightMiddle();
            break;
          case Side.TOP:
            anchor2 = bbox2.topMiddle();
            break;
          case Side.BOTTOM:
            anchor2 = bbox2.bottomMiddle();
            break;
        }
        return rotate ? anchor2.rotate(center2, -angle) : anchor2;
      }
      function _modelCenter(view, _magnet, _refPoint, opt, endType) {
        return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);
      }
      const center = bboxWrapper("center");
      const top = bboxWrapper("topMiddle");
      const bottom = bboxWrapper("bottomMiddle");
      const left = bboxWrapper("leftMiddle");
      const right = bboxWrapper("rightMiddle");
      const topLeft = bboxWrapper("origin");
      const topRight = bboxWrapper("topRight");
      const bottomLeft = bboxWrapper("bottomLeft");
      const bottomRight = bboxWrapper("corner");
      const perpendicular = resolveRef(_perpendicular);
      const midSide = resolveRef(_midSide);
      const modelCenter = _modelCenter;
      var anchors = {
        __proto__: null,
        bottom,
        bottomLeft,
        bottomRight,
        center,
        left,
        midSide,
        modelCenter,
        perpendicular,
        right,
        top,
        topLeft,
        topRight
      };
      class GraphLayersController extends Listener {
        constructor(options) {
          super(options);
          this.callbackArguments = [];
          const graph = options.graph;
          if (!graph) {
            throw new Error('GraphLayersController: "graph" option is required.');
          }
          this.graph = graph;
          this.layerCollection = graph.layerCollection;
          this.startListening();
        }
        startListening() {
          this.listenTo(this.layerCollection, "all", this.onLayerCollectionEvent);
        }
        /**
         * @description When a cell changes its layer attribute,
         * move the cell to the target layer.
         */
        onCellChange(cell, options) {
          if (!cell.hasChanged(config$3.layerAttribute)) return;
          const targetLayerId = this.graph.getCellLayerId(cell);
          this.layerCollection.moveCellBetweenLayers(cell, targetLayerId, options);
        }
        /**
         * @description When a cell is removed from a layer,
         * also remove its embeds and connected links from the graph.
         * Note: an embedded cell might come from a different layer,
         * so we can not use the layer's cell collection to remove it.
         */
        onCellRemove(cell, options) {
          if (options.fromLayer) return;
          if (options.replace) return;
          const parentCell = cell.getParentCell();
          if (parentCell) {
            parentCell.unembed(cell, options);
          }
          const embeddedCells = cell.getEmbeddedCells();
          for (let i = 0, n = embeddedCells.length; i < n; i++) {
            const embed = embeddedCells[i];
            if (embed) {
              this.layerCollection.removeCell(embed, options);
            }
          }
          if (!options.clear) {
            if (options.disconnectLinks) {
              this.graph.disconnectLinks(cell, options);
            } else {
              this.graph.removeLinks(cell, options);
            }
          }
        }
        onLayerCollectionEvent(eventName, model) {
          if (!model) return;
          if (model[CELL_MARKER]) {
            switch (eventName) {
              case "change":
                this.onCellChange.call(this, model, arguments[2]);
                break;
              case "remove":
                this.onCellRemove.call(this, model, arguments[3]);
                break;
            }
            this.forwardCellEvent.apply(this, arguments);
            return;
          }
          if (model[CELL_COLLECTION_MARKER]) {
            this.forwardCellCollectionEvent.apply(this, arguments);
            return;
          }
          if (model[GRAPH_LAYER_MARKER]) {
            this.forwardLayerEvent.apply(this, arguments);
            return;
          }
          if (model[GRAPH_LAYER_COLLECTION_MARKER]) {
            this.forwardLayerCollectionEvent.apply(this, arguments);
            return;
          }
        }
        forwardLayerEvent() {
          this.graph.trigger.apply(this.graph, arguments);
        }
        forwardCellEvent(eventName, cell) {
          var _arguments$;
          if ((eventName === "remove" || eventName === "add") && (_arguments$ = arguments[3]) !== null && _arguments$ !== void 0 && _arguments$.fromLayer) return;
          this.graph.trigger.apply(this.graph, arguments);
        }
        forwardCellCollectionEvent(eventName) {
          if (eventName !== "sort") return;
          this.graph.trigger.apply(this.graph, arguments);
        }
        forwardLayerCollectionEvent(eventName) {
          if (eventName === "reset") {
            return;
          }
          arguments[0] = "layers:" + arguments[0];
          this.graph.trigger.apply(this.graph, arguments);
        }
      }
      class CellCollection extends Collection {
        [CELL_COLLECTION_MARKER] = true;
        initialize(_models, opt) {
          this.layer = opt.layer;
        }
        // Method for checking whether an object should be considered a model for
        // the purposes of adding to the collection.
        _isModel(model) {
          return Boolean(model[CELL_MARKER]);
        }
        // Overriding the default `model` method to create cell models
        // based on their `type` attribute and the `cellNamespace` option.
        model(attrs, opt) {
          const namespace = this.cellNamespace;
          if (!namespace) {
            throw new Error("dia.CellCollection: cellNamespace is required to instantiate a Cell from JSON.");
          }
          const {
            type
          } = attrs;
          const ModelClass = getByPath(namespace, type, ".");
          if (!ModelClass) {
            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);
          }
          return new ModelClass(attrs, opt);
        }
        // Override to set graph reference
        _addReference(model, options) {
          super._addReference(model, options);
          if (!options.dry && !model.graph) {
            model.graph = this.layer.graph;
          }
        }
        // Override to remove graph reference
        _removeReference(model, options) {
          super._removeReference(model, options);
          if (!options.dry && model.graph === this.layer.graph) {
            model.graph = null;
          }
        }
        // remove graph reference additionally
        _removeReferenceFast(model, options) {
          model.off("all", this._onModelEvent, this);
          if (!options.dry) {
            if (this === model.collection) {
              delete model.collection;
            }
            if (model.graph === this.layer.graph) {
              model.graph = null;
            }
          }
        }
        // `comparator` makes it easy to sort cells based on their `z` index.
        comparator(model) {
          return model.get("z") || 0;
        }
        // This method overrides base mvc.Collection implementation
        // in a way that improves performance of resetting large collections.
        // For layers specifically, there is an option where we put references
        // from the main collection in order to improve performance when
        // there is only one layer
        reset(models, options) {
          options = assign({}, {
            add: true,
            remove: false,
            merge: false
          }, options);
          for (let i = 0; i < this.models.length; i++) {
            this._removeReferenceFast(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          for (let i = 0; i < models.length; i++) {
            const model = this._prepareModel(models[i], options);
            if (model) {
              this.models.push(model);
              this._addReference(model, options);
            }
          }
          this.length = this.models.length;
          const sort = this.comparator && options.sort !== false;
          if (sort) {
            this.sort({
              silent: true
            });
          }
          if (!options.silent) {
            this.trigger("reset", this, options);
          }
          return this.models;
        }
        minZIndex() {
          var _this$first;
          return ((_this$first = this.first()) === null || _this$first === void 0 ? void 0 : _this$first.get("z")) || 0;
        }
        maxZIndex() {
          var _this$last;
          return ((_this$last = this.last()) === null || _this$last === void 0 ? void 0 : _this$last.get("z")) || 0;
        }
      }
      const DEFAULT_GRAPH_LAYER_TYPE = "GraphLayer";
      class GraphLayer extends Model {
        [GRAPH_LAYER_MARKER] = true;
        preinitialize() {
          this.eventPrefix = "layer:";
        }
        defaults() {
          return {
            type: DEFAULT_GRAPH_LAYER_TYPE
          };
        }
        initialize(attrs, options = {}) {
          super.initialize(attrs, options);
          this.cellCollection = new CellCollection([], {
            layer: this
          });
          this.cellCollection.on("all", this.trigger, this);
          this.cellCollection.on("change", this.onCellChange, this);
        }
        onCellChange(cell, opt) {
          if (opt.sort === false || !cell.hasChanged("z")) return;
          this.cellCollection.sort();
        }
        /**
         * @public
         * @description Returns all cells in this layer.
         */
        getCells() {
          return this.cellCollection.toArray();
        }
      }
      const GraphLayerCollection = Collection.extend({
        defaultLayerNamespace: {
          GraphLayer
        },
        /**
         * @override
         * @description Initializes the collection and sets up the layer and cell namespaces.
         */
        initialize: function(_models, options = {}) {
          const {
            layerNamespace,
            cellNamespace,
            graph
          } = options;
          this.layerNamespace = assign({}, this.defaultLayerNamespace, layerNamespace);
          if (cellNamespace) {
            this.cellNamespace = cellNamespace;
          } else {
            this.cellNamespace = typeof joint !== "undefined" && has(joint, "shapes") ? joint.shapes : null;
          }
          this.graph = graph;
        },
        /**
         * @override
         * @description Overrides the default `model` method
         * to create layer models based on their `type` attribute.
         */
        model: function(attrs, opt) {
          const collection = opt.collection;
          const namespace = collection.layerNamespace;
          const {
            type
          } = attrs;
          const GraphLayerClass = getByPath(namespace, type, ".");
          if (!GraphLayerClass) {
            throw new Error(`dia.Graph: Could not find layer constructor for type: '${type}'. Make sure to add the constructor to 'layerNamespace'.`);
          }
          return new GraphLayerClass(attrs, opt);
        },
        // Override to set graph reference
        _addReference(layer, options) {
          Collection.prototype._addReference.call(this, layer, options);
          layer.graph = this.graph;
          layer.cellCollection.cellNamespace = this.cellNamespace;
        },
        // Override to remove graph reference
        _removeReference(layer, options) {
          Collection.prototype._removeReference.call(this, layer, options);
          layer.graph = null;
          layer.cellCollection.cellNamespace = null;
        },
        /**
         * @override
         * @description Overrides the default `_prepareModel` method
         * to set default layer type if missing.
         */
        _prepareModel: function(attrs, options) {
          if (!attrs[GRAPH_LAYER_MARKER]) {
            if (!attrs.type) {
              const preparedAttributes = clone$1(attrs);
              preparedAttributes.type = DEFAULT_GRAPH_LAYER_TYPE;
              arguments[0] = preparedAttributes;
            }
          }
          return Collection.prototype._prepareModel.apply(this, arguments);
        },
        /**
         * @override
         * @description Add an assertion to prevent direct resetting of the collection.
         */
        reset(models, options) {
          this._assertInternalCall(options);
          return Collection.prototype.reset.apply(this, arguments);
        },
        /**
         * @override
         * @description Add an assertion to prevent direct addition of layers.
         */
        add(models, options) {
          this._assertInternalCall(options);
          return Collection.prototype.add.apply(this, arguments);
        },
        /**
         * @override
         * @description Add an assertion to prevent direct removal of layers.
         */
        remove(models, options) {
          this._assertInternalCall(options);
          return Collection.prototype.remove.apply(this, arguments);
        },
        /**
         * @override
         * @description Overrides the default `_onModelEvent` method
         * to distinguish between events coming from different model types.
         */
        _onModelEvent(_, model) {
          if (model && model[CELL_MARKER]) {
            this.trigger.apply(this, arguments);
            return;
          }
          Collection.prototype._onModelEvent.apply(this, arguments);
        },
        /**
         * @protected
         * @description Asserts that the collection manipulation
         * is done via internal graph methods. Otherwise, it throws an error.
         * This is a temporary measure until layers API is stabilized.
         */
        _assertInternalCall(options) {
          if (options && !options.graph && !options.silent) {
            throw new Error("dia.GraphLayerCollection: direct manipulation of the collection is not supported, use graph methods instead.");
          }
        },
        /**
         * @public
         * @description Inserts a layer before another layer or at the end if `beforeLayerId` is null.
         */
        insert(layerInit, beforeLayerId = null, options = {}) {
          const id2 = layerInit.id;
          if (id2 === beforeLayerId) {
            return;
          }
          if (beforeLayerId && !this.has(beforeLayerId)) {
            throw new Error(`dia.GraphLayerCollection: Layer "${beforeLayerId}" does not exist`);
          }
          let currentIndex = -1;
          if (this.has(id2)) {
            currentIndex = this.findIndex((l) => l.id === id2);
            if (currentIndex === this.length - 1 && !beforeLayerId) {
              return;
            }
            this.remove(id2, {
              silent: true
            });
          }
          let insertAt;
          if (!beforeLayerId) {
            insertAt = this.length;
          } else {
            insertAt = this.findIndex((l) => l.id === beforeLayerId);
          }
          if (currentIndex !== -1) {
            this.add(layerInit, {
              at: insertAt,
              silent: true
            });
            this.trigger("sort", this, options);
          } else {
            this.add(layerInit, {
              ...options,
              at: insertAt
            });
          }
        },
        /**
         * @public
         * @description Finds and returns a cell by its id from all layers.
         */
        getCell(cellRef) {
          for (const layer of this.models) {
            const cell = layer.cellCollection.get(cellRef);
            if (cell) {
              return cell;
            }
          }
          return void 0;
        },
        /**
         * @public
         * @description Returns all cells in all layers in the correct order.
         */
        getCells() {
          const layers = this.models;
          if (layers.length === 1) {
            return layers[0].getCells();
          }
          const cells = [];
          for (const layer of layers) {
            Array.prototype.push.apply(cells, layer.cellCollection.models);
          }
          return cells;
        },
        /**
         * @public
         * @description Removes a cell from its current layer.
         */
        removeCell(cell, options = {}) {
          var _cell$collection;
          const cellCollection = (_cell$collection = cell.collection) === null || _cell$collection === void 0 || (_cell$collection = _cell$collection.layer) === null || _cell$collection === void 0 ? void 0 : _cell$collection.cellCollection;
          if (!cellCollection) return;
          cellCollection.remove(cell, options);
        },
        /**
         * @public
         * @description Move a cell from its current layer to a target layer.
         */
        moveCellBetweenLayers(cell, targetLayerId, options = {}) {
          var _cell$collection2;
          const sourceLayer = (_cell$collection2 = cell.collection) === null || _cell$collection2 === void 0 ? void 0 : _cell$collection2.layer;
          if (!sourceLayer) {
            throw new Error("dia.GraphLayerCollection: cannot move a cell that is not part of any layer.");
          }
          const targetLayer = this.get(targetLayerId);
          if (!targetLayer) {
            throw new Error(`dia.GraphLayerCollection: cannot move cell to layer '${targetLayerId}' because such layer does not exist.`);
          }
          if (sourceLayer === targetLayer) {
            return;
          }
          const moveOptions = {
            ...options,
            fromLayer: sourceLayer.id,
            toLayer: targetLayer.id
          };
          sourceLayer.cellCollection.remove(cell, moveOptions);
          targetLayer.cellCollection.add(cell, moveOptions);
          cell.trigger("move", cell, moveOptions);
        },
        /**
         * @public
         * @description Adds a cell to the specified layer.
         */
        addCellToLayer(cell, layerId, options = {}) {
          const targetLayer = this.get(layerId);
          if (!targetLayer) {
            throw new Error(`dia.GraphLayerCollection: layer "${layerId}" does not exist.`);
          }
          const addOptions2 = {
            ...options,
            toLayer: targetLayer.id
          };
          targetLayer.cellCollection.add(cell, addOptions2);
        }
      });
      Object.defineProperty(GraphLayerCollection.prototype, GRAPH_LAYER_COLLECTION_MARKER, {
        value: true
      });
      class GraphTopologyIndex extends Listener {
        constructor(options) {
          super(options);
          this.callbackArguments = [];
          this.layerCollection = options.layerCollection;
          if (!this.layerCollection) {
            throw new Error('GraphTopologyIndex: "layerCollection" option is required.');
          }
          this.initializeIndex();
          this.startListening();
        }
        /**
         * @public
         * @description Start listening to graph and layer collection events
         * to maintain the topology index.
         */
        startListening() {
          this.listenTo(this.layerCollection.graph, {
            "add": this._restructureOnAdd,
            "remove": this._restructureOnRemove,
            "reset": this._restructureOnReset
          });
          this.listenTo(this.layerCollection, {
            "change:source": this._restructureOnChangeSource,
            "change:target": this._restructureOnChangeTarget
          });
        }
        /**
         * @protected
         * @description Initialize the internal data structures.
         */
        initializeIndex() {
          this._out = {};
          this._in = {};
          this._nodes = {};
          this._edges = {};
        }
        /**
         * @protected
         * @description Restructure the topology index on graph reset.
         * E.g. when fromJSON or resetCells is called.
         */
        _restructureOnReset() {
          this.initializeIndex();
          this.layerCollection.getCells().forEach(this._restructureOnAdd, this);
        }
        /**
         * @protected
         * @description Restructure the topology index on cell addition.
         * @param {dia.Cell} cell - The cell being added.
         */
        _restructureOnAdd(cell) {
          if (cell.isLink()) {
            this._edges[cell.id] = true;
            const {
              source,
              target
            } = cell.attributes;
            if (source.id) {
              (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;
            }
            if (target.id) {
              (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;
            }
          } else {
            this._nodes[cell.id] = true;
          }
        }
        /**
         * @protected
         * @description Restructure the topology index on cell removal.
         * @param {dia.Cell} cell - The cell being removed.
         */
        _restructureOnRemove(cell) {
          if (cell.isLink()) {
            delete this._edges[cell.id];
            const {
              source,
              target
            } = cell.attributes;
            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {
              delete this._out[source.id][cell.id];
            }
            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {
              delete this._in[target.id][cell.id];
            }
          } else {
            delete this._nodes[cell.id];
          }
        }
        /**
         * @protected
         * @description Restructure the topology index on link source change.
         * @param {dia.Link} link - The link being changed.
         */
        _restructureOnChangeSource(link) {
          const prevSource = link.previous("source");
          if (prevSource.id && this._out[prevSource.id]) {
            delete this._out[prevSource.id][link.id];
          }
          const source = link.attributes.source;
          if (source.id) {
            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;
          }
        }
        /**
         * @protected
         * @description Restructure the topology index on link target change.
         * @param {dia.Link} link - The link being changed.
         */
        _restructureOnChangeTarget(link) {
          const prevTarget = link.previous("target");
          if (prevTarget.id && this._in[prevTarget.id]) {
            delete this._in[prevTarget.id][link.id];
          }
          const target = link.get("target");
          if (target.id) {
            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;
          }
        }
        /**
         * @public
         * @description Get all outbound edges for the node. Time complexity: O(1).
         * @param {string} nodeId - The id of the node.
         * @returns {Object} - An object of the form: [edgeId] -> true.
         */
        getOutboundEdges(nodeId) {
          return this._out[nodeId] || {};
        }
        /**
         * @public
         * @description Get all inbound edges for the node. Time complexity: O(1).
         * @param {string} nodeId - The id of the node.
         * @returns {Object} - An object of the form: [edgeId] -> true.
         */
        getInboundEdges(nodeId) {
          return this._in[nodeId] || {};
        }
        /**
         * @public
         * @description Get all sink nodes (leafs) in the graph. Time complexity: O(|V|).
         * @returns {string[]} - Array of node ids.
         */
        getSinkNodes() {
          const sinks = [];
          for (const nodeId in this._nodes) {
            if (!this._out[nodeId] || isEmpty(this._out[nodeId])) {
              sinks.push(nodeId);
            }
          }
          return sinks;
        }
        /**
         * @public
         * @description Get all source nodes (roots) in the graph. Time complexity: O(|V|).
         * @returns {string[]} - Array of node ids.
         */
        getSourceNodes() {
          const sources = [];
          for (const nodeId in this._nodes) {
            if (!this._in[nodeId] || isEmpty(this._in[nodeId])) {
              sources.push(nodeId);
            }
          }
          return sources;
        }
        /**
         * @public
         * @description Return `true` if `nodeId` is a source node (root). Time complexity: O(1).
         * @param {string} nodeId - The id of the node to check.
         * @returns {boolean}
         */
        isSourceNode(nodeId) {
          return !this._in[nodeId] || isEmpty(this._in[nodeId]);
        }
        /**
         * @public
         * @description Return `true` if `nodeId` is a sink node (leaf). Time complexity: O(1).
         * @param {string} nodeId - The id of the node to check.
         * @returns {boolean}
         */
        isSinkNode(nodeId) {
          return !this._out[nodeId] || isEmpty(this._out[nodeId]);
        }
      }
      const DEFAULT_LAYER_ID = "cells";
      const Graph = Model.extend({
        /**
         * @todo Remove in v5.0.0
         * @description In legacy mode, the information about layers is not
         * exported into JSON.
         */
        legacyMode: true,
        /**
         * @protected
         * @description The ID of the default layer.
         */
        defaultLayerId: DEFAULT_LAYER_ID,
        initialize: function(attrs, options = {}) {
          const layerCollection = this.layerCollection = new GraphLayerCollection([], {
            layerNamespace: options.layerNamespace,
            cellNamespace: options.cellNamespace,
            graph: this,
            /** @deprecated use cellNamespace instead */
            model: options.cellModel
          });
          layerCollection.add({
            id: DEFAULT_LAYER_ID
          }, {
            graph: this.cid
          });
          this.attributes.cells = this.getLayer(DEFAULT_LAYER_ID).cellCollection;
          this.layersController = new GraphLayersController({
            graph: this
          });
          this.topologyIndex = new GraphTopologyIndex({
            layerCollection
          });
          this._batches = {};
        },
        toJSON: function(opt = {}) {
          const {
            layerCollection
          } = this;
          const json = Model.prototype.toJSON.apply(this, arguments);
          json.cells = this.getCells().map((cell) => cell.toJSON(opt.cellAttributes));
          if (this.legacyMode) {
            return json;
          }
          json.layers = layerCollection.toJSON();
          json.defaultLayer = this.defaultLayerId;
          return json;
        },
        fromJSON: function(json, opt) {
          const {
            cells,
            layers,
            defaultLayer,
            ...attributes2
          } = json;
          if (!cells) {
            throw new Error("Graph JSON must contain cells array.");
          }
          this.set(attributes2, {
            silent: true
          });
          if (layers) {
            this._resetLayers(layers, defaultLayer, opt);
          }
          if (cells) {
            this.resetCells(cells, opt);
          }
          return this;
        },
        /** @deprecated  */
        clear: function(opt) {
          opt = assign({}, opt, {
            clear: true
          });
          const cells = this.getCells();
          if (cells.length === 0) return this;
          this.startBatch("clear", opt);
          const sortedCells = sortBy(cells, (cell) => {
            return cell.isLink() ? 1 : 2;
          });
          do {
            this.layerCollection.removeCell(sortedCells.shift(), opt);
          } while (sortedCells.length > 0);
          this.stopBatch("clear");
          return this;
        },
        _prepareCell: function(cellInit, opt) {
          let cellAttributes;
          if (cellInit[CELL_MARKER]) {
            cellAttributes = cellInit.attributes;
          } else {
            cellAttributes = cellInit;
          }
          if (!isString(cellAttributes.type)) {
            throw new TypeError("dia.Graph: cell type must be a string.");
          }
          if (opt && opt.ensureZIndex) {
            if (cellAttributes.z === void 0) {
              const layerId = cellAttributes[config$3.layerAttribute] || this.defaultLayerId;
              const zIndex = this.maxZIndex(layerId) + 1;
              if (cellInit[CELL_MARKER]) {
                cellInit.set("z", zIndex, opt);
              } else {
                cellAttributes.z = zIndex;
              }
            }
          }
          return cellInit;
        },
        minZIndex: function(layerId = this.defaultLayerId) {
          const layer = this.getLayer(layerId);
          return layer.cellCollection.minZIndex();
        },
        maxZIndex: function(layerId = this.defaultLayerId) {
          const layer = this.getLayer(layerId);
          return layer.cellCollection.maxZIndex();
        },
        addCell: function(cellInit, options) {
          if (Array.isArray(cellInit)) {
            return this.addCells(cellInit, options);
          }
          this._prepareCell(cellInit, {
            ...options,
            ensureZIndex: true
          });
          this.layerCollection.addCellToLayer(cellInit, this.getCellLayerId(cellInit), options);
          return this;
        },
        addCells: function(cells, opt) {
          if (cells.length === 0) return this;
          cells = flattenDeep(cells);
          opt.maxPosition = opt.position = cells.length - 1;
          this.startBatch("add", opt);
          cells.forEach((cell) => {
            this.addCell(cell, opt);
            opt.position--;
          });
          this.stopBatch("add", opt);
          return this;
        },
        /**
         * @public
         * @description Reset the cells in the graph.
         * Useful for bulk operations and optimizations.
         */
        resetCells: function(cellInits, options) {
          const {
            layerCollection
          } = this;
          const prepareOptions = {
            ...options,
            ensureZIndex: false
          };
          const layerCellsMap = layerCollection.reduce((map, layer) => {
            map[layer.id] = [];
            return map;
          }, {});
          for (let i = 0; i < cellInits.length; i++) {
            const cellInit = cellInits[i];
            const layerId = this.getCellLayerId(cellInit);
            if (layerId in layerCellsMap) {
              this._prepareCell(cellInit, prepareOptions);
              layerCellsMap[layerId].push(cellInit);
            } else {
              throw new Error(`dia.Graph: Layer "${layerId}" does not exist.`);
            }
          }
          layerCollection.each((layer) => {
            layer.cellCollection.reset(layerCellsMap[layer.id], options);
          });
          this.trigger("reset", this.getDefaultLayer().cellCollection, options);
          return this;
        },
        /**
         * @public
         * @description Get the layer ID in which the cell resides.
         * Cells without an explicit layer are assigned to the default layer.
         * @param {dia.Cell | Object} cellInit - Cell model or attributes.
         * @returns {string} - The layer ID.
         */
        getCellLayerId: function(cellInit) {
          if (!cellInit) {
            throw new Error("dia.Graph: No cell provided.");
          }
          const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;
          return cellAttributes[config$3.layerAttribute] || this.defaultLayerId;
        },
        /**
         * @protected
         * @description Reset the layers in the graph.
         * It assumes the existing cells have been removed beforehand
         * or can be discarded.
         */
        _resetLayers: function(layers, defaultLayerId, options = {}) {
          if (!Array.isArray(layers) || layers.length === 0) {
            throw new Error("dia.Graph: At least one layer must be defined.");
          }
          this.legacyMode = false;
          this.layerCollection.reset(layers, {
            ...options,
            graph: this.cid
          });
          if (defaultLayerId) {
            if (!this.hasLayer(defaultLayerId)) {
              throw new Error(`dia.Graph: default layer "${defaultLayerId}" does not exist.`);
            }
            this.defaultLayerId = defaultLayerId;
          } else {
            this.defaultLayerId = this.layerCollection.at(0).id;
          }
          return this;
        },
        /**
         * @public
         * @description Remove multiple cells from the graph.
         * @param {Array<dia.Cell | dia.Cell.ID>} cellRefs - Array of cell references (models or IDs) to remove.
         * @param {Object} [options] - Removal options. See {@link dia.Graph#removeCell}.
         */
        removeCells: function(cellRefs, options) {
          if (!cellRefs.length) return this;
          this.startBatch("remove");
          for (const cellRef of cellRefs) {
            if (!cellRef) continue;
            let cell;
            if (cellRef[CELL_MARKER]) {
              cell = cellRef;
            } else {
              cell = this.getCell(cellRef);
              if (!cell) {
                continue;
              }
            }
            this.layerCollection.removeCell(cell, options);
          }
          this.stopBatch("remove");
          return this;
        },
        /**
         * @protected
         * @description Replace an existing cell with a new cell.
         */
        _replaceCell: function(currentCell, newCellInit, opt = {}) {
          const batchName = "replace-cell";
          const replaceOptions = {
            ...opt,
            replace: true
          };
          this.startBatch(batchName, opt);
          this.layerCollection.removeCell(currentCell, replaceOptions);
          const newCellInitAttributes = newCellInit[CELL_MARKER] ? newCellInit.attributes : newCellInit;
          const replacementCellAttributes = Object.assign({}, currentCell.attributes, newCellInitAttributes);
          let replacement2;
          if (newCellInit[CELL_MARKER]) {
            newCellInit.set(replacementCellAttributes, replaceOptions);
            replacement2 = newCellInit;
          } else {
            replacement2 = replacementCellAttributes;
          }
          this.addCell(replacement2, replaceOptions);
          this.stopBatch(batchName);
        },
        /**
         * @protected
         * @description Synchronize a single graph cell with the provided cell (model or attributes).
         * If the cell with the same `id` exists, it is updated. If the cell does not exist, it is added.
         * If the existing cell type is different from the incoming cell type, the existing cell is replaced.
         */
        _syncCell: function(cellInit, opt = {}) {
          const cellAttributes = cellInit[CELL_MARKER] ? cellInit.attributes : cellInit;
          const currentCell = this.getCell(cellInit.id);
          if (currentCell) {
            if ("type" in cellAttributes && currentCell.get("type") !== cellAttributes.type) {
              this._replaceCell(currentCell, cellInit, opt);
            } else {
              currentCell.set(cellAttributes, opt);
            }
          } else {
            this.addCell(cellInit, opt);
          }
        },
        /**
         * @public
         * @description Synchronize the graph cells with the provided array of cells (models or attributes).
         */
        syncCells: function(cellInits, opt = {}) {
          const batchName = "sync-cells";
          const {
            remove: remove2 = false,
            ...setOpt
          } = opt;
          let currentCells, newCellsMap;
          if (remove2) {
            currentCells = this.getCells();
            newCellsMap = /* @__PURE__ */ new Map();
          }
          let changeObserver, changedLayers;
          const shouldSort = opt.sort !== false;
          if (shouldSort) {
            changeObserver = new Listener();
            changedLayers = /* @__PURE__ */ new Set();
            changeObserver.listenTo(this, {
              "add": (cell) => {
                changedLayers.add(this.getCellLayerId(cell));
              },
              "change": (cell) => {
                if (cell.hasChanged(config$3.layerAttribute) || cell.hasChanged("z")) {
                  changedLayers.add(this.getCellLayerId(cell));
                }
              }
            });
          }
          this.startBatch(batchName, opt);
          setOpt.sort = false;
          for (const cellInit of cellInits) {
            if (remove2) {
              newCellsMap.set(cellInit.id, true);
            }
            this._syncCell(cellInit, setOpt);
          }
          if (remove2) {
            for (const cell of currentCells) {
              if (!newCellsMap.has(cell.id)) {
                this.layerCollection.removeCell(cell, setOpt);
              }
            }
          }
          if (shouldSort) {
            changeObserver.stopListening();
            for (const layerId of changedLayers) {
              this.getLayer(layerId).cellCollection.sort(opt);
            }
          }
          this.stopBatch(batchName);
        },
        /**
         * @public
         * @description Remove a cell from the graph.
         * @param {dia.Cell} cell
         * @param {Object} [options]
         * @param {boolean} [options.disconnectLinks=false] - If `true`, the connected links are
         * disconnected instead of removed.
         * @param {boolean} [options.clear=false] - If `true`, the connected links
         * are kept. @internal
         * @param {boolean} [options.replace=false] - If `true`, the connected links and
         * embedded cells are kept. @internal
         * @throws Will throw an error if no cell is provided
         * @throws Will throw an error if the ID of the cell to remove
         * does not exist in the graph
         **/
        removeCell: function(cellRef, options) {
          if (!cellRef) {
            throw new Error("dia.Graph: no cell provided.");
          }
          const cell = cellRef[CELL_MARKER] ? cellRef : this.getCell(cellRef);
          if (!cell) {
            throw new Error("dia.Graph: cell to remove does not exist in the graph.");
          }
          if (cell.graph !== this) return;
          this.startBatch("remove");
          cell.collection.remove(cell, options);
          this.stopBatch("remove");
        },
        transferCellEmbeds: function(sourceCell, targetCell, opt = {}) {
          const batchName = "transfer-embeds";
          this.startBatch(batchName);
          const children2 = sourceCell.getEmbeddedCells();
          targetCell.embed(children2, {
            ...opt,
            reparent: true
          });
          this.stopBatch(batchName);
        },
        transferCellConnectedLinks: function(sourceCell, targetCell, opt = {}) {
          const batchName = "transfer-connected-links";
          this.startBatch(batchName);
          const connectedLinks = this.getConnectedLinks(sourceCell, opt);
          connectedLinks.forEach((link) => {
            if (link.getSourceCell() === sourceCell) {
              link.prop(["source", "id"], targetCell.id, opt);
            }
            if (link.getTargetCell() === sourceCell) {
              link.prop(["target", "id"], targetCell.id, opt);
            }
          });
          this.stopBatch(batchName);
        },
        /**
         * @private
         * Helper method for addLayer and moveLayer methods
         */
        _getBeforeLayerIdFromOptions(options, layer = null) {
          let {
            before = null,
            index: index2
          } = options;
          if (before && index2 !== void 0) {
            throw new Error('dia.Graph: Options "before" and "index" are mutually exclusive.');
          }
          let computedBefore;
          if (index2 !== void 0) {
            const layersArray = this.getLayers();
            if (index2 >= layersArray.length) {
              computedBefore = null;
            } else if (index2 < 0) {
              computedBefore = layersArray[0].id;
            } else {
              var _layersArray$index;
              const originalIndex = layersArray.indexOf(layer);
              if (originalIndex !== -1 && index2 > originalIndex) {
                index2 += 1;
              }
              computedBefore = ((_layersArray$index = layersArray[index2]) === null || _layersArray$index === void 0 ? void 0 : _layersArray$index.id) || null;
            }
          } else {
            computedBefore = before;
          }
          return computedBefore;
        },
        /**
         * @public
         * Adds a new layer to the graph.
         * @param {GraphLayer | GraphLayerJSON} layerInit
         * @param {*} options
         * @param {string | null} [options.before] - ID of the layer
         * before which to insert the new layer. If `null`, the layer is added at the end.
         * @param {number} [options.index] - Zero-based index to which to add the layer.
         * @throws Will throw an error if the layer to add is invalid
         * @throws Will throw an error if a layer with the same ID already exists
         * @throws Will throw if `before` reference is invalid
         */
        addLayer(layerInit, options = {}) {
          if (!layerInit || !layerInit.id) {
            throw new Error("dia.Graph: Layer to add is invalid.");
          }
          if (this.hasLayer(layerInit.id)) {
            throw new Error(`dia.Graph: Layer "${layerInit.id}" already exists.`);
          }
          const {
            before = null,
            index: index2,
            ...insertOptions
          } = options;
          insertOptions.graph = this.cid;
          this.legacyMode = false;
          const beforeId = this._getBeforeLayerIdFromOptions({
            before,
            index: index2
          });
          this.layerCollection.insert(layerInit, beforeId, insertOptions);
        },
        /**
         * @public
         * Moves an existing layer to a new position in the layer stack.
         * @param {string | GraphLayer} layerRef - ID or reference of the layer to move.
         * @param {*} options
         * @param {string | null} [options.before] - ID of the layer
         * before which to insert the moved layer. If `null`, the layer is moved to the end.
         * @param {number} [options.index] - Zero-based index to which to move the layer.
         * @throws Will throw an error if the layer to move does not exist
         * @throws Will throw an error if `before` reference is invalid
         * @throws Will throw an error if both `before` and `index` options are provided
         */
        moveLayer(layerRef, options = {}) {
          if (!layerRef || !this.hasLayer(layerRef)) {
            throw new Error("dia.Graph: Layer to move does not exist.");
          }
          const layer = this.getLayer(layerRef);
          const {
            before = null,
            index: index2,
            ...insertOptions
          } = options;
          insertOptions.graph = this.cid;
          this.legacyMode = false;
          const beforeId = this._getBeforeLayerIdFromOptions({
            before,
            index: index2
          }, layer);
          this.layerCollection.insert(layer, beforeId, insertOptions);
        },
        /**
         * @public
         * Removes an existing layer from the graph.
         * @param {string | GraphLayer} layerRef - ID or reference of the layer to remove.
         * @param {*} options
         * @throws Will throw an error if no layer is provided
         * @throws Will throw an error if the layer to remove does not exist
         */
        removeLayer(layerRef, options = {}) {
          if (!layerRef) {
            throw new Error("dia.Graph: No layer provided.");
          }
          const layerId = layerRef.id ? layerRef.id : layerRef;
          const layer = this.getLayer(layerId);
          const {
            id: defaultLayerId
          } = this.getDefaultLayer();
          if (layerId === defaultLayerId) {
            throw new Error("dia.Graph: default layer cannot be removed.");
          }
          if (layer.cellCollection.length > 0) {
            throw new Error(`dia.Graph: Layer "${layerId}" cannot be removed because it is not empty.`);
          }
          this.layerCollection.remove(layerId, {
            ...options,
            graph: this.cid
          });
        },
        getDefaultLayer() {
          return this.layerCollection.get(this.defaultLayerId);
        },
        setDefaultLayer(layerRef, options = {}) {
          if (!layerRef) {
            throw new Error("dia.Graph: No default layer ID provided.");
          }
          const defaultLayerId = layerRef.id ? layerRef.id : layerRef;
          const defaultLayer = this.getLayer(defaultLayerId);
          const currentDefaultLayerId = this.defaultLayerId;
          if (defaultLayerId === currentDefaultLayerId) {
            return;
          }
          const implicitLayerCells = this.getImplicitLayerCells();
          this.defaultLayerId = defaultLayerId;
          const batchName = "default-layer-change";
          this.startBatch(batchName, options);
          if (implicitLayerCells.length > 0) {
            const moveOptions = {
              ...options,
              sort: false
            };
            for (const cell of implicitLayerCells) {
              this.layerCollection.moveCellBetweenLayers(cell, defaultLayerId, moveOptions);
            }
            if (options.sort !== false) {
              defaultLayer.cellCollection.sort(options);
            }
          }
          defaultLayer.trigger(defaultLayer.eventPrefix + "default", defaultLayer, {
            ...options,
            previousDefaultLayerId: currentDefaultLayerId
          });
          this.stopBatch(batchName, options);
        },
        /**
         * @protected
         * @description Get all cells that do not have an explicit layer assigned.
         * These cells belong to the default layer implicitly.
         * @return {Array<dia.Cell>} Array of cells without an explicit layer.
         */
        getImplicitLayerCells() {
          return this.getDefaultLayer().cellCollection.filter((cell) => {
            return cell.get(config$3.layerAttribute) == null;
          });
        },
        getLayer(layerId) {
          if (!this.hasLayer(layerId)) {
            throw new Error(`dia.Graph: Layer "${layerId}" does not exist.`);
          }
          return this.layerCollection.get(layerId);
        },
        hasLayer(layerRef) {
          return this.layerCollection.has(layerRef);
        },
        getLayers() {
          return this.layerCollection.toArray();
        },
        getCell: function(cellRef) {
          return this.layerCollection.getCell(cellRef);
        },
        getCells: function() {
          return this.layerCollection.getCells();
        },
        getElements: function() {
          return this.getCells().filter((cell) => cell.isElement());
        },
        getLinks: function() {
          return this.getCells().filter((cell) => cell.isLink());
        },
        getFirstCell: function(layerId) {
          let layer;
          if (!layerId) {
            layer = this.getLayers().at(0);
          } else {
            layer = this.getLayer(layerId);
          }
          return layer.cellCollection.models.at(0);
        },
        getLastCell: function(layerId) {
          let layer;
          if (!layerId) {
            layer = this.getLayers().at(-1);
          } else {
            layer = this.getLayer(layerId);
          }
          return layer.cellCollection.models.at(-1);
        },
        // Get all inbound and outbound links connected to the cell `model`.
        getConnectedLinks: function(model, opt) {
          opt = opt || {};
          var indirect = opt.indirect;
          var inbound = opt.inbound;
          var outbound = opt.outbound;
          if (inbound === void 0 && outbound === void 0) {
            inbound = outbound = true;
          }
          var links = [];
          var edges = {};
          if (outbound) {
            addOutbounds(this, model);
          }
          if (inbound) {
            addInbounds(this, model);
          }
          function addOutbounds(graph, model2) {
            forIn(graph.topologyIndex.getOutboundEdges(model2.id), (function(_, edge) {
              if (edges[edge]) return;
              var link = graph.getCell(edge);
              if (!link) return;
              links.push(link);
              edges[edge] = true;
              if (indirect) {
                if (inbound) addInbounds(graph, link);
                if (outbound) addOutbounds(graph, link);
              }
            }).bind(graph));
            if (indirect && model2.isLink()) {
              var outCell = model2.getTargetCell();
              if (outCell && outCell.isLink()) {
                if (!edges[outCell.id]) {
                  links.push(outCell);
                  addOutbounds(graph, outCell);
                }
              }
            }
          }
          function addInbounds(graph, model2) {
            forIn(graph.topologyIndex.getInboundEdges(model2.id), (function(_, edge) {
              if (edges[edge]) return;
              var link = graph.getCell(edge);
              if (!link) return;
              links.push(link);
              edges[edge] = true;
              if (indirect) {
                if (inbound) addInbounds(graph, link);
                if (outbound) addOutbounds(graph, link);
              }
            }).bind(graph));
            if (indirect && model2.isLink()) {
              var inCell = model2.getSourceCell();
              if (inCell && inCell.isLink()) {
                if (!edges[inCell.id]) {
                  links.push(inCell);
                  addInbounds(graph, inCell);
                }
              }
            }
          }
          if (opt.deep) {
            var embeddedCells = model.getEmbeddedCells({
              deep: true
            });
            var embeddedElements = {};
            embeddedCells.forEach(function(cell) {
              if (cell.isElement()) {
                embeddedElements[cell.id] = true;
              }
            });
            embeddedCells.forEach(function(cell) {
              if (cell.isLink()) return;
              if (outbound) {
                forIn(this.topologyIndex.getOutboundEdges(cell.id), (function(exists2, edge) {
                  if (!edges[edge]) {
                    var edgeCell = this.getCell(edge);
                    var {
                      source,
                      target
                    } = edgeCell.attributes;
                    var sourceId = source.id;
                    var targetId = target.id;
                    if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
                      return;
                    }
                    links.push(this.getCell(edge));
                    edges[edge] = true;
                  }
                }).bind(this));
              }
              if (inbound) {
                forIn(this.topologyIndex.getInboundEdges(cell.id), (function(exists2, edge) {
                  if (!edges[edge]) {
                    var edgeCell = this.getCell(edge);
                    var {
                      source,
                      target
                    } = edgeCell.attributes;
                    var sourceId = source.id;
                    var targetId = target.id;
                    if (!opt.includeEnclosed && sourceId && embeddedElements[sourceId] && targetId && embeddedElements[targetId]) {
                      return;
                    }
                    links.push(this.getCell(edge));
                    edges[edge] = true;
                  }
                }).bind(this));
              }
            }, this);
          }
          return links;
        },
        getNeighbors: function(model, opt) {
          opt || (opt = {});
          var inbound = opt.inbound;
          var outbound = opt.outbound;
          if (inbound === void 0 && outbound === void 0) {
            inbound = outbound = true;
          }
          var neighbors = this.getConnectedLinks(model, opt).reduce((function(res, link) {
            var {
              source,
              target
            } = link.attributes;
            var loop = link.hasLoop(opt);
            if (inbound && has(source, "id") && !res[source.id]) {
              var sourceElement = this.getCell(source.id);
              if (sourceElement.isElement()) {
                if (loop || sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model))) {
                  res[source.id] = sourceElement;
                }
              }
            }
            if (outbound && has(target, "id") && !res[target.id]) {
              var targetElement = this.getCell(target.id);
              if (targetElement.isElement()) {
                if (loop || targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model))) {
                  res[target.id] = targetElement;
                }
              }
            }
            return res;
          }).bind(this), {});
          if (model.isLink()) {
            if (inbound) {
              var sourceCell = model.getSourceCell();
              if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {
                neighbors[sourceCell.id] = sourceCell;
              }
            }
            if (outbound) {
              var targetCell = model.getTargetCell();
              if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {
                neighbors[targetCell.id] = targetCell;
              }
            }
          }
          return toArray$1(neighbors);
        },
        getCommonAncestor: function() {
          var cellsAncestors = Array.from(arguments).map(function(cell) {
            var ancestors = [];
            var parentId = cell.get("parent");
            while (parentId) {
              ancestors.push(parentId);
              parentId = this.getCell(parentId).get("parent");
            }
            return ancestors;
          }, this);
          cellsAncestors = cellsAncestors.sort(function(a, b) {
            return a.length - b.length;
          });
          var commonAncestor = toArray$1(cellsAncestors.shift()).find(function(ancestor) {
            return cellsAncestors.every(function(cellAncestors) {
              return cellAncestors.includes(ancestor);
            });
          });
          return this.getCell(commonAncestor);
        },
        // Find the whole branch starting at `element`.
        // If `opt.deep` is `true`, take into account embedded elements too.
        // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
        getSuccessors: function(element, opt) {
          opt = opt || {};
          var res = [];
          this.search(element, function(el) {
            if (el !== element) {
              res.push(el);
            }
          }, assign({}, opt, {
            outbound: true
          }));
          return res;
        },
        cloneCells,
        // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).
        // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.
        // Return a map of the form: [original cell ID] -> [clone].
        cloneSubgraph: function(cells, opt) {
          var subgraph = this.getSubgraph(cells, opt);
          return this.cloneCells(subgraph);
        },
        // Return `cells` and all the connected links that connect cells in the `cells` array.
        // If `opt.deep` is `true`, return all the cells including all their embedded cells
        // and all the links that connect any of the returned cells.
        // For example, for a single shallow element, the result is that very same element.
        // For two elements connected with a link: `A --- L ---> B`, the result for
        // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.
        getSubgraph: function(cells, opt) {
          opt = opt || {};
          var subgraph = [];
          var cellMap = {};
          var elements = [];
          var links = [];
          toArray$1(cells).forEach(function(cell) {
            if (!cellMap[cell.id]) {
              subgraph.push(cell);
              cellMap[cell.id] = cell;
              if (cell.isLink()) {
                links.push(cell);
              } else {
                elements.push(cell);
              }
            }
            if (opt.deep) {
              var embeds = cell.getEmbeddedCells({
                deep: true
              });
              embeds.forEach(function(embed) {
                if (!cellMap[embed.id]) {
                  subgraph.push(embed);
                  cellMap[embed.id] = embed;
                  if (embed.isLink()) {
                    links.push(embed);
                  } else {
                    elements.push(embed);
                  }
                }
              });
            }
          });
          links.forEach(function(link) {
            var {
              source,
              target
            } = link.attributes;
            if (source.id && !cellMap[source.id]) {
              var sourceElement = this.getCell(source.id);
              subgraph.push(sourceElement);
              cellMap[sourceElement.id] = sourceElement;
              elements.push(sourceElement);
            }
            if (target.id && !cellMap[target.id]) {
              var targetElement = this.getCell(target.id);
              subgraph.push(this.getCell(target.id));
              cellMap[targetElement.id] = targetElement;
              elements.push(targetElement);
            }
          }, this);
          elements.forEach(function(element) {
            var links2 = this.getConnectedLinks(element, opt);
            links2.forEach(function(link) {
              var {
                source,
                target
              } = link.attributes;
              if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {
                subgraph.push(link);
                cellMap[link.id] = link;
              }
            });
          }, this);
          return subgraph;
        },
        // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.
        // If `opt.deep` is `true`, take into account embedded elements too.
        // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.
        getPredecessors: function(element, opt) {
          opt = opt || {};
          var res = [];
          this.search(element, function(el) {
            if (el !== element) {
              res.push(el);
            }
          }, assign({}, opt, {
            inbound: true
          }));
          return res;
        },
        // Perform search on the graph.
        // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.
        // By setting `opt.inbound` to `true`, you can reverse the direction of the search.
        // If `opt.deep` is `true`, take into account embedded elements too.
        // `iteratee` is a function of the form `function(element) {}`.
        // If `iteratee` explicitly returns `false`, the searching stops.
        search: function(element, iteratee, opt) {
          opt = opt || {};
          if (opt.breadthFirst) {
            this.bfs(element, iteratee, opt);
          } else {
            this.dfs(element, iteratee, opt);
          }
        },
        // Breadth-first search.
        // If `opt.deep` is `true`, take into account embedded elements too.
        // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
        // `iteratee` is a function of the form `function(element, distance) {}`.
        // where `element` is the currently visited element and `distance` is the distance of that element
        // from the root `element` passed the `bfs()`, i.e. the element we started the search from.
        // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels
        // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.
        // If `iteratee` explicitly returns `false`, the searching stops.
        bfs: function(element, iteratee, opt = {}) {
          const visited = {};
          const distance = {};
          const queue = [];
          queue.push(element);
          distance[element.id] = 0;
          while (queue.length > 0) {
            var next = queue.shift();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            for (let i = 0, n = neighbors.length; i < n; i++) {
              const neighbor = neighbors[i];
              distance[neighbor.id] = distance[next.id] + 1;
              queue.push(neighbor);
            }
          }
        },
        // Depth-first search.
        // If `opt.deep` is `true`, take into account embedded elements too.
        // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).
        // `iteratee` is a function of the form `function(element, distance) {}`.
        // If `iteratee` explicitly returns `false`, the search stops.
        dfs: function(element, iteratee, opt = {}) {
          const visited = {};
          const distance = {};
          const queue = [];
          queue.push(element);
          distance[element.id] = 0;
          while (queue.length > 0) {
            const next = queue.pop();
            if (visited[next.id]) continue;
            visited[next.id] = true;
            if (iteratee.call(this, next, distance[next.id]) === false) continue;
            const neighbors = this.getNeighbors(next, opt);
            const lastIndex = queue.length;
            for (let i = 0, n = neighbors.length; i < n; i++) {
              const neighbor = neighbors[i];
              distance[neighbor.id] = distance[next.id] + 1;
              queue.splice(lastIndex, 0, neighbor);
            }
          }
        },
        // Get all the roots of the graph. Time complexity: O(|V|).
        getSources: function() {
          return this.topologyIndex.getSourceNodes().map((nodeId) => this.getCell(nodeId));
        },
        // Get all the leafs of the graph. Time complexity: O(|V|).
        getSinks: function() {
          return this.topologyIndex.getSinkNodes().map((nodeId) => this.getCell(nodeId));
        },
        // Return `true` if `element` is a root. Time complexity: O(1).
        isSource: function(element) {
          return this.topologyIndex.isSourceNode(element.id);
        },
        // Return `true` if `element` is a leaf. Time complexity: O(1).
        isSink: function(element) {
          return this.topologyIndex.isSinkNode(element.id);
        },
        // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.
        isSuccessor: function(elementA, elementB) {
          var isSuccessor = false;
          this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
              isSuccessor = true;
              return false;
            }
          }, {
            outbound: true
          });
          return isSuccessor;
        },
        // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.
        isPredecessor: function(elementA, elementB) {
          var isPredecessor = false;
          this.search(elementA, function(element) {
            if (element === elementB && element !== elementA) {
              isPredecessor = true;
              return false;
            }
          }, {
            inbound: true
          });
          return isPredecessor;
        },
        // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.
        // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`
        // for more details.
        // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.
        // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.
        isNeighbor: function(elementA, elementB, opt) {
          opt = opt || {};
          var inbound = opt.inbound;
          var outbound = opt.outbound;
          if (inbound === void 0 && outbound === void 0) {
            inbound = outbound = true;
          }
          var isNeighbor = false;
          this.getConnectedLinks(elementA, opt).forEach(function(link) {
            var {
              source,
              target
            } = link.attributes;
            if (inbound && has(source, "id") && source.id === elementB.id) {
              isNeighbor = true;
              return false;
            }
            if (outbound && has(target, "id") && target.id === elementB.id) {
              isNeighbor = true;
              return false;
            }
          });
          return isNeighbor;
        },
        // Disconnect links connected to the cell `model`.
        disconnectLinks: function(model, opt) {
          this.getConnectedLinks(model).forEach(function(link) {
            link.set(link.attributes.source.id === model.id ? "source" : "target", {
              x: 0,
              y: 0
            }, opt);
          });
        },
        // Remove links connected to the cell `model` completely.
        removeLinks: function(cell, opt) {
          this.getConnectedLinks(cell).forEach((link) => {
            this.layerCollection.removeCell(link, opt);
          });
        },
        // Find all cells at given point
        findElementsAtPoint: function(point2, opt) {
          return this._filterAtPoint(this.getElements(), point2, opt);
        },
        findLinksAtPoint: function(point2, opt) {
          return this._filterAtPoint(this.getLinks(), point2, opt);
        },
        findCellsAtPoint: function(point2, opt) {
          return this._filterAtPoint(this.getCells(), point2, opt);
        },
        _filterAtPoint: function(cells, point2, opt = {}) {
          return cells.filter((el) => el.getBBox({
            rotate: true
          }).containsPoint(point2, opt));
        },
        // Find all cells in given area
        findElementsInArea: function(area, opt = {}) {
          return this._filterInArea(this.getElements(), area, opt);
        },
        findLinksInArea: function(area, opt = {}) {
          return this._filterInArea(this.getLinks(), area, opt);
        },
        findCellsInArea: function(area, opt = {}) {
          return this._filterInArea(this.getCells(), area, opt);
        },
        _filterInArea: function(cells, area, opt = {}) {
          const r = new Rect(area);
          const {
            strict = false
          } = opt;
          const method = strict ? "containsRect" : "intersect";
          return cells.filter((el) => r[method](el.getBBox({
            rotate: true
          })));
        },
        // Find all cells under the given element.
        findElementsUnderElement: function(element, opt) {
          return this._filterCellsUnderElement(this.getElements(), element, opt);
        },
        findLinksUnderElement: function(element, opt) {
          return this._filterCellsUnderElement(this.getLinks(), element, opt);
        },
        findCellsUnderElement: function(element, opt) {
          return this._filterCellsUnderElement(this.getCells(), element, opt);
        },
        _isValidElementUnderElement: function(el1, el2) {
          return el1.id !== el2.id && !el1.isEmbeddedIn(el2);
        },
        _isValidLinkUnderElement: function(link, el) {
          return link.source().id !== el.id && link.target().id !== el.id && !link.isEmbeddedIn(el);
        },
        _validateCellsUnderElement: function(cells, element) {
          return cells.filter((cell) => {
            return cell.isLink() ? this._isValidLinkUnderElement(cell, element) : this._isValidElementUnderElement(cell, element);
          });
        },
        _getFindUnderElementGeometry: function(element, searchBy = "bbox") {
          const bbox2 = element.getBBox({
            rotate: true
          });
          return searchBy !== "bbox" ? getRectPoint(bbox2, searchBy) : bbox2;
        },
        _filterCellsUnderElement: function(cells, element, opt = {}) {
          const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);
          const filteredCells = geometry.type === types.Point ? this._filterAtPoint(cells, geometry) : this._filterInArea(cells, geometry, opt);
          return this._validateCellsUnderElement(filteredCells, element);
        },
        // @deprecated use `findElementsInArea` instead
        findModelsInArea: function(area, opt) {
          return this.findElementsInArea(area, opt);
        },
        // @deprecated use `findElementsAtPoint` instead
        findModelsFromPoint: function(point2) {
          return this.findElementsAtPoint(point2);
        },
        // @deprecated use `findModelsUnderElement` instead
        findModelsUnderElement: function(element, opt) {
          return this.findElementsUnderElement(element, opt);
        },
        // Return bounding box of all elements.
        getBBox: function() {
          return this.getCellsBBox(this.getCells());
        },
        // Return the bounding box of all cells in array provided.
        getCellsBBox: function(cells, opt = {}) {
          const {
            rotate = true
          } = opt;
          return toArray$1(cells).reduce(function(memo, cell) {
            const rect2 = cell.getBBox({
              rotate
            });
            if (!rect2) return memo;
            if (memo) {
              return memo.union(rect2);
            }
            return rect2;
          }, null);
        },
        translate: function(dx, dy, opt) {
          var cells = this.getCells().filter(function(cell) {
            return !cell.isEmbedded();
          });
          invoke(cells, "translate", dx, dy, opt);
          return this;
        },
        resize: function(width2, height2, opt) {
          return this.resizeCells(width2, height2, this.getCells(), opt);
        },
        resizeCells: function(width2, height2, cells, opt) {
          var bbox2 = this.getCellsBBox(cells);
          if (bbox2) {
            var sx = Math.max(width2 / bbox2.width, 0);
            var sy = Math.max(height2 / bbox2.height, 0);
            invoke(cells, "scale", sx, sy, bbox2.origin(), opt);
          }
          return this;
        },
        startBatch: function(name, data2) {
          data2 = data2 || {};
          this._batches[name] = (this._batches[name] || 0) + 1;
          return this.trigger("batch:start", assign({}, data2, {
            batchName: name
          }));
        },
        stopBatch: function(name, data2) {
          data2 = data2 || {};
          this._batches[name] = (this._batches[name] || 0) - 1;
          return this.trigger("batch:stop", assign({}, data2, {
            batchName: name
          }));
        },
        hasActiveBatch: function(name) {
          const batches = this._batches;
          let names;
          if (arguments.length === 0) {
            names = Object.keys(batches);
          } else if (Array.isArray(name)) {
            names = name;
          } else {
            names = [name];
          }
          return names.some((batch) => batches[batch] > 0);
        }
      }, {
        validations: {
          multiLinks: function(graph, link) {
            var {
              source,
              target
            } = link.attributes;
            if (source.id && target.id) {
              var sourceModel = link.getSourceCell();
              if (sourceModel) {
                var connectedLinks = graph.getConnectedLinks(sourceModel, {
                  outbound: true
                });
                var sameLinks = connectedLinks.filter(function(_link) {
                  var {
                    source: _source,
                    target: _target
                  } = _link.attributes;
                  return _source && _source.id === source.id && (!_source.port || _source.port === source.port) && _target && _target.id === target.id && (!_target.port || _target.port === target.port);
                });
                if (sameLinks.length > 1) {
                  return false;
                }
              }
            }
            return true;
          },
          linkPinning: function(_graph, link) {
            var {
              source,
              target
            } = link.attributes;
            return source.id && target.id;
          }
        }
      });
      wrapWith(Graph.prototype, ["resetCells", "addCells", "removeCells"], wrappers.cells);
      const calcAttributesList = ["transform", "x", "y", "cx", "cy", "dx", "dy", "x1", "y1", "x2", "y2", "points", "d", "r", "rx", "ry", "width", "height", "stroke-width", "font-size"];
      const positiveValueList = ["r", "rx", "ry", "width", "height", "stroke-width", "font-size"];
      const calcAttributes = calcAttributesList.reduce((acc, attrName) => {
        acc[attrName] = true;
        return acc;
      }, {});
      const positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {
        acc[attrName] = true;
        return acc;
      }, {});
      function evalAttributes(attrs, refBBox) {
        const evalAttrs = {};
        for (let attrName in attrs) {
          if (!attrs.hasOwnProperty(attrName)) continue;
          evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);
        }
        return evalAttrs;
      }
      function evalAttribute(attrName, attrValue, refBBox) {
        if (attrName in calcAttributes && isCalcExpression(attrValue)) {
          let evalAttrValue = evalCalcExpression(attrValue, refBBox);
          if (attrName in positiveValueAttributes) {
            evalAttrValue = Math.max(0, evalAttrValue);
          }
          return evalAttrValue;
        }
        return attrValue;
      }
      const HighlightingTypes$1 = {
        DEFAULT: "default",
        EMBEDDING: "embedding",
        CONNECTING: "connecting",
        MAGNET_AVAILABILITY: "magnetAvailability",
        ELEMENT_AVAILABILITY: "elementAvailability"
      };
      const Flags$2 = {
        TOOLS: "TOOLS"
      };
      const CellView = View.extend({
        tagName: "g",
        svgElement: true,
        selector: "root",
        metrics: null,
        className: function() {
          var classNames = ["cell"];
          var type = this.model.get("type");
          if (type) {
            type.toLowerCase().split(".").forEach(function(value, index2, list2) {
              classNames.push("type-" + list2.slice(0, index2 + 1).join("-"));
            });
          }
          return classNames.join(" ");
        },
        _presentationAttributes: null,
        _flags: null,
        setFlags: function() {
          var flags = {};
          var attributes2 = {};
          var shift = 0;
          var i, n, label;
          var presentationAttributes = result(this, "presentationAttributes");
          for (var attribute in presentationAttributes) {
            if (!presentationAttributes.hasOwnProperty(attribute)) continue;
            var labels = presentationAttributes[attribute];
            if (!Array.isArray(labels)) labels = [labels];
            for (i = 0, n = labels.length; i < n; i++) {
              label = labels[i];
              var flag = flags[label];
              if (!flag) {
                flag = flags[label] = 1 << shift++;
              }
              attributes2[attribute] |= flag;
            }
          }
          var initFlag = result(this, "initFlag");
          if (!Array.isArray(initFlag)) initFlag = [initFlag];
          for (i = 0, n = initFlag.length; i < n; i++) {
            label = initFlag[i];
            if (!flags[label]) flags[label] = 1 << shift++;
          }
          if (shift > 25) throw new Error("dia.CellView: Maximum number of flags exceeded.");
          this._flags = flags;
          this._presentationAttributes = attributes2;
        },
        hasFlag: function(flag, label) {
          return flag & this.getFlag(label);
        },
        removeFlag: function(flag, label) {
          return flag ^ flag & this.getFlag(label);
        },
        getFlag: function(label) {
          var flags = this._flags;
          if (!flags) return 0;
          var flag = 0;
          if (Array.isArray(label)) {
            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];
          } else {
            flag |= flags[label];
          }
          return flag;
        },
        attributes: function() {
          var cell = this.model;
          return {
            "model-id": cell.id,
            "data-type": cell.attributes.type
          };
        },
        constructor: function(options) {
          options.id = options.id || guid(this);
          View.call(this, options);
        },
        initialize: function() {
          this.setFlags();
          View.prototype.initialize.apply(this, arguments);
          this.cleanNodesCache();
          this.startListening();
        },
        startListening: function() {
          this.listenTo(this.model, "change", this.onAttributesChange);
        },
        onAttributesChange: function(model, opt) {
          var flag = model.getChangeFlag(this._presentationAttributes);
          if (opt.updateHandled || !flag) return;
          if (opt.dirty && this.hasFlag(flag, "UPDATE")) flag |= this.getFlag("RENDER");
          if (opt.tool) opt.async = false;
          this.requestUpdate(flag, opt);
        },
        requestUpdate: function(flags, opt) {
          const {
            paper
          } = this;
          if (paper && flags > 0) {
            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);
          }
        },
        parseDOMJSON: function(markup, root) {
          var doc = parseDOMJSON(markup);
          var selectors = doc.selectors;
          var groups = doc.groupSelectors;
          for (var group in groups) {
            if (selectors[group]) throw new Error("dia.CellView: ambiguous group selector");
            selectors[group] = groups[group];
          }
          if (root) {
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error("dia.CellView: ambiguous root selector.");
            selectors[rootSelector] = root;
          }
          return {
            fragment: doc.fragment,
            selectors
          };
        },
        // Return `true` if cell link is allowed to perform a certain UI `feature`.
        // Example: `can('labelMove')`.
        can: function(feature) {
          var interactive = isFunction(this.options.interactive) ? this.options.interactive(this) : this.options.interactive;
          return isObject(interactive) && interactive[feature] !== false || isBoolean(interactive) && interactive !== false;
        },
        findBySelector: function(selector, root, selectors) {
          if (!selector || selector === ".") return [root];
          if (selectors) {
            var nodes = selectors[selector];
            if (nodes) {
              if (Array.isArray(nodes)) return nodes;
              return [nodes];
            }
          }
          if (this.useCSSSelectors) return $(root).find(selector).toArray();
          return [];
        },
        findNodes: function(selector) {
          return this.findBySelector(selector, this.el, this.selectors);
        },
        findNode: function(selector) {
          const [node = null] = this.findNodes(selector);
          return node;
        },
        notify: function(eventName) {
          if (this.paper) {
            var args = Array.prototype.slice.call(arguments, 1);
            this.trigger.apply(this, [eventName].concat(args));
            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));
          }
        },
        getBBox: function(opt) {
          var bbox2;
          if (opt && opt.useModelGeometry) {
            var model = this.model;
            bbox2 = model.getBBox().bbox(model.angle());
          } else {
            bbox2 = this.getNodeBBox(this.el);
          }
          return this.paper.localToPaperRect(bbox2);
        },
        getNodeBBox: function(magnet) {
          const rect2 = this.getNodeBoundingRect(magnet);
          const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));
          const magnetMatrix = this.getNodeMatrix(magnet);
          return V2.transformRect(rect2, transformMatrix.multiply(magnetMatrix));
        },
        getNodeRotateMatrix(node) {
          if (!this.rotatableNode || this.rotatableNode.contains(node)) {
            return this.getRootRotateMatrix();
          }
          return V2.createSVGMatrix();
        },
        getNodeUnrotatedBBox: function(magnet) {
          var rect2 = this.getNodeBoundingRect(magnet);
          var magnetMatrix = this.getNodeMatrix(magnet);
          var translateMatrix = this.getRootTranslateMatrix();
          return V2.transformRect(rect2, translateMatrix.multiply(magnetMatrix));
        },
        getRootTranslateMatrix: function() {
          var model = this.model;
          var position2 = model.position();
          var mt = V2.createSVGMatrix().translate(position2.x, position2.y);
          return mt;
        },
        getRootRotateMatrix: function() {
          var mr = V2.createSVGMatrix();
          var model = this.model;
          var angle = model.angle();
          if (angle) {
            var bbox2 = model.getBBox();
            var cx = bbox2.width / 2;
            var cy = bbox2.height / 2;
            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);
          }
          return mr;
        },
        _notifyHighlight: function(eventName, el, opt = {}) {
          const {
            el: rootNode
          } = this;
          let node;
          if (typeof el === "string") {
            node = this.findNode(el) || rootNode;
          } else {
            [node = rootNode] = this.$(el);
          }
          opt.partial = node !== rootNode;
          if (opt.type === void 0) {
            let type;
            switch (true) {
              case opt.embedding:
                type = HighlightingTypes$1.EMBEDDING;
                break;
              case opt.connecting:
                type = HighlightingTypes$1.CONNECTING;
                break;
              case opt.magnetAvailability:
                type = HighlightingTypes$1.MAGNET_AVAILABILITY;
                break;
              case opt.elementAvailability:
                type = HighlightingTypes$1.ELEMENT_AVAILABILITY;
                break;
              default:
                type = HighlightingTypes$1.DEFAULT;
                break;
            }
            opt.type = type;
          }
          this.notify(eventName, node, opt);
          return this;
        },
        highlight: function(el, opt) {
          return this._notifyHighlight("cell:highlight", el, opt);
        },
        unhighlight: function(el, opt = {}) {
          return this._notifyHighlight("cell:unhighlight", el, opt);
        },
        // Find the closest element that has the `magnet` attribute set to `true`. If there was not such
        // an element found, return the root element of the cell view.
        findMagnet: function(el) {
          const root = this.el;
          let magnet = this.$(el)[0];
          if (!magnet) {
            magnet = root;
          }
          do {
            const magnetAttribute = magnet.getAttribute("magnet");
            const isMagnetRoot = magnet === root;
            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== "false") {
              return magnet;
            }
            if (isMagnetRoot) {
              return void 0;
            }
            magnet = magnet.parentNode;
          } while (magnet);
          return void 0;
        },
        findProxyNode: function(el, type) {
          el || (el = this.el);
          const nodeSelector = el.getAttribute(`${type}-selector`);
          if (nodeSelector) {
            const proxyNode = this.findNode(nodeSelector);
            if (proxyNode) return proxyNode;
          }
          return el;
        },
        // Construct a unique selector for the `el` element within this view.
        // `prevSelector` is being collected through the recursive call.
        // No value for `prevSelector` is expected when using this method.
        getSelector: function(el, prevSelector) {
          var selector;
          if (el === this.el) {
            if (typeof prevSelector === "string") selector = ":scope > " + prevSelector;
            return selector;
          }
          if (el) {
            var nthChild = V2(el).index() + 1;
            selector = el.tagName + ":nth-child(" + nthChild + ")";
            if (prevSelector) {
              selector += " > " + prevSelector;
            }
            selector = this.getSelector(el.parentNode, selector);
          }
          return selector;
        },
        addLinkFromMagnet: function(magnet, x, y) {
          var paper = this.paper;
          var graph = paper.model;
          var link = paper.getDefaultLink(this, magnet);
          link.set({
            source: this.getLinkEnd(magnet, x, y, link, "source"),
            target: {
              x,
              y
            }
          }).addTo(graph, {
            async: false,
            ui: true
          });
          return link.findView(paper);
        },
        getLinkEnd: function(magnet, ...args) {
          const model = this.model;
          const id2 = model.id;
          const portNode = this.findAttributeNode("port", magnet);
          const selector = magnet.getAttribute("joint-selector");
          const end = {
            id: id2
          };
          if (selector != null) end.magnet = selector;
          if (portNode != null) {
            let port = portNode.getAttribute("port");
            if (portNode.getAttribute("port-id-type") === "number") {
              port = parseInt(port, 10);
            }
            end.port = port;
            if (!model.hasPort(port) && !selector) {
              end.selector = this.getSelector(magnet);
            }
          } else if (selector == null && this.el !== magnet) {
            end.selector = this.getSelector(magnet);
          }
          return this.customizeLinkEnd(end, magnet, ...args);
        },
        customizeLinkEnd: function(end, magnet, x, y, link, endType) {
          const {
            paper
          } = this;
          const {
            connectionStrategy
          } = paper.options;
          if (typeof connectionStrategy === "function") {
            var strategy = connectionStrategy.call(paper, end, this, magnet, new Point(x, y), link, endType, paper);
            if (strategy) return strategy;
          }
          return end;
        },
        getMagnetFromLinkEnd: function(end) {
          var port = end.port;
          var selector = end.magnet;
          var model = this.model;
          var magnet;
          if (port != null && model.isElement() && model.hasPort(port)) {
            magnet = this.findPortNode(port, selector) || this.el;
          } else {
            if (!selector) selector = end.selector;
            if (!selector && port != null) {
              selector = '[port="' + port + '"]';
            }
            magnet = this.findNode(selector);
          }
          return this.findProxyNode(magnet, "magnet");
        },
        dragLinkStart: function(evt, magnet, x, y) {
          this.model.startBatch("add-link");
          const linkView = this.addLinkFromMagnet(magnet, x, y);
          linkView.notifyPointerdown(evt, x, y);
          linkView.eventData(evt, linkView.startArrowheadMove("target", {
            whenNotAllowed: "remove"
          }));
          this.eventData(evt, {
            linkView
          });
        },
        dragLink: function(evt, x, y) {
          var data2 = this.eventData(evt);
          var linkView = data2.linkView;
          if (linkView) {
            linkView.pointermove(evt, x, y);
          } else {
            var paper = this.paper;
            var magnetThreshold = paper.options.magnetThreshold;
            var currentTarget = this.getEventTarget(evt);
            var targetMagnet = data2.targetMagnet;
            if (magnetThreshold === "onleave") {
              if (targetMagnet === currentTarget || V2(targetMagnet).contains(currentTarget)) return;
            } else {
              if (paper.eventData(evt).mousemoved <= magnetThreshold) return;
            }
            this.dragLinkStart(evt, targetMagnet, x, y);
          }
        },
        dragLinkEnd: function(evt, x, y) {
          var data2 = this.eventData(evt);
          var linkView = data2.linkView;
          if (!linkView) return;
          linkView.pointerup(evt, x, y);
          this.model.stopBatch("add-link");
        },
        getAttributeDefinition: function(attrName) {
          return this.model.constructor.getAttributeDefinition(attrName);
        },
        setNodeAttributes: function(node, attrs) {
          if (!isEmpty(attrs)) {
            if (node instanceof SVGElement) {
              V2(node).attr(attrs);
            } else {
              $(node).attr(attrs);
            }
          }
        },
        processNodeAttributes: function(node, attrs) {
          var attrName, attrVal, def, i, n;
          var normalAttrs, setAttrs, positionAttrs, offsetAttrs;
          var relatives = [];
          const rawAttrs = {};
          for (attrName in attrs) {
            if (!attrs.hasOwnProperty(attrName)) continue;
            rawAttrs[V2.attributeNames[attrName]] = attrs[attrName];
          }
          for (attrName in rawAttrs) {
            if (!rawAttrs.hasOwnProperty(attrName)) continue;
            attrVal = rawAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            if (def) {
              if (attrVal === null) {
                let unsetAttrName;
                if (isFunction(def.unset)) {
                  unsetAttrName = def.unset.call(this, node, rawAttrs, this);
                } else {
                  unsetAttrName = def.unset;
                }
                if (!unsetAttrName && isString(def.set)) {
                  unsetAttrName = def.set;
                }
                if (!unsetAttrName) {
                  unsetAttrName = attrName;
                }
                if (isString(unsetAttrName) && unsetAttrName) {
                  normalAttrs || (normalAttrs = {});
                  if (unsetAttrName in normalAttrs) continue;
                  normalAttrs[unsetAttrName] = attrVal;
                } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {
                  normalAttrs || (normalAttrs = {});
                  for (i = 0, n = unsetAttrName.length; i < n; i++) {
                    const attrName2 = unsetAttrName[i];
                    if (attrName2 in normalAttrs) continue;
                    normalAttrs[attrName2] = attrVal;
                  }
                }
              } else {
                if (!isFunction(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {
                  if (isString(def.set)) {
                    normalAttrs || (normalAttrs = {});
                    normalAttrs[def.set] = attrVal;
                  }
                  relatives.push(attrName, def);
                } else {
                  normalAttrs || (normalAttrs = {});
                  normalAttrs[attrName] = attrVal;
                }
              }
            } else {
              normalAttrs || (normalAttrs = {});
              normalAttrs[attrName] = attrVal;
            }
          }
          for (i = 0, n = relatives.length; i < n; i += 2) {
            attrName = relatives[i];
            def = relatives[i + 1];
            attrVal = attrs[attrName];
            if (isFunction(def.set)) {
              setAttrs || (setAttrs = {});
              setAttrs[attrName] = attrVal;
            }
            if (isFunction(def.position)) {
              positionAttrs || (positionAttrs = {});
              positionAttrs[attrName] = attrVal;
            }
            if (isFunction(def.offset)) {
              offsetAttrs || (offsetAttrs = {});
              offsetAttrs[attrName] = attrVal;
            }
          }
          return {
            raw: rawAttrs,
            normal: normalAttrs,
            set: setAttrs,
            position: positionAttrs,
            offset: offsetAttrs
          };
        },
        updateRelativeAttributes: function(node, attrs, refBBox, opt) {
          opt || (opt = {});
          var attrName, attrVal, def;
          var evalAttrs = evalAttributes(attrs.raw || {}, refBBox);
          var nodeAttrs = attrs.normal || {};
          for (const nodeAttrName in nodeAttrs) {
            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];
          }
          var setAttrs = attrs.set;
          var positionAttrs = attrs.position;
          var offsetAttrs = attrs.offset;
          for (attrName in setAttrs) {
            attrVal = evalAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
            if (isObject(setResult)) {
              assign(nodeAttrs, setResult);
            } else if (setResult !== void 0) {
              nodeAttrs[attrName] = setResult;
            }
          }
          if (node instanceof HTMLElement) {
            this.setNodeAttributes(node, nodeAttrs);
            return;
          }
          var nodeTransform = nodeAttrs.transform;
          var nodeMatrix = V2.transformStringToMatrix(nodeTransform);
          var nodePosition = Point(nodeMatrix.e, nodeMatrix.f);
          if (nodeTransform) {
            nodeAttrs = omit(nodeAttrs, "transform");
            nodeMatrix.e = nodeMatrix.f = 0;
          }
          var sx, sy, translation;
          if (positionAttrs || offsetAttrs) {
            var nodeScale = this.getNodeScale(node, opt.scalableNode);
            sx = nodeScale.sx;
            sy = nodeScale.sy;
          }
          var positioned = false;
          for (attrName in positionAttrs) {
            attrVal = evalAttrs[attrName];
            def = this.getAttributeDefinition(attrName);
            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);
            if (translation) {
              nodePosition.offset(Point(translation).scale(sx, sy));
              positioned || (positioned = true);
            }
          }
          this.setNodeAttributes(node, nodeAttrs);
          var offseted = false;
          if (offsetAttrs) {
            var nodeBoundingRect = this.getNodeBoundingRect(node);
            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {
              var nodeBBox = V2.transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);
              for (attrName in offsetAttrs) {
                attrVal = evalAttrs[attrName];
                def = this.getAttributeDefinition(attrName);
                translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);
                if (translation) {
                  nodePosition.offset(Point(translation).scale(sx, sy));
                  offseted || (offseted = true);
                }
              }
            }
          }
          if (nodeTransform !== void 0 || positioned || offseted) {
            nodePosition.round(1);
            nodeMatrix.e = nodePosition.x;
            nodeMatrix.f = nodePosition.y;
            node.setAttribute("transform", V2.matrixToTransformString(nodeMatrix));
          }
        },
        getNodeScale: function(node, scalableNode) {
          var sx, sy;
          if (scalableNode && scalableNode.contains(node)) {
            var scale2 = scalableNode.scale();
            sx = 1 / scale2.sx;
            sy = 1 / scale2.sy;
          } else {
            sx = 1;
            sy = 1;
          }
          return {
            sx,
            sy
          };
        },
        cleanNodesCache: function() {
          this.metrics = {};
        },
        cleanNodeCache: function(node) {
          const id2 = node.id;
          if (!id2) return;
          delete this.metrics[id2];
        },
        nodeCache: function(magnet) {
          var metrics = this.metrics;
          if (!metrics) return {};
          var id2 = V2.ensureId(magnet);
          var value = metrics[id2];
          if (!value) value = metrics[id2] = {};
          return value;
        },
        getNodeData: function(magnet) {
          var metrics = this.nodeCache(magnet);
          if (!metrics.data) metrics.data = {};
          return metrics.data;
        },
        getNodeBoundingRect: function(magnet) {
          var metrics = this.nodeCache(magnet);
          if (metrics.boundingRect === void 0) {
            const {
              measureNode
            } = this.paper.options;
            if (typeof measureNode === "function") {
              metrics.boundingRect = measureNode(magnet, this);
            } else {
              metrics.boundingRect = V2(magnet).getBBox();
            }
          }
          return new Rect(metrics.boundingRect);
        },
        getNodeMatrix: function(magnet) {
          const metrics = this.nodeCache(magnet);
          if (metrics.magnetMatrix === void 0) {
            const {
              rotatableNode,
              el
            } = this;
            let target;
            if (rotatableNode && rotatableNode.contains(magnet)) {
              target = rotatableNode;
            } else {
              target = el;
            }
            metrics.magnetMatrix = V2(magnet).getTransformToElement(target, {
              // We use `safe` mode if the magnet is not visible (not in the DOM render tree).
              // The browser would not be able to calculate the transformation matrix
              // using `getScreenCTM()` method.
              safe: !magnet.checkVisibility()
            });
          }
          return V2.createSVGMatrix(metrics.magnetMatrix);
        },
        getNodeShape: function(magnet) {
          var metrics = this.nodeCache(magnet);
          if (metrics.geometryShape === void 0) metrics.geometryShape = V2(magnet).toGeometryShape();
          return metrics.geometryShape.clone();
        },
        isNodeConnection: function(node) {
          return this.model.isLink() && (!node || node === this.el);
        },
        findNodesAttributes: function(attrs, root, selectorCache, selectors) {
          var i, n, nodeAttrs, nodeId;
          var nodesAttrs = {};
          var mergeIds = [];
          for (var selector in attrs) {
            if (!attrs.hasOwnProperty(selector)) continue;
            nodeAttrs = attrs[selector];
            if (!isPlainObject(nodeAttrs)) continue;
            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);
            for (i = 0, n = selected.length; i < n; i++) {
              var node = selected[i];
              nodeId = V2.ensureId(node);
              var unique = selectors && selectors[selector] === node;
              var prevNodeAttrs = nodesAttrs[nodeId];
              if (prevNodeAttrs) {
                if (!prevNodeAttrs.array) {
                  mergeIds.push(nodeId);
                  prevNodeAttrs.array = true;
                  prevNodeAttrs.attributes = [prevNodeAttrs.attributes];
                  prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];
                }
                var attributes2 = prevNodeAttrs.attributes;
                var selectedLength = prevNodeAttrs.selectedLength;
                if (unique) {
                  attributes2.unshift(nodeAttrs);
                  selectedLength.unshift(-1);
                } else {
                  var sortIndex = sortedIndex(selectedLength, n);
                  attributes2.splice(sortIndex, 0, nodeAttrs);
                  selectedLength.splice(sortIndex, 0, n);
                }
              } else {
                nodesAttrs[nodeId] = {
                  attributes: nodeAttrs,
                  selectedLength: unique ? -1 : n,
                  node,
                  array: false
                };
              }
            }
          }
          for (i = 0, n = mergeIds.length; i < n; i++) {
            nodeId = mergeIds[i];
            nodeAttrs = nodesAttrs[nodeId];
            nodeAttrs.attributes = merge({}, ...nodeAttrs.attributes.reverse());
          }
          return nodesAttrs;
        },
        getEventTarget: function(evt, opt = {}) {
          const {
            target,
            type,
            clientX = 0,
            clientY = 0
          } = evt;
          if (
            // Explicitly defined `fromPoint` option
            opt.fromPoint || // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.
            // It holds the element when a touchstart triggered.
            type === "touchmove" || type === "touchend" || // Pointermove/Pointerup event with the pointer captured
            "pointerId" in evt && target.hasPointerCapture(evt.pointerId)
          ) {
            return document.elementFromPoint(clientX, clientY);
          }
          return target;
        },
        // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,
        // unless `attrs` parameter was passed.
        updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {
          opt || (opt = {});
          opt.rootBBox || (opt.rootBBox = Rect());
          opt.selectors || (opt.selectors = this.selectors);
          var selectorCache = {};
          var bboxCache = {};
          var relativeItems = [];
          var relativeRefItems = [];
          var item, node, nodeAttrs, nodeData, processedAttrs;
          var roAttrs = opt.roAttributes;
          var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);
          var nodesAllAttrs = roAttrs ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors) : nodesAttrs;
          for (var nodeId in nodesAttrs) {
            nodeData = nodesAttrs[nodeId];
            nodeAttrs = nodeData.attributes;
            node = nodeData.node;
            processedAttrs = this.processNodeAttributes(node, nodeAttrs);
            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {
              this.setNodeAttributes(node, evalAttributes(processedAttrs.normal, opt.rootBBox));
            } else {
              var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;
              var refSelector = nodeAllAttrs && nodeAttrs.ref === void 0 ? nodeAllAttrs.ref : nodeAttrs.ref;
              var refNode;
              if (refSelector) {
                refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];
                if (!refNode) {
                  throw new Error('dia.CellView: "' + refSelector + '" reference does not exist.');
                }
              } else {
                refNode = null;
              }
              item = {
                node,
                refNode,
                processedAttributes: processedAttrs,
                allAttributes: nodeAllAttrs
              };
              if (refNode) {
                var itemIndex = relativeRefItems.findIndex(function(item2) {
                  return item2.refNode === node;
                });
                if (itemIndex > -1) {
                  relativeRefItems.splice(itemIndex, 0, item);
                } else {
                  relativeRefItems.push(item);
                }
              } else {
                relativeItems.push(item);
              }
            }
          }
          relativeItems.push(...relativeRefItems);
          for (let i = 0, n = relativeItems.length; i < n; i++) {
            item = relativeItems[i];
            node = item.node;
            refNode = item.refNode;
            const refNodeId = refNode ? V2.ensureId(refNode) : "";
            let refBBox = bboxCache[refNodeId];
            if (!refBBox) {
              if (refNode) {
                const refRect = this.getNodeBoundingRect(refNode);
                const refTMatrix = V2(refNode).getTransformToElement(V2.getCommonAncestor(node, refNode));
                refBBox = V2.transformRect(refRect, refTMatrix);
              } else {
                refBBox = opt.rootBBox;
              }
              bboxCache[refNodeId] = refBBox;
            }
            if (roAttrs) {
              processedAttrs = this.processNodeAttributes(node, item.allAttributes);
              this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);
            } else {
              processedAttrs = item.processedAttributes;
            }
            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);
          }
        },
        mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {
          processedAttrs.set || (processedAttrs.set = {});
          processedAttrs.position || (processedAttrs.position = {});
          processedAttrs.offset || (processedAttrs.offset = {});
          assign(processedAttrs.set, roProcessedAttrs.set);
          assign(processedAttrs.position, roProcessedAttrs.position);
          assign(processedAttrs.offset, roProcessedAttrs.offset);
          var transform = processedAttrs.normal && processedAttrs.normal.transform;
          if (transform !== void 0 && roProcessedAttrs.normal) {
            roProcessedAttrs.normal.transform = transform;
          }
          processedAttrs.normal = roProcessedAttrs.normal;
        },
        // Lifecycle methods
        // Called when the view is attached to the DOM,
        // as result of `cell.addTo(graph)` being called (isInitialMount === true)
        // or `paper.options.viewport` returning `true` (isInitialMount === false).
        onMount(isInitialMount) {
          if (isInitialMount) return;
          this.mountTools();
          HighlighterView.mount(this);
        },
        // Called when the view is detached from the DOM,
        // as result of `paper.options.viewport` returning `false`.
        onDetach() {
          this.unmountTools();
          HighlighterView.unmount(this);
        },
        // Called when the view is removed from the DOM
        // as result of `cell.remove()`.
        onRemove: function() {
          this.removeTools();
          this.removeHighlighters();
        },
        _toolsView: null,
        hasTools: function(name) {
          var toolsView = this._toolsView;
          if (!toolsView) return false;
          if (!name) return true;
          return toolsView.getName() === name;
        },
        addTools: function(toolsView) {
          this.removeTools();
          if (toolsView) {
            this._toolsView = toolsView;
            toolsView.configure({
              relatedView: this
            });
            toolsView.listenTo(this.paper, "tools:event", this.onToolEvent.bind(this));
          }
          return this;
        },
        unmountTools() {
          const toolsView = this._toolsView;
          if (toolsView) toolsView.unmount();
          return this;
        },
        mountTools() {
          const toolsView = this._toolsView;
          if (toolsView && !toolsView.isMounted()) toolsView.mount();
          return this;
        },
        updateTools: function(opt) {
          var toolsView = this._toolsView;
          if (toolsView) toolsView.update(opt);
          return this;
        },
        removeTools: function() {
          var toolsView = this._toolsView;
          if (toolsView) {
            toolsView.remove();
            this._toolsView = null;
          }
          return this;
        },
        hideTools: function() {
          var toolsView = this._toolsView;
          if (toolsView) toolsView.hide();
          return this;
        },
        showTools: function() {
          var toolsView = this._toolsView;
          if (toolsView) toolsView.show();
          return this;
        },
        onToolEvent: function(event) {
          switch (event) {
            case "remove":
              this.removeTools();
              break;
            case "hide":
              this.hideTools();
              break;
            case "show":
              this.showTools();
              break;
          }
        },
        removeHighlighters: function() {
          HighlighterView.remove(this);
        },
        updateHighlighters: function(dirty = false) {
          HighlighterView.update(this, null, dirty);
        },
        transformHighlighters: function() {
          HighlighterView.transform(this);
        },
        // Interaction. The controller part.
        // ---------------------------------
        preventDefaultInteraction(evt) {
          this.eventData(evt, {
            defaultInteractionPrevented: true
          });
        },
        isDefaultInteractionPrevented(evt) {
          const {
            defaultInteractionPrevented = false
          } = this.eventData(evt);
          return defaultInteractionPrevented;
        },
        // Interaction is handled by the paper and delegated to the view in interest.
        // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.
        // If necessary, real coordinates can be obtained from the `evt` event object.
        // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,
        // i.e. `joint.dia.Element` and `joint.dia.Link`.
        pointerdblclick: function(evt, x, y) {
          this.notify("cell:pointerdblclick", evt, x, y);
        },
        pointerclick: function(evt, x, y) {
          this.notify("cell:pointerclick", evt, x, y);
        },
        contextmenu: function(evt, x, y) {
          this.notify("cell:contextmenu", evt, x, y);
        },
        pointerdown: function(evt, x, y) {
          const {
            model
          } = this;
          const {
            graph
          } = model;
          if (graph) {
            model.startBatch("pointer");
            this.eventData(evt, {
              graph
            });
          }
          this.notify("cell:pointerdown", evt, x, y);
        },
        pointermove: function(evt, x, y) {
          this.notify("cell:pointermove", evt, x, y);
        },
        pointerup: function(evt, x, y) {
          const {
            graph
          } = this.eventData(evt);
          this.notify("cell:pointerup", evt, x, y);
          if (graph) {
            graph.stopBatch("pointer", {
              cell: this.model
            });
          }
        },
        mouseover: function(evt) {
          this.notify("cell:mouseover", evt);
        },
        mouseout: function(evt) {
          this.notify("cell:mouseout", evt);
        },
        mouseenter: function(evt) {
          this.notify("cell:mouseenter", evt);
        },
        mouseleave: function(evt) {
          this.notify("cell:mouseleave", evt);
        },
        mousewheel: function(evt, x, y, delta) {
          this.notify("cell:mousewheel", evt, x, y, delta);
        },
        onevent: function(evt, eventName, x, y) {
          this.notify(eventName, evt, x, y);
        },
        onmagnet: function() {
        },
        magnetpointerdblclick: function() {
        },
        magnetcontextmenu: function() {
        },
        checkMouseleave(evt) {
          const {
            paper,
            model
          } = this;
          if (paper.isAsync()) {
            if (model.isLink()) {
              const sourceElement = model.getSourceElement();
              if (sourceElement) {
                const sourceView = paper.findViewByModel(sourceElement);
                if (sourceView) {
                  paper.dumpView(sourceView);
                  paper.checkViewVisibility(sourceView);
                }
              }
              const targetElement = model.getTargetElement();
              if (targetElement) {
                const targetView = paper.findViewByModel(targetElement);
                if (targetView) {
                  paper.dumpView(targetView);
                  paper.checkViewVisibility(targetView);
                }
              }
            }
            paper.dumpView(this);
            paper.checkViewVisibility(this);
          }
          const target = this.getEventTarget(evt, {
            fromPoint: true
          });
          const view = paper.findView(target);
          if (view === this) return;
          this.mouseleave(evt);
          if (!view) return;
          view.mouseenter(evt);
        },
        setInteractivity: function(value) {
          this.options.interactive = value;
        },
        isIntersecting: function(geometryShape, geometryData) {
          return intersection$1.exists(geometryShape, this.getNodeBBox(this.el), geometryData);
        },
        isEnclosedIn: function(geometryRect) {
          return geometryRect.containsRect(this.getNodeBBox(this.el));
        },
        isInArea: function(geometryRect, options = {}) {
          if (options.strict) {
            return this.isEnclosedIn(geometryRect);
          }
          return this.isIntersecting(geometryRect);
        },
        isAtPoint: function(point2, options) {
          return this.getNodeBBox(this.el).containsPoint(point2, options);
        }
      }, {
        Flags: Flags$2,
        Highlighting: HighlightingTypes$1,
        addPresentationAttributes: function(presentationAttributes) {
          return merge({}, result(this.prototype, "presentationAttributes"), presentationAttributes, function(a, b) {
            if (!a || !b) return;
            if (typeof a === "string") a = [a];
            if (typeof b === "string") b = [b];
            if (Array.isArray(a) && Array.isArray(b)) return uniq(a.concat(b));
          });
        },
        evalAttribute
      });
      Object.defineProperty(CellView.prototype, "useCSSSelectors", {
        get() {
          const localUse = this.model.useCSSSelectors;
          if (localUse !== void 0) return localUse;
          return config$3.useCSSSelectors;
        }
      });
      Object.defineProperty(CellView.prototype, CELL_VIEW_MARKER, {
        value: true
      });
      const Flags$1 = {
        TOOLS: CellView.Flags.TOOLS,
        UPDATE: "UPDATE",
        TRANSLATE: "TRANSLATE",
        RESIZE: "RESIZE",
        PORTS: "PORTS",
        ROTATE: "ROTATE",
        RENDER: "RENDER"
      };
      const DragActions = {
        MOVE: "move",
        MAGNET: "magnet"
      };
      const ElementView = CellView.extend({
        /**
         * @abstract
         */
        _removePorts: function() {
        },
        /**
         *
         * @abstract
         */
        _renderPorts: function() {
        },
        className: function() {
          var classNames = CellView.prototype.className.apply(this).split(" ");
          classNames.push("element");
          return classNames.join(" ");
        },
        initialize: function() {
          CellView.prototype.initialize.apply(this, arguments);
          this._initializePorts();
        },
        presentationAttributes: {
          "attrs": [Flags$1.UPDATE],
          "position": [Flags$1.TRANSLATE, Flags$1.TOOLS],
          "size": [Flags$1.RESIZE, Flags$1.PORTS, Flags$1.TOOLS],
          "angle": [Flags$1.ROTATE, Flags$1.TOOLS],
          "markup": [Flags$1.RENDER],
          "ports": [Flags$1.PORTS]
        },
        initFlag: [Flags$1.RENDER],
        UPDATE_PRIORITY: 0,
        confirmUpdate: function(flag, opt) {
          const {
            useCSSSelectors
          } = this;
          if (this.hasFlag(flag, Flags$1.PORTS)) {
            this._removePorts();
            this._cleanPortsCache();
          }
          let transformHighlighters = false;
          if (this.hasFlag(flag, Flags$1.RENDER)) {
            this.render();
            this.updateTools(opt);
            this.updateHighlighters(true);
            transformHighlighters = true;
            flag = this.removeFlag(flag, [Flags$1.RENDER, Flags$1.UPDATE, Flags$1.RESIZE, Flags$1.TRANSLATE, Flags$1.ROTATE, Flags$1.PORTS, Flags$1.TOOLS]);
          } else {
            let updateHighlighters = false;
            if (this.hasFlag(flag, Flags$1.RESIZE)) {
              this.resize(opt);
              updateHighlighters = true;
              flag = this.removeFlag(flag, [Flags$1.RESIZE, Flags$1.UPDATE]);
              if (useCSSSelectors) {
                flag = this.removeFlag(flag, Flags$1.PORTS);
              }
            }
            if (this.hasFlag(flag, Flags$1.UPDATE)) {
              this.update(this.model, null, opt);
              flag = this.removeFlag(flag, Flags$1.UPDATE);
              updateHighlighters = true;
              if (useCSSSelectors) {
                flag = this.removeFlag(flag, Flags$1.PORTS);
              }
            }
            if (this.hasFlag(flag, Flags$1.TRANSLATE)) {
              this.translate();
              flag = this.removeFlag(flag, Flags$1.TRANSLATE);
              transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags$1.ROTATE)) {
              this.rotate();
              flag = this.removeFlag(flag, Flags$1.ROTATE);
              transformHighlighters = true;
            }
            if (this.hasFlag(flag, Flags$1.PORTS)) {
              this._renderPorts();
              updateHighlighters = true;
              flag = this.removeFlag(flag, Flags$1.PORTS);
            }
            if (updateHighlighters) {
              this.updateHighlighters(false);
            }
          }
          if (transformHighlighters) {
            this.transformHighlighters();
          }
          if (this.hasFlag(flag, Flags$1.TOOLS)) {
            this.updateTools(opt);
            flag = this.removeFlag(flag, Flags$1.TOOLS);
          }
          return flag;
        },
        /**
         * @abstract
         */
        _initializePorts: function() {
        },
        update: function(_, renderingOnlyAttrs) {
          this.cleanNodesCache();
          const {
            useCSSSelectors
          } = this;
          if (useCSSSelectors) this._removePorts();
          var model = this.model;
          var modelAttrs = model.attr();
          this.updateDOMSubtreeAttributes(this.el, modelAttrs, {
            rootBBox: new Rect(model.size()),
            selectors: this.selectors,
            scalableNode: this.scalableNode,
            rotatableNode: this.rotatableNode,
            // Use rendering only attributes if they differs from the model attributes
            roAttributes: renderingOnlyAttrs === modelAttrs ? null : renderingOnlyAttrs
          });
          if (useCSSSelectors) {
            this._renderPorts();
          }
        },
        rotatableSelector: "rotatable",
        scalableSelector: "scalable",
        scalableNode: null,
        rotatableNode: null,
        // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the
        // default markup is not desirable.
        renderMarkup: function() {
          var element = this.model;
          var markup = element.get("markup") || element.markup;
          if (!markup) throw new Error("dia.ElementView: markup required");
          if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
          if (typeof markup === "string") return this.renderStringMarkup(markup);
          throw new Error("dia.ElementView: invalid markup");
        },
        renderJSONMarkup: function(markup) {
          var doc = this.parseDOMJSON(markup, this.el);
          var selectors = this.selectors = doc.selectors;
          this.rotatableNode = V2(selectors[this.rotatableSelector]) || null;
          this.scalableNode = V2(selectors[this.scalableSelector]) || null;
          this.vel.append(doc.fragment);
        },
        renderStringMarkup: function(markup) {
          var vel = this.vel;
          vel.append(V2(markup));
          this.rotatableNode = vel.findOne(".rotatable");
          this.scalableNode = vel.findOne(".scalable");
          var selectors = this.selectors = {};
          selectors[this.selector] = this.el;
        },
        render: function() {
          this.vel.empty();
          this.renderMarkup();
          if (this.scalableNode) {
            this.update();
          }
          this.resize();
          if (this.rotatableNode) {
            this.rotate();
            this.translate();
          } else {
            this.updateTransformation();
          }
          if (!this.useCSSSelectors) this._renderPorts();
          return this;
        },
        resize: function(opt) {
          if (this.scalableNode) return this.sgResize(opt);
          if (this.model.attributes.angle) this.rotate();
          this.update();
        },
        translate: function() {
          if (this.rotatableNode) return this.rgTranslate();
          this.updateTransformation();
        },
        rotate: function() {
          if (this.rotatableNode) {
            this.rgRotate();
            this.update();
            return;
          }
          this.updateTransformation();
        },
        updateTransformation: function() {
          var transformation = this.getTranslateString();
          var rotateString = this.getRotateString();
          if (rotateString) transformation += " " + rotateString;
          this.vel.attr("transform", transformation);
        },
        getTranslateString: function() {
          const {
            x,
            y
          } = this.model.position();
          return `translate(${x},${y})`;
        },
        getRotateString: function() {
          const angle = this.model.angle();
          if (!angle) return null;
          const {
            width: width2,
            height: height2
          } = this.model.size();
          return `rotate(${angle},${width2 / 2},${height2 / 2})`;
        },
        // Rotatable & Scalable Group
        // always slower, kept mainly for backwards compatibility
        rgRotate: function() {
          this.rotatableNode.attr("transform", this.getRotateString());
        },
        rgTranslate: function() {
          this.vel.attr("transform", this.getTranslateString());
        },
        sgResize: function(opt) {
          var model = this.model;
          var angle = model.angle();
          var size = model.size();
          var scalable = this.scalableNode;
          var recursive = false;
          if (scalable.node.getElementsByTagName("path").length > 0) {
            recursive = true;
          }
          var scalableBBox = scalable.getBBox({
            recursive
          });
          var sx = size.width / (scalableBBox.width || 1);
          var sy = size.height / (scalableBBox.height || 1);
          scalable.attr("transform", "scale(" + sx + "," + sy + ")");
          var rotatable = this.rotatableNode;
          var rotation = rotatable && rotatable.attr("transform");
          if (rotation) {
            rotatable.attr("transform", rotation + " rotate(" + -angle + "," + size.width / 2 + "," + size.height / 2 + ")");
            var rotatableBBox = scalable.getBBox({
              target: this.paper.cells
            });
            model.set("position", {
              x: rotatableBBox.x,
              y: rotatableBBox.y
            }, assign({
              updateHandled: true
            }, opt));
            this.translate();
            this.rotate();
          }
          this.update();
        },
        // Embedding mode methods.
        // -----------------------
        prepareEmbedding: function(data2 = {}) {
          const element = data2.model || this.model;
          const paper = data2.paper || this.paper;
          const graph = paper.model;
          const initialZIndices = data2.initialZIndices = {};
          const embeddedCells = element.getEmbeddedCells({
            deep: true
          });
          const connectedLinks = graph.getConnectedLinks(element, {
            deep: true,
            includeEnclosed: true
          });
          [element, ...embeddedCells, ...connectedLinks].forEach((cell) => initialZIndices[cell.id] = cell.attributes.z);
          element.startBatch("to-front");
          element.toFront({
            deep: true,
            ui: true
          });
          const maxZ = graph.getElements().reduce((max2, cell) => Math.max(max2, cell.attributes.z || 0), 0);
          connectedLinks.forEach((link) => {
            if (link.attributes.z <= maxZ) {
              link.set("z", maxZ + 1, {
                ui: true
              });
            }
          });
          element.stopBatch("to-front");
          const parentId = element.parent();
          if (parentId) {
            const parent2 = graph.getCell(parentId);
            parent2.unembed(element, {
              ui: true
            });
            data2.initialParentId = parentId;
          } else {
            data2.initialParentId = data2.initialParentId || null;
          }
        },
        processEmbedding: function(data2 = {}, evt, x, y) {
          const model = data2.model || this.model;
          const paper = data2.paper || this.paper;
          const graph = paper.model;
          const {
            findParentBy,
            frontParentOnly,
            validateEmbedding
          } = paper.options;
          let candidates;
          if (isFunction(findParentBy)) {
            candidates = toArray$1(findParentBy.call(graph, this, evt, x, y));
          } else if (findParentBy === "pointer") {
            candidates = graph.findElementsAtPoint({
              x,
              y
            });
          } else {
            candidates = graph.findElementsUnderElement(model, {
              searchBy: findParentBy
            });
          }
          candidates = candidates.filter((el) => {
            return el instanceof Cell && model.id !== el.id && !el.isEmbeddedIn(model);
          });
          if (frontParentOnly) {
            candidates = candidates.slice(-1);
          }
          let newCandidateView = null;
          const prevCandidateView = data2.candidateEmbedView;
          for (let i = candidates.length - 1; i >= 0; i--) {
            const candidate = candidates[i];
            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {
              newCandidateView = prevCandidateView;
              break;
            } else {
              const view = candidate.findView(paper);
              if (!isFunction(validateEmbedding) || validateEmbedding.call(paper, this, view)) {
                newCandidateView = view;
                break;
              }
            }
          }
          if (newCandidateView && newCandidateView != prevCandidateView) {
            this.clearEmbedding(data2);
            data2.candidateEmbedView = newCandidateView.highlight(newCandidateView.findProxyNode(null, "container"), {
              embedding: true
            });
          }
          if (!newCandidateView && prevCandidateView) {
            this.clearEmbedding(data2);
          }
        },
        clearEmbedding: function(data2) {
          data2 || (data2 = {});
          var candidateView = data2.candidateEmbedView;
          if (candidateView) {
            candidateView.unhighlight(candidateView.findProxyNode(null, "container"), {
              embedding: true
            });
            data2.candidateEmbedView = null;
          }
        },
        finalizeEmbedding: function(data2 = {}) {
          const candidateView = data2.candidateEmbedView;
          const element = data2.model || this.model;
          const paper = data2.paper || this.paper;
          if (candidateView) {
            candidateView.model.embed(element, {
              ui: true
            });
            candidateView.unhighlight(candidateView.findProxyNode(null, "container"), {
              embedding: true
            });
            data2.candidateEmbedView = null;
          } else {
            const {
              validateUnembedding
            } = paper.options;
            const {
              initialParentId
            } = data2;
            if (initialParentId && typeof validateUnembedding === "function" && !validateUnembedding.call(paper, this)) {
              this._disallowUnembed(data2);
              return;
            }
          }
          paper.model.getConnectedLinks(element, {
            deep: true
          }).forEach((link) => {
            link.reparent({
              ui: true
            });
          });
        },
        _disallowUnembed: function(data2) {
          const {
            model,
            whenNotAllowed = "revert"
          } = data2;
          const element = model || this.model;
          const paper = data2.paper || this.paper;
          const graph = paper.model;
          switch (whenNotAllowed) {
            case "remove": {
              element.remove({
                ui: true
              });
              break;
            }
            case "revert": {
              const {
                initialParentId,
                initialPosition,
                initialZIndices
              } = data2;
              if (initialPosition) {
                const {
                  x,
                  y
                } = initialPosition;
                element.position(x, y, {
                  deep: true,
                  ui: true
                });
              }
              if (initialZIndices) {
                Object.keys(initialZIndices).forEach((id2) => {
                  const cell = graph.getCell(id2);
                  if (cell) {
                    cell.set("z", initialZIndices[id2], {
                      ui: true
                    });
                  }
                });
              }
              const parent2 = graph.getCell(initialParentId);
              if (parent2) {
                parent2.embed(element, {
                  ui: true
                });
              }
              break;
            }
          }
        },
        getTargetParentView: function(evt) {
          const {
            candidateEmbedView = null
          } = this.eventData(evt);
          return candidateEmbedView;
        },
        getDelegatedView: function() {
          var view = this;
          var model = view.model;
          var paper = view.paper;
          while (view) {
            if (model.isLink()) break;
            if (!model.isEmbedded() || view.can("stopDelegation")) return view;
            model = model.getParentCell();
            view = paper.findViewByModel(model);
          }
          return null;
        },
        findProxyNode: function(el, type) {
          el || (el = this.el);
          const nodeSelector = el.getAttribute(`${type}-selector`);
          if (nodeSelector) {
            const port = this.findAttribute("port", el);
            if (port) {
              const proxyPortNode = this.findPortNode(port, nodeSelector);
              if (proxyPortNode) return proxyPortNode;
            } else {
              const proxyNode = this.findNode(nodeSelector);
              if (proxyNode) return proxyNode;
            }
          }
          return el;
        },
        // Interaction. The controller part.
        // ---------------------------------
        notifyPointerdown(evt, x, y) {
          CellView.prototype.pointerdown.call(this, evt, x, y);
          this.notify("element:pointerdown", evt, x, y);
        },
        notifyPointermove(evt, x, y) {
          CellView.prototype.pointermove.call(this, evt, x, y);
          this.notify("element:pointermove", evt, x, y);
        },
        notifyPointerup(evt, x, y) {
          this.notify("element:pointerup", evt, x, y);
          CellView.prototype.pointerup.call(this, evt, x, y);
        },
        pointerdblclick: function(evt, x, y) {
          CellView.prototype.pointerdblclick.apply(this, arguments);
          this.notify("element:pointerdblclick", evt, x, y);
        },
        pointerclick: function(evt, x, y) {
          CellView.prototype.pointerclick.apply(this, arguments);
          this.notify("element:pointerclick", evt, x, y);
        },
        contextmenu: function(evt, x, y) {
          CellView.prototype.contextmenu.apply(this, arguments);
          this.notify("element:contextmenu", evt, x, y);
        },
        pointerdown: function(evt, x, y) {
          this.notifyPointerdown(evt, x, y);
          this.dragStart(evt, x, y);
        },
        pointermove: function(evt, x, y) {
          const data2 = this.eventData(evt);
          const {
            targetMagnet,
            action,
            delegatedView
          } = data2;
          if (targetMagnet) {
            this.magnetpointermove(evt, targetMagnet, x, y);
          }
          switch (action) {
            case DragActions.MAGNET:
              this.dragMagnet(evt, x, y);
              break;
            case DragActions.MOVE:
              (delegatedView || this).drag(evt, x, y);
            // eslint: no-fallthrough=false
            default:
              if (data2.preventPointerEvents) break;
              this.notifyPointermove(evt, x, y);
              break;
          }
          this.eventData(evt, data2);
        },
        pointerup: function(evt, x, y) {
          const data2 = this.eventData(evt);
          const {
            targetMagnet,
            action,
            delegatedView
          } = data2;
          if (targetMagnet) {
            this.magnetpointerup(evt, targetMagnet, x, y);
          }
          switch (action) {
            case DragActions.MAGNET:
              this.dragMagnetEnd(evt, x, y);
              break;
            case DragActions.MOVE:
              (delegatedView || this).dragEnd(evt, x, y);
            // eslint: no-fallthrough=false
            default:
              if (data2.preventPointerEvents) break;
              this.notifyPointerup(evt, x, y);
          }
          if (targetMagnet) {
            this.magnetpointerclick(evt, targetMagnet, x, y);
          }
          this.checkMouseleave(evt);
        },
        mouseover: function(evt) {
          CellView.prototype.mouseover.apply(this, arguments);
          this.notify("element:mouseover", evt);
        },
        mouseout: function(evt) {
          CellView.prototype.mouseout.apply(this, arguments);
          this.notify("element:mouseout", evt);
        },
        mouseenter: function(evt) {
          CellView.prototype.mouseenter.apply(this, arguments);
          this.notify("element:mouseenter", evt);
        },
        mouseleave: function(evt) {
          CellView.prototype.mouseleave.apply(this, arguments);
          this.notify("element:mouseleave", evt);
        },
        mousewheel: function(evt, x, y, delta) {
          CellView.prototype.mousewheel.apply(this, arguments);
          this.notify("element:mousewheel", evt, x, y, delta);
        },
        onmagnet: function(evt, x, y) {
          const {
            currentTarget: targetMagnet
          } = evt;
          this.magnetpointerdown(evt, targetMagnet, x, y);
          this.eventData(evt, {
            targetMagnet
          });
          this.dragMagnetStart(evt, x, y);
        },
        magnetpointerdown: function(evt, magnet, x, y) {
          this.notify("element:magnet:pointerdown", evt, magnet, x, y);
        },
        magnetpointermove: function(evt, magnet, x, y) {
          this.notify("element:magnet:pointermove", evt, magnet, x, y);
        },
        magnetpointerup: function(evt, magnet, x, y) {
          this.notify("element:magnet:pointerup", evt, magnet, x, y);
        },
        magnetpointerdblclick: function(evt, magnet, x, y) {
          this.notify("element:magnet:pointerdblclick", evt, magnet, x, y);
        },
        magnetcontextmenu: function(evt, magnet, x, y) {
          this.notify("element:magnet:contextmenu", evt, magnet, x, y);
        },
        // Drag Start Handlers
        dragStart: function(evt, x, y) {
          if (this.isDefaultInteractionPrevented(evt)) return;
          var view = this.getDelegatedView();
          if (!view || !view.can("elementMove")) return;
          this.eventData(evt, {
            action: DragActions.MOVE,
            delegatedView: view
          });
          const position2 = view.model.position();
          view.eventData(evt, {
            initialPosition: position2,
            pointerOffset: position2.difference(x, y),
            restrictedArea: this.paper.getRestrictedArea(view, x, y)
          });
        },
        dragMagnetStart: function(evt, x, y) {
          const {
            paper
          } = this;
          const isPropagationAlreadyStopped = evt.isPropagationStopped();
          if (isPropagationAlreadyStopped) {
            this.eventData(evt, {
              preventPointerEvents: true
            });
          }
          if (this.isDefaultInteractionPrevented(evt) || !this.can("addLinkFromMagnet")) {
            return;
          }
          const {
            targetMagnet = evt.currentTarget
          } = this.eventData(evt);
          evt.stopPropagation();
          if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {
            if (isPropagationAlreadyStopped) {
              this.dragStart(evt, x, y);
            } else {
              this.pointerdown(evt, x, y);
            }
            return;
          }
          if (paper.options.magnetThreshold <= 0) {
            this.dragLinkStart(evt, targetMagnet, x, y);
          }
          this.eventData(evt, {
            action: DragActions.MAGNET
          });
        },
        // Drag Handlers
        snapToGrid: function(evt, x, y) {
          const grid = this.paper.options.gridSize;
          return {
            x: snapToGrid$1(x, grid),
            y: snapToGrid$1(y, grid)
          };
        },
        drag: function(evt, x, y) {
          var paper = this.paper;
          var element = this.model;
          var data2 = this.eventData(evt);
          var {
            pointerOffset,
            restrictedArea,
            embedding
          } = data2;
          const {
            x: elX,
            y: elY
          } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);
          element.position(elX, elY, {
            restrictedArea,
            deep: true,
            ui: true
          });
          if (paper.options.embeddingMode) {
            if (!embedding) {
              this.prepareEmbedding(data2);
              embedding = true;
            }
            this.processEmbedding(data2, evt, x, y);
          }
          this.eventData(evt, {
            embedding
          });
        },
        dragMagnet: function(evt, x, y) {
          this.dragLink(evt, x, y);
        },
        // Drag End Handlers
        dragEnd: function(evt, x, y) {
          var data2 = this.eventData(evt);
          if (data2.embedding) this.finalizeEmbedding(data2);
        },
        dragMagnetEnd: function(evt, x, y) {
          this.dragLinkEnd(evt, x, y);
        },
        magnetpointerclick: function(evt, magnet, x, y) {
          var paper = this.paper;
          if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;
          this.notify("element:magnet:pointerclick", evt, magnet, x, y);
        }
      }, {
        Flags: Flags$1
      });
      assign(ElementView.prototype, elementViewPortPrototype);
      const Flags = {
        TOOLS: CellView.Flags.TOOLS,
        RENDER: "RENDER",
        UPDATE: "UPDATE",
        LABELS: "LABELS",
        SOURCE: "SOURCE",
        TARGET: "TARGET",
        CONNECTOR: "CONNECTOR"
      };
      const LinkView = CellView.extend({
        className: function() {
          var classNames = CellView.prototype.className.apply(this).split(" ");
          classNames.push("link");
          return classNames.join(" ");
        },
        _labelCache: null,
        _labelSelectors: null,
        _V: null,
        _sourceMagnet: null,
        _targetMagnet: null,
        _dragData: null,
        // deprecated
        metrics: null,
        decimalsRounding: 2,
        initialize: function() {
          CellView.prototype.initialize.apply(this, arguments);
          this._labelCache = {};
          this._labelSelectors = {};
          this._V = {};
          this.cleanNodesCache();
        },
        presentationAttributes: {
          markup: [Flags.RENDER],
          attrs: [Flags.UPDATE],
          router: [Flags.UPDATE],
          connector: [Flags.CONNECTOR],
          labels: [Flags.LABELS, Flags.TOOLS],
          labelMarkup: [Flags.LABELS],
          vertices: [Flags.UPDATE],
          source: [Flags.SOURCE, Flags.UPDATE],
          target: [Flags.TARGET, Flags.UPDATE]
        },
        initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],
        UPDATE_PRIORITY: 1,
        EPSILON: 1e-6,
        confirmUpdate: function(flags, opt = {}) {
          const {
            paper,
            model
          } = this;
          const {
            attributes: attributes2
          } = model;
          const {
            source: {
              id: sourceId
            },
            target: {
              id: targetId
            }
          } = attributes2;
          if (this.hasFlag(flags, Flags.SOURCE)) {
            this._sourceMagnet = null;
            this.checkEndModel("source", sourceId);
            flags = this.removeFlag(flags, Flags.SOURCE);
          }
          if (this.hasFlag(flags, Flags.TARGET)) {
            this._targetMagnet = null;
            this.checkEndModel("target", targetId);
            flags = this.removeFlag(flags, Flags.TARGET);
          }
          if (paper && (sourceId && !paper.isCellVisible(sourceId) || targetId && !paper.isCellVisible(targetId))) {
            return flags;
          }
          if (this.hasFlag(flags, Flags.RENDER)) {
            this.render();
            this.updateHighlighters(true);
            this.updateTools(opt);
            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);
            if (env.test("isAppleWebKit")) {
              this.__fixWebKitBug268376();
            }
            return flags;
          }
          let updateHighlighters = false;
          let updateLabels = this.hasFlag(flags, Flags.LABELS);
          if (updateLabels) {
            this.onLabelsChange(model, attributes2.labels, opt);
            flags = this.removeFlag(flags, Flags.LABELS);
            updateHighlighters = true;
          }
          const updateAll = this.hasFlag(flags, Flags.UPDATE);
          const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);
          if (updateAll || updateConnector) {
            if (!updateAll) {
              this.updatePath();
              this.updateDOM();
            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {
              this.translate(opt.tx, opt.ty);
            } else {
              this.update();
            }
            this.updateTools(opt);
            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);
            updateLabels = false;
            updateHighlighters = true;
          }
          if (updateLabels) {
            this.updateLabelPositions();
          }
          if (updateHighlighters) {
            this.updateHighlighters();
          }
          if (this.hasFlag(flags, Flags.TOOLS)) {
            this.updateTools(opt);
            flags = this.removeFlag(flags, Flags.TOOLS);
          }
          return flags;
        },
        __fixWebKitBug268376: function() {
          const {
            el
          } = this;
          const childNodes = Array.from(el.childNodes);
          const fragment = document.createDocumentFragment();
          for (let i = 0, n = childNodes.length; i < n; i++) {
            el.removeChild(childNodes[i]);
            fragment.appendChild(childNodes[i]);
          }
          el.appendChild(fragment);
        },
        requestConnectionUpdate: function(opt) {
          this.requestUpdate(this.getFlag(Flags.UPDATE), opt);
        },
        isLabelsRenderRequired: function(opt = {}) {
          const previousLabels = this.model.previous("labels");
          if (!previousLabels) return true;
          if ("propertyPathArray" in opt && "propertyValue" in opt) {
            var pathArray = opt.propertyPathArray || [];
            var pathLength = pathArray.length;
            if (pathLength > 1) {
              var labelExists = !!previousLabels[pathArray[1]];
              if (labelExists) {
                if (pathLength === 2) {
                  return "markup" in Object(opt.propertyValue);
                } else if (pathArray[2] !== "markup") {
                  return false;
                }
              }
            }
          }
          return true;
        },
        onLabelsChange: function(_link, _labels, opt) {
          if (this.isLabelsRenderRequired(opt)) {
            this.renderLabels();
          } else {
            this.updateLabels();
          }
        },
        // Rendering.
        // ----------
        render: function() {
          this.vel.empty();
          this.unmountLabels();
          this._V = {};
          this.renderMarkup();
          this.renderLabels();
          this.update();
          return this;
        },
        renderMarkup: function() {
          var link = this.model;
          var markup = link.get("markup") || link.markup;
          if (!markup) throw new Error("dia.LinkView: markup required");
          if (Array.isArray(markup)) return this.renderJSONMarkup(markup);
          if (typeof markup === "string") return this.renderStringMarkup(markup);
          throw new Error("dia.LinkView: invalid markup");
        },
        renderJSONMarkup: function(markup) {
          var doc = this.parseDOMJSON(markup, this.el);
          this.selectors = doc.selectors;
          this.vel.append(doc.fragment);
        },
        renderStringMarkup: function(markup) {
          var children2 = V2(markup);
          if (!Array.isArray(children2)) children2 = [children2];
          this.vel.append(children2);
        },
        _getLabelMarkup: function(labelMarkup2) {
          if (!labelMarkup2) return void 0;
          if (Array.isArray(labelMarkup2)) return this.parseDOMJSON(labelMarkup2, null);
          if (typeof labelMarkup2 === "string") return this._getLabelStringMarkup(labelMarkup2);
          throw new Error("dia.linkView: invalid label markup");
        },
        _getLabelStringMarkup: function(labelMarkup2) {
          var children2 = V2(labelMarkup2);
          var fragment = document.createDocumentFragment();
          if (!Array.isArray(children2)) {
            fragment.appendChild(children2.node);
          } else {
            for (var i = 0, n = children2.length; i < n; i++) {
              var currentChild = children2[i].node;
              fragment.appendChild(currentChild);
            }
          }
          return {
            fragment,
            selectors: {}
          };
        },
        // Label markup fragment may come wrapped in <g class="label" />, or not.
        // If it doesn't, add the <g /> container here.
        _normalizeLabelMarkup: function(markup) {
          if (!markup) return void 0;
          var fragment = markup.fragment;
          if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error("dia.LinkView: invalid label markup.");
          var vNode;
          var childNodes = fragment.childNodes;
          if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== "G") {
            vNode = V2("g").append(fragment);
          } else {
            vNode = V2(childNodes[0]);
          }
          vNode.addClass("label");
          return {
            node: vNode.node,
            selectors: markup.selectors
          };
        },
        renderLabels: function() {
          var cache2 = this._V;
          var vLabels = cache2.labels;
          var labelCache = this._labelCache = {};
          var labelSelectors = this._labelSelectors = {};
          var model = this.model;
          var labels = model.attributes.labels || [];
          var labelsCount = labels.length;
          if (labelsCount === 0) {
            if (vLabels) vLabels.remove();
            return this;
          }
          if (vLabels) {
            vLabels.empty();
          } else {
            vLabels = cache2.labels = V2("g").addClass("labels");
            if (this.options.labelsLayer) {
              vLabels.addClass(addClassNamePrefix(result(this, "className")));
              vLabels.attr("model-id", model.id);
            }
          }
          for (var i = 0; i < labelsCount; i++) {
            var label = labels[i];
            var labelMarkup2 = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));
            var labelNode;
            var selectors;
            if (labelMarkup2) {
              labelNode = labelMarkup2.node;
              selectors = labelMarkup2.selectors;
            } else {
              var builtinDefaultLabel = model._builtins.defaultLabel;
              var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));
              var defaultLabel = model._getDefaultLabel();
              var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));
              var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;
              labelNode = defaultMarkup.node;
              selectors = defaultMarkup.selectors;
            }
            labelNode.setAttribute("label-idx", i);
            vLabels.append(labelNode);
            labelCache[i] = labelNode;
            var rootSelector = this.selector;
            if (selectors[rootSelector]) throw new Error("dia.LinkView: ambiguous label root selector.");
            selectors[rootSelector] = labelNode;
            labelSelectors[i] = selectors;
          }
          if (!vLabels.parent()) {
            this.mountLabels();
          }
          this.updateLabels();
          return this;
        },
        mountLabels: function() {
          const {
            el,
            paper,
            model,
            _V,
            options
          } = this;
          const {
            labels: vLabels
          } = _V;
          if (!vLabels || !model.hasLabels()) return;
          const {
            node
          } = vLabels;
          if (options.labelsLayer) {
            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get("z"));
          } else {
            if (node.parentNode !== el) {
              el.appendChild(node);
            }
          }
        },
        unmountLabels: function() {
          const {
            options,
            _V
          } = this;
          if (!_V) return;
          const {
            labels: vLabels
          } = _V;
          if (vLabels && options.labelsLayer) {
            vLabels.remove();
          }
        },
        findLabelNodes: function(labelIndex, selector) {
          const labelRoot = this._labelCache[labelIndex];
          if (!labelRoot) return [];
          const labelSelectors = this._labelSelectors[labelIndex];
          return this.findBySelector(selector, labelRoot, labelSelectors);
        },
        findLabelNode: function(labelIndex, selector) {
          const [node = null] = this.findLabelNodes(labelIndex, selector);
          return node;
        },
        // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)
        // keep `undefined` or `null` because `{}` means something else
        _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {
          if (labelAttrs === null) return null;
          if (labelAttrs === void 0) {
            if (defaultLabelAttrs === null) return null;
            if (defaultLabelAttrs === void 0) {
              if (hasCustomMarkup) return void 0;
              return builtinDefaultLabelAttrs;
            }
            if (hasCustomMarkup) return defaultLabelAttrs;
            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);
          }
          if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);
          return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);
        },
        // merge default label size into label size (no built-in default)
        // keep `undefined` or `null` because `{}` means something else
        _mergeLabelSize: function(labelSize, defaultLabelSize) {
          if (labelSize === null) return null;
          if (labelSize === void 0) {
            if (defaultLabelSize === null) return null;
            if (defaultLabelSize === void 0) return void 0;
            return defaultLabelSize;
          }
          return merge({}, defaultLabelSize, labelSize);
        },
        updateLabels: function() {
          if (!this._V.labels) return this;
          if (!this.paper.options.labelLayer) {
            this.cleanNodeCache(this.el);
          }
          var model = this.model;
          var labels = model.get("labels") || [];
          var canLabelMove = this.can("labelMove");
          var builtinDefaultLabel = model._builtins.defaultLabel;
          var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;
          var defaultLabel = model._getDefaultLabel();
          var defaultLabelMarkup = defaultLabel.markup;
          var defaultLabelAttrs = defaultLabel.attrs;
          var defaultLabelSize = defaultLabel.size;
          for (var i = 0, n = labels.length; i < n; i++) {
            var labelNode = this._labelCache[i];
            labelNode.setAttribute("cursor", canLabelMove ? "move" : "default");
            var selectors = this._labelSelectors[i];
            var label = labels[i];
            var labelMarkup2 = label.markup;
            var labelAttrs = label.attrs;
            var labelSize = label.size;
            var attrs = this._mergeLabelAttrs(labelMarkup2 || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);
            var size = this._mergeLabelSize(labelSize, defaultLabelSize);
            this.updateDOMSubtreeAttributes(labelNode, attrs, {
              rootBBox: new Rect(size),
              selectors
            });
          }
          return this;
        },
        // remove vertices that lie on (or nearly on) straight lines within the link
        // return the number of removed points
        removeRedundantLinearVertices: function(opt) {
          const SIMPLIFY_THRESHOLD = 1e-3;
          const link = this.model;
          const vertices = link.vertices();
          const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];
          const numRoutePoints = routePoints.length;
          const polyline = new Polyline$1(routePoints);
          polyline.simplify({
            threshold: SIMPLIFY_THRESHOLD
          });
          const polylinePoints = polyline.points.map((point2) => point2.toJSON());
          const numPolylinePoints = polylinePoints.length;
          if (numRoutePoints === numPolylinePoints) return 0;
          link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);
          return numRoutePoints - numPolylinePoints;
        },
        getEndView: function(type) {
          switch (type) {
            case "source":
              return this.sourceView || null;
            case "target":
              return this.targetView || null;
            default:
              throw new Error("dia.LinkView: type parameter required.");
          }
        },
        getEndAnchor: function(type) {
          switch (type) {
            case "source":
              return new Point(this.sourceAnchor);
            case "target":
              return new Point(this.targetAnchor);
            default:
              throw new Error("dia.LinkView: type parameter required.");
          }
        },
        getEndConnectionPoint: function(type) {
          switch (type) {
            case "source":
              return new Point(this.sourcePoint);
            case "target":
              return new Point(this.targetPoint);
            default:
              throw new Error("dia.LinkView: type parameter required.");
          }
        },
        getEndMagnet: function(type) {
          switch (type) {
            case "source":
              var sourceView = this.sourceView;
              if (!sourceView) break;
              return this.sourceMagnet || sourceView.el;
            case "target":
              var targetView = this.targetView;
              if (!targetView) break;
              return this.targetMagnet || targetView.el;
            default:
              throw new Error("dia.LinkView: type parameter required.");
          }
          return null;
        },
        // Updating.
        // ---------
        update: function() {
          this.updateRoute();
          this.updatePath();
          this.updateDOM();
          return this;
        },
        translate: function(tx = 0, ty = 0) {
          const {
            route,
            path: path2
          } = this;
          if (!route || !path2) return;
          const polyline = new Polyline$1(route);
          polyline.translate(tx, ty);
          this.route = polyline.points;
          this.sourcePoint.offset(tx, ty);
          this.targetPoint.offset(tx, ty);
          this.sourceAnchor.offset(tx, ty);
          this.targetAnchor.offset(tx, ty);
          path2.translate(tx, ty);
          this.updateDOM();
        },
        updateDOM() {
          const {
            el,
            model,
            selectors
          } = this;
          this.cleanNodesCache();
          this.updateDOMSubtreeAttributes(el, model.attr(), {
            selectors
          });
          this.updateLabelPositions();
          this.options.perpendicular = null;
        },
        updateRoute: function() {
          const {
            model
          } = this;
          const vertices = model.vertices();
          const anchors2 = this.findAnchors(vertices);
          const sourceAnchor = this.sourceAnchor = anchors2.source;
          const targetAnchor = this.targetAnchor = anchors2.target;
          const route = this.findRoute(vertices);
          this.route = route;
          var connectionPoints2 = this.findConnectionPoints(route, sourceAnchor, targetAnchor);
          this.sourcePoint = connectionPoints2.source;
          this.targetPoint = connectionPoints2.target;
        },
        updatePath: function() {
          const {
            route,
            sourcePoint,
            targetPoint
          } = this;
          const path2 = this.findPath(route, sourcePoint.clone(), targetPoint.clone());
          this.path = path2;
        },
        findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {
          var firstAnchor, secondAnchor;
          var firstAnchorRef, secondAnchorRef;
          var model = this.model;
          var firstDef = model.get(firstEndType);
          var secondDef = model.get(secondEndType);
          var firstView = this.getEndView(firstEndType);
          var secondView = this.getEndView(secondEndType);
          var firstMagnet = this.getEndMagnet(firstEndType);
          var secondMagnet = this.getEndMagnet(secondEndType);
          if (firstView) {
            if (firstRef) {
              firstAnchorRef = new Point(firstRef);
            } else if (secondView) {
              firstAnchorRef = secondMagnet;
            } else {
              firstAnchorRef = new Point(secondDef);
            }
            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);
          } else {
            firstAnchor = new Point(firstDef);
          }
          if (secondView) {
            secondAnchorRef = new Point(secondRef || firstAnchor);
            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);
          } else {
            secondAnchor = new Point(secondDef);
          }
          var res = {};
          res[firstEndType] = firstAnchor;
          res[secondEndType] = secondAnchor;
          return res;
        },
        findAnchors: function(vertices) {
          var model = this.model;
          var firstVertex = vertices[0];
          var lastVertex = vertices[vertices.length - 1];
          if (model.target().priority && !model.source().priority) {
            return this.findAnchorsOrdered("target", lastVertex, "source", firstVertex);
          }
          return this.findAnchorsOrdered("source", firstVertex, "target", lastVertex);
        },
        findConnectionPoints: function(route, sourceAnchor, targetAnchor) {
          var firstWaypoint = route[0];
          var lastWaypoint = route[route.length - 1];
          var model = this.model;
          var sourceDef = model.get("source");
          var targetDef = model.get("target");
          var sourceView = this.sourceView;
          var targetView = this.targetView;
          var paperOptions = this.paper.options;
          var sourceMagnet, targetMagnet;
          var sourcePoint;
          if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {
            sourceMagnet = this.sourceMagnet || sourceView.el;
            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var sourcePointRef = firstWaypoint || targetAnchor;
            var sourceLine = new Line(sourcePointRef, sourceAnchor);
            sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, "source");
          } else {
            sourcePoint = sourceAnchor;
          }
          var targetPoint;
          if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {
            targetMagnet = this.targetMagnet || targetView.el;
            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;
            var targetPointRef = lastWaypoint || sourceAnchor;
            var targetLine = new Line(targetPointRef, targetAnchor);
            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, "target");
          } else {
            targetPoint = targetAnchor;
          }
          return {
            source: sourcePoint,
            target: targetPoint
          };
        },
        getAnchor: function(anchorDef, cellView, magnet, ref, endType) {
          var isConnection = cellView.isNodeConnection(magnet);
          var paperOptions = this.paper.options;
          if (!anchorDef) {
            if (isConnection) {
              anchorDef = paperOptions.defaultLinkAnchor;
            } else {
              if (this.options.perpendicular) {
                anchorDef = {
                  name: "perpendicular"
                };
              } else {
                anchorDef = paperOptions.defaultAnchor;
              }
            }
          }
          if (!anchorDef) throw new Error("Anchor required.");
          var anchorFn;
          if (typeof anchorDef === "function") {
            anchorFn = anchorDef;
          } else {
            var anchorName = anchorDef.name;
            var anchorNamespace = isConnection ? "linkAnchorNamespace" : "anchorNamespace";
            anchorFn = paperOptions[anchorNamespace][anchorName];
            if (typeof anchorFn !== "function") throw new Error("Unknown anchor: " + anchorName);
          }
          var anchor2 = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);
          if (!anchor2) return new Point();
          return anchor2.round(this.decimalsRounding);
        },
        getConnectionPoint: function(connectionPointDef, view, magnet, line2, endType) {
          var connectionPoint;
          var anchor2 = line2.end;
          var paperOptions = this.paper.options;
          if (!connectionPointDef) return anchor2;
          var connectionPointFn;
          if (typeof connectionPointDef === "function") {
            connectionPointFn = connectionPointDef;
          } else {
            var connectionPointName = connectionPointDef.name;
            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];
            if (typeof connectionPointFn !== "function") throw new Error("Unknown connection point: " + connectionPointName);
          }
          connectionPoint = connectionPointFn.call(this, line2, view, magnet, connectionPointDef.args || {}, endType, this);
          if (!connectionPoint) return anchor2;
          return connectionPoint.round(this.decimalsRounding);
        },
        isIntersecting: function(geometryShape, geometryData) {
          const connection = this.getConnection();
          if (!connection) return false;
          return intersection$1.exists(geometryShape, connection, geometryData, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        isEnclosedIn: function(geometryRect) {
          const connection = this.getConnection();
          if (!connection) return false;
          const bbox2 = connection.bbox();
          if (!bbox2) return false;
          return geometryRect.containsRect(bbox2);
        },
        isAtPoint: function(point2) {
          const area = new Rect(point2);
          area.inflate(this.EPSILON);
          return this.isIntersecting(area);
        },
        // combine default label position with built-in default label position
        _getDefaultLabelPositionProperty: function() {
          var model = this.model;
          var builtinDefaultLabel = model._builtins.defaultLabel;
          var builtinDefaultLabelPosition = builtinDefaultLabel.position;
          var defaultLabel = model._getDefaultLabel();
          var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);
          return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);
        },
        // if label position is a number, normalize it to a position object
        // this makes sure that label positions can be merged properly
        _normalizeLabelPosition: function(labelPosition) {
          if (typeof labelPosition === "number") return {
            distance: labelPosition,
            offset: null,
            angle: 0,
            args: null
          };
          return labelPosition;
        },
        // expects normalized position properties
        // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`
        _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {
          if (normalizedLabelPosition === null) return null;
          if (normalizedLabelPosition === void 0) {
            if (normalizedDefaultLabelPosition === null) return null;
            return normalizedDefaultLabelPosition;
          }
          return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);
        },
        updateLabelPositions: function() {
          if (!this._V.labels) return this;
          var path2 = this.path;
          if (!path2) return this;
          var model = this.model;
          var labels = model.get("labels") || [];
          if (!labels.length) return this;
          var defaultLabelPosition = this._getDefaultLabelPositionProperty();
          for (var idx = 0, n = labels.length; idx < n; idx++) {
            var labelNode = this._labelCache[idx];
            if (!labelNode) continue;
            var label = labels[idx];
            var labelPosition = this._normalizeLabelPosition(label.position);
            var position2 = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);
            var transformationMatrix = this._getLabelTransformationMatrix(position2);
            labelNode.setAttribute("transform", V2.matrixToTransformString(transformationMatrix));
            this._cleanLabelMatrices(idx);
          }
          return this;
        },
        _cleanLabelMatrices: function(index2) {
          const {
            metrics,
            _labelSelectors
          } = this;
          const selectors = _labelSelectors[index2];
          if (!selectors) return;
          for (let selector in selectors) {
            const {
              id: id2
            } = selectors[selector];
            if (id2 && id2 in metrics) delete metrics[id2].magnetMatrix;
          }
        },
        checkEndModel: function(endType, endId) {
          if (!endId) return;
          const endModel = this.paper.getModelById(endId);
          if (!endModel) {
            throw new Error(`LinkView: invalid ${endType} cell.`);
          }
        },
        _getLabelPositionProperty: function(idx) {
          return this.model.label(idx).position || {};
        },
        _getLabelPositionAngle: function(idx) {
          var labelPosition = this._getLabelPositionProperty(idx);
          return labelPosition.angle || 0;
        },
        _getLabelPositionArgs: function(idx) {
          var labelPosition = this._getLabelPositionProperty(idx);
          return labelPosition.args;
        },
        _getDefaultLabelPositionArgs: function() {
          var defaultLabel = this.model._getDefaultLabel();
          var defaultLabelPosition = defaultLabel.position || {};
          return defaultLabelPosition.args;
        },
        // merge default label position args into label position args
        // keep `undefined` or `null` because `{}` means something else
        _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {
          if (labelPositionArgs === null) return null;
          if (labelPositionArgs === void 0) {
            if (defaultLabelPositionArgs === null) return null;
            return defaultLabelPositionArgs;
          }
          return merge({}, defaultLabelPositionArgs, labelPositionArgs);
        },
        // Add default label at given position at end of `labels` array.
        // Four signatures:
        // - obj, obj = point, opt
        // - obj, num, obj = point, angle, opt
        // - num, num, obj = x, y, opt
        // - num, num, num, obj = x, y, angle, opt
        // Assigns relative coordinates by default:
        // `opt.absoluteDistance` forces absolute coordinates.
        // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).
        // `opt.absoluteOffset` forces absolute coordinates for offset.
        // Additional args:
        // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.
        // `opt.ensureLegibility` rotates labels so they are never upside-down.
        addLabel: function(p1, p2, p3, p4) {
          var localX;
          var localY;
          var localAngle = 0;
          var localOpt;
          if (typeof p1 !== "number") {
            localX = p1.x;
            localY = p1.y;
            if (typeof p2 === "number") {
              localAngle = p2;
              localOpt = p3;
            } else {
              localOpt = p2;
            }
          } else {
            localX = p1;
            localY = p2;
            if (typeof p3 === "number") {
              localAngle = p3;
              localOpt = p4;
            } else {
              localOpt = p3;
            }
          }
          var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
          var labelPositionArgs = localOpt;
          var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
          var label = {
            position: this.getLabelPosition(localX, localY, localAngle, positionArgs)
          };
          var idx = -1;
          this.model.insertLabel(idx, label, localOpt);
          return idx;
        },
        // Add a new vertex at calculated index to the `vertices` array.
        addVertex: function(x, y, opt) {
          var isPointProvided = typeof x !== "number";
          var localX = isPointProvided ? x.x : x;
          var localY = isPointProvided ? x.y : y;
          var localOpt = isPointProvided ? y : opt;
          var vertex = {
            x: localX,
            y: localY
          };
          var idx = this.getVertexIndex(localX, localY);
          this.model.insertVertex(idx, vertex, localOpt);
          return idx;
        },
        // Send a token (an SVG element, usually a circle) along the connection path.
        // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`
        // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.
        // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)
        // `opt.connection` is an optional selector to the connection path.
        // `callback` is optional and is a function to be called once the token reaches the target.
        sendToken: function(token, opt, callback) {
          function onAnimationEnd(vToken2, callback2) {
            return function() {
              vToken2.remove();
              if (typeof callback2 === "function") {
                callback2();
              }
            };
          }
          var duration, isReversed, selector;
          if (isObject(opt)) {
            duration = opt.duration;
            isReversed = opt.direction === "reverse";
            selector = opt.connection;
          } else {
            duration = opt;
            isReversed = false;
            selector = null;
          }
          duration = duration || 1e3;
          var animationAttributes = {
            dur: duration + "ms",
            repeatCount: 1,
            calcMode: "linear",
            fill: "freeze"
          };
          if (isReversed) {
            animationAttributes.keyPoints = "1;0";
            animationAttributes.keyTimes = "0;1";
          }
          var vToken = V2(token);
          var connection;
          if (typeof selector === "string") {
            connection = this.findNode(selector);
          } else {
            var cache2 = this._V;
            connection = cache2.connection ? cache2.connection.node : this.el.querySelector("path");
          }
          if (!(connection instanceof SVGPathElement)) {
            throw new Error("dia.LinkView: token animation requires a valid connection path.");
          }
          vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);
          setTimeout(onAnimationEnd(vToken, callback), duration);
        },
        findRoute: function(vertices) {
          vertices || (vertices = []);
          var namespace = this.paper.options.routerNamespace || routers;
          var router2 = this.model.router();
          var defaultRouter = this.paper.options.defaultRouter;
          if (!router2) {
            if (defaultRouter) router2 = defaultRouter;
            else return vertices.map(Point);
          }
          var routerFn = isFunction(router2) ? router2 : namespace[router2.name];
          if (!isFunction(routerFn)) {
            throw new Error('dia.LinkView: unknown router: "' + router2.name + '".');
          }
          var args = router2.args || {};
          var route = routerFn.call(
            this,
            // context
            vertices,
            // vertices
            args,
            // options
            this
            // linkView
          );
          if (!route) return vertices.map(Point);
          return route;
        },
        // Return the `d` attribute value of the `<path>` element representing the link
        // between `source` and `target`.
        findPath: function(route, sourcePoint, targetPoint) {
          var namespace = this.paper.options.connectorNamespace || connectors;
          var connector = this.model.connector();
          var defaultConnector = this.paper.options.defaultConnector;
          if (!connector) {
            connector = defaultConnector || {};
          }
          var connectorFn = isFunction(connector) ? connector : namespace[connector.name];
          if (!isFunction(connectorFn)) {
            throw new Error('dia.LinkView: unknown connector: "' + connector.name + '".');
          }
          var args = clone$1(connector.args || {});
          args.raw = true;
          var path2 = connectorFn.call(
            this,
            // context
            sourcePoint,
            // start point
            targetPoint,
            // end point
            route,
            // vertices
            args,
            // options
            this
            // linkView
          );
          if (typeof path2 === "string") {
            path2 = new Path$1(V2.normalizePathData(path2));
          }
          return path2;
        },
        // Public API.
        // -----------
        getConnection: function() {
          var path2 = this.path;
          if (!path2) return null;
          return path2.clone();
        },
        getSerializedConnection: function() {
          var path2 = this.path;
          if (!path2) return null;
          var metrics = this.metrics;
          if (metrics.hasOwnProperty("data")) return metrics.data;
          var data2 = path2.serialize();
          metrics.data = data2;
          return data2;
        },
        getConnectionSubdivisions: function() {
          var path2 = this.path;
          if (!path2) return null;
          var metrics = this.metrics;
          if (metrics.hasOwnProperty("segmentSubdivisions")) return metrics.segmentSubdivisions;
          var subdivisions = path2.getSegmentSubdivisions();
          metrics.segmentSubdivisions = subdivisions;
          return subdivisions;
        },
        getConnectionLength: function() {
          var path2 = this.path;
          if (!path2) return 0;
          var metrics = this.metrics;
          if (metrics.hasOwnProperty("length")) return metrics.length;
          var length2 = path2.length({
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
          metrics.length = length2;
          return length2;
        },
        getPointAtLength: function(length2) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.pointAtLength(length2, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getPointAtRatio: function(ratio) {
          var path2 = this.path;
          if (!path2) return null;
          if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;
          return path2.pointAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getTangentAtLength: function(length2) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.tangentAtLength(length2, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getTangentAtRatio: function(ratio) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.tangentAt(ratio, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getClosestPoint: function(point2) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.closestPoint(point2, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getClosestPointLength: function(point2) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.closestPointLength(point2, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        getClosestPointRatio: function(point2) {
          var path2 = this.path;
          if (!path2) return null;
          return path2.closestPointNormalizedLength(point2, {
            segmentSubdivisions: this.getConnectionSubdivisions()
          });
        },
        // Get label position object based on two provided coordinates, x and y.
        // (Used behind the scenes when user moves labels around.)
        // Two signatures:
        // - num, num, obj = x, y, options
        // - num, num, num, obj = x, y, angle, options
        // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`
        // - `absoluteOffset` is necessary in order to move beyond connection endpoints
        // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`
        getLabelPosition: function(x, y, p3, p4) {
          var position2 = {};
          var localAngle = 0;
          var localOpt;
          if (typeof p3 === "number") {
            localAngle = p3;
            localOpt = p4;
          } else {
            localOpt = p3;
          }
          if (localOpt) position2.args = localOpt;
          var isDistanceRelative = !(localOpt && localOpt.absoluteDistance);
          var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance;
          var isOffsetAbsolute = localOpt && localOpt.absoluteOffset;
          var path2 = this.path;
          var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
          };
          var labelPoint = new Point(x, y);
          var t = path2.closestPointT(labelPoint, pathOpt);
          var labelDistance = path2.lengthAtT(t, pathOpt);
          if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0;
          if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1;
          position2.distance = labelDistance;
          var tangent;
          if (!isOffsetAbsolute) tangent = path2.tangentAtT(t);
          var labelOffset;
          if (tangent) {
            labelOffset = tangent.pointOffset(labelPoint);
          } else {
            var closestPoint = path2.pointAtT(t);
            var labelOffsetDiff = labelPoint.difference(closestPoint);
            labelOffset = {
              x: labelOffsetDiff.x,
              y: labelOffsetDiff.y
            };
          }
          position2.offset = labelOffset;
          position2.angle = localAngle;
          return position2;
        },
        _getLabelTransformationMatrix: function(labelPosition) {
          var labelDistance;
          var labelAngle = 0;
          var args = {};
          if (typeof labelPosition === "number") {
            labelDistance = labelPosition;
          } else if (typeof labelPosition.distance === "number") {
            args = labelPosition.args || {};
            labelDistance = labelPosition.distance;
            labelAngle = labelPosition.angle || 0;
          } else {
            throw new Error("dia.LinkView: invalid label position distance.");
          }
          var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;
          var labelOffset = 0;
          var labelOffsetCoordinates = {
            x: 0,
            y: 0
          };
          if (labelPosition.offset) {
            var positionOffset = labelPosition.offset;
            if (typeof positionOffset === "number") labelOffset = positionOffset;
            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;
            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;
          }
          var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;
          var isKeepGradient = args.keepGradient;
          var isEnsureLegibility = args.ensureLegibility;
          var path2 = this.path;
          var pathOpt = {
            segmentSubdivisions: this.getConnectionSubdivisions()
          };
          var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;
          var tangent = path2.tangentAtLength(distance, pathOpt);
          var translation;
          var angle = labelAngle;
          if (tangent) {
            if (isOffsetAbsolute) {
              translation = tangent.start.clone();
              translation.offset(labelOffsetCoordinates);
            } else {
              var normal2 = tangent.clone();
              normal2.rotate(tangent.start, -90);
              normal2.setLength(labelOffset);
              translation = normal2.end;
            }
            if (isKeepGradient) {
              angle = tangent.angle() + labelAngle;
              if (isEnsureLegibility) {
                angle = normalizeAngle((angle + 90) % 180 - 90);
              }
            }
          } else {
            translation = path2.start.clone();
            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);
          }
          return V2.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);
        },
        getLabelCoordinates: function(labelPosition) {
          var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);
          return new Point(transformationMatrix.e, transformationMatrix.f);
        },
        getVertexIndex: function(x, y) {
          var model = this.model;
          var vertices = model.vertices();
          var vertexLength = this.getClosestPointLength(new Point(x, y));
          var idx = 0;
          for (var n = vertices.length; idx < n; idx++) {
            var currentVertex = vertices[idx];
            var currentVertexLength = this.getClosestPointLength(currentVertex);
            if (vertexLength < currentVertexLength) break;
          }
          return idx;
        },
        // Interaction. The controller part.
        // ---------------------------------
        notifyPointerdown(evt, x, y) {
          CellView.prototype.pointerdown.call(this, evt, x, y);
          this.notify("link:pointerdown", evt, x, y);
        },
        notifyPointermove(evt, x, y) {
          CellView.prototype.pointermove.call(this, evt, x, y);
          this.notify("link:pointermove", evt, x, y);
        },
        notifyPointerup(evt, x, y) {
          this.notify("link:pointerup", evt, x, y);
          CellView.prototype.pointerup.call(this, evt, x, y);
        },
        pointerdblclick: function(evt, x, y) {
          CellView.prototype.pointerdblclick.apply(this, arguments);
          this.notify("link:pointerdblclick", evt, x, y);
        },
        pointerclick: function(evt, x, y) {
          CellView.prototype.pointerclick.apply(this, arguments);
          this.notify("link:pointerclick", evt, x, y);
        },
        contextmenu: function(evt, x, y) {
          CellView.prototype.contextmenu.apply(this, arguments);
          this.notify("link:contextmenu", evt, x, y);
        },
        pointerdown: function(evt, x, y) {
          this.notifyPointerdown(evt, x, y);
          this.dragStart(evt, x, y);
        },
        pointermove: function(evt, x, y) {
          var dragData = this._dragData;
          if (dragData) this.eventData(evt, dragData);
          var data2 = this.eventData(evt);
          switch (data2.action) {
            case "label-move":
              this.dragLabel(evt, x, y);
              break;
            case "arrowhead-move":
              this.dragArrowhead(evt, x, y);
              break;
            case "move":
              this.drag(evt, x, y);
              break;
          }
          if (dragData) assign(dragData, this.eventData(evt));
          this.notifyPointermove(evt, x, y);
        },
        pointerup: function(evt, x, y) {
          var dragData = this._dragData;
          if (dragData) {
            this.eventData(evt, dragData);
            this._dragData = null;
          }
          var data2 = this.eventData(evt);
          switch (data2.action) {
            case "label-move":
              this.dragLabelEnd(evt, x, y);
              break;
            case "arrowhead-move":
              this.dragArrowheadEnd(evt, x, y);
              break;
            case "move":
              this.dragEnd(evt, x, y);
          }
          this.notifyPointerup(evt, x, y);
          this.checkMouseleave(evt);
        },
        mouseover: function(evt) {
          CellView.prototype.mouseover.apply(this, arguments);
          this.notify("link:mouseover", evt);
        },
        mouseout: function(evt) {
          CellView.prototype.mouseout.apply(this, arguments);
          this.notify("link:mouseout", evt);
        },
        mouseenter: function(evt) {
          CellView.prototype.mouseenter.apply(this, arguments);
          this.notify("link:mouseenter", evt);
        },
        mouseleave: function(evt) {
          CellView.prototype.mouseleave.apply(this, arguments);
          this.notify("link:mouseleave", evt);
        },
        mousewheel: function(evt, x, y, delta) {
          CellView.prototype.mousewheel.apply(this, arguments);
          this.notify("link:mousewheel", evt, x, y, delta);
        },
        onlabel: function(evt, x, y) {
          this.notifyPointerdown(evt, x, y);
          this.dragLabelStart(evt, x, y);
          var stopPropagation = this.eventData(evt).stopPropagation;
          if (stopPropagation) evt.stopPropagation();
        },
        // Drag Start Handlers
        dragLabelStart: function(evt, x, y) {
          if (this.can("labelMove")) {
            if (this.isDefaultInteractionPrevented(evt)) return;
            var labelNode = evt.currentTarget;
            var labelIdx = parseInt(labelNode.getAttribute("label-idx"), 10);
            var defaultLabelPosition = this._getDefaultLabelPositionProperty();
            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));
            var position2 = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);
            var coords = this.getLabelCoordinates(position2);
            var dx = coords.x - x;
            var dy = coords.y - y;
            var positionAngle = this._getLabelPositionAngle(labelIdx);
            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);
            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();
            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);
            this.eventData(evt, {
              action: "label-move",
              labelIdx,
              dx,
              dy,
              positionAngle,
              positionArgs,
              stopPropagation: true
            });
          } else {
            this.eventData(evt, {
              stopPropagation: true
            });
          }
          this.paper.delegateDragEvents(this, evt.data);
        },
        dragArrowheadStart: function(evt, x, y) {
          if (!this.can("arrowheadMove")) return;
          var arrowheadNode = evt.target;
          var arrowheadType = arrowheadNode.getAttribute("end");
          var data2 = this.startArrowheadMove(arrowheadType, {
            ignoreBackwardsCompatibility: true
          });
          this.eventData(evt, data2);
        },
        dragStart: function(evt, x, y) {
          if (this.isDefaultInteractionPrevented(evt)) return;
          if (!this.can("linkMove")) return;
          this.eventData(evt, {
            action: "move",
            dx: x,
            dy: y
          });
        },
        // Drag Handlers
        dragLabel: function(evt, x, y) {
          var data2 = this.eventData(evt);
          var label = {
            position: this.getLabelPosition(x + data2.dx, y + data2.dy, data2.positionAngle, data2.positionArgs)
          };
          if (this.paper.options.snapLabels) delete label.position.offset;
          const setOptions2 = {
            ui: true
          };
          if (this.paper.isAsync() && evt.type === "touchmove") {
            setOptions2.async = false;
          }
          this.model.label(data2.labelIdx, label, setOptions2);
        },
        dragArrowhead: function(evt, x, y) {
          if (this.paper.options.snapLinks) {
            const isSnapped = this._snapArrowhead(evt, x, y);
            if (!isSnapped && this.paper.options.snapLinksSelf) {
              this._snapArrowheadSelf(evt, x, y);
            }
          } else {
            if (this.paper.options.snapLinksSelf) {
              this._snapArrowheadSelf(evt, x, y);
            } else {
              this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));
            }
          }
        },
        drag: function(evt, x, y) {
          var data2 = this.eventData(evt);
          this.model.translate(x - data2.dx, y - data2.dy, {
            ui: true
          });
          this.eventData(evt, {
            dx: x,
            dy: y
          });
        },
        // Drag End Handlers
        dragLabelEnd: function() {
        },
        dragArrowheadEnd: function(evt, x, y) {
          var data2 = this.eventData(evt);
          var paper = this.paper;
          if (paper.options.snapLinks) {
            this._snapArrowheadEnd(data2);
          } else {
            this._connectArrowheadEnd(data2, x, y);
          }
          if (!paper.linkAllowed(this)) {
            this._disallow(data2);
          } else {
            this._finishEmbedding(data2);
            this._notifyConnectEvent(data2, evt);
          }
          this._afterArrowheadMove(data2);
        },
        dragEnd: function() {
        },
        _disallow: function(data2) {
          switch (data2.whenNotAllowed) {
            case "remove":
              this.model.remove({
                ui: true
              });
              break;
            case "revert":
            default:
              this.model.set(data2.arrowhead, data2.initialEnd, {
                ui: true
              });
              break;
          }
        },
        _finishEmbedding: function(data2) {
          if (this.paper.options.embeddingMode && this.model.reparent()) {
            data2.z = null;
          }
        },
        _notifyConnectEvent: function(data2, evt) {
          var arrowhead = data2.arrowhead;
          var initialEnd = data2.initialEnd;
          var currentEnd = this.model.prop(arrowhead);
          var endChanged = currentEnd && !Link$1.endsEqual(initialEnd, currentEnd);
          if (endChanged) {
            var paper = this.paper;
            if (initialEnd.id) {
              this.notify("link:disconnect", evt, paper.findViewByModel(initialEnd.id), data2.initialMagnet, arrowhead);
            }
            if (currentEnd.id) {
              this.notify("link:connect", evt, paper.findViewByModel(currentEnd.id), data2.magnetUnderPointer, arrowhead);
            }
          }
        },
        _snapToPoints: function(snapPoint, points, radius) {
          let closestPointX = null;
          let closestDistanceX = Infinity;
          let closestPointY = null;
          let closestDistanceY = Infinity;
          let x = snapPoint.x;
          let y = snapPoint.y;
          for (let i = 0; i < points.length; i++) {
            const distX = Math.abs(points[i].x - snapPoint.x);
            if (distX < closestDistanceX) {
              closestDistanceX = distX;
              closestPointX = points[i];
            }
            const distY = Math.abs(points[i].y - snapPoint.y);
            if (distY < closestDistanceY) {
              closestDistanceY = distY;
              closestPointY = points[i];
            }
          }
          if (closestDistanceX < radius) {
            x = closestPointX.x;
          }
          if (closestDistanceY < radius) {
            y = closestPointY.y;
          }
          return {
            x,
            y
          };
        },
        _snapArrowheadSelf: function(evt, x, y) {
          const {
            paper,
            model
          } = this;
          const {
            snapLinksSelf
          } = paper.options;
          const data2 = this.eventData(evt);
          const radius = snapLinksSelf.radius || 20;
          const anchor2 = this.getEndAnchor(data2.arrowhead === "source" ? "target" : "source");
          const vertices = model.vertices();
          const points = [anchor2, ...vertices];
          const snapPoint = this._snapToPoints({
            x,
            y
          }, points, radius);
          const point2 = paper.localToClientPoint(snapPoint);
          this._connectArrowhead(document.elementFromPoint(point2.x, point2.y), snapPoint.x, snapPoint.y, this.eventData(evt));
        },
        _snapArrowhead: function(evt, x, y) {
          const {
            paper
          } = this;
          const {
            snapLinks,
            connectionStrategy
          } = paper.options;
          const data2 = this.eventData(evt);
          let isSnapped = false;
          const radius = snapLinks.radius || 50;
          const findInAreaOptions = snapLinks.findInAreaOptions;
          const prevClosestView = data2.closestView || null;
          const prevClosestMagnet = data2.closestMagnet || null;
          const prevMagnetProxy = data2.magnetProxy || null;
          data2.closestView = data2.closestMagnet = data2.magnetProxy = null;
          const isValidCandidate = (view, magnet) => {
            if (view === this) {
              return false;
            }
            const isAlreadyValidated = prevClosestMagnet === magnet;
            return isAlreadyValidated || paper.options.validateConnection.apply(paper, data2.validateConnectionArgs(view, view.el === magnet ? null : magnet));
          };
          const closest2 = paper.findClosestMagnetToPoint({
            x,
            y
          }, {
            radius,
            findInAreaOptions,
            filter: isValidCandidate
          });
          data2.closestView = closest2 ? closest2.view : null;
          data2.closestMagnet = closest2 ? closest2.magnet : null;
          var end;
          var magnetProxy = null;
          var closestView = data2.closestView;
          var closestMagnet = data2.closestMagnet;
          if (closestMagnet) {
            magnetProxy = data2.magnetProxy = closestView.findProxyNode(closestMagnet, "highlighter");
          }
          var endType = data2.arrowhead;
          var newClosestMagnet = prevClosestMagnet !== closestMagnet;
          if (prevClosestView && newClosestMagnet) {
            prevClosestView.unhighlight(prevMagnetProxy, {
              connecting: true,
              snapping: true
            });
          }
          if (closestView) {
            const {
              prevEnd,
              prevX,
              prevY
            } = data2;
            data2.prevX = x;
            data2.prevY = y;
            isSnapped = true;
            if (!newClosestMagnet) {
              if (typeof connectionStrategy !== "function" || prevX === x && prevY === y) {
                return isSnapped;
              }
            }
            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);
            if (!newClosestMagnet && isEqual(prevEnd, end)) {
              return isSnapped;
            }
            data2.prevEnd = end;
            if (newClosestMagnet) {
              closestView.highlight(magnetProxy, {
                connecting: true,
                snapping: true
              });
            }
          } else {
            end = {
              x,
              y
            };
          }
          this.model.set(endType, end || {
            x,
            y
          }, {
            ui: true
          });
          if (prevClosestView) {
            this.notify("link:snap:disconnect", evt, prevClosestView, prevClosestMagnet, endType);
          }
          if (closestView) {
            this.notify("link:snap:connect", evt, closestView, closestMagnet, endType);
          }
          return isSnapped;
        },
        _snapArrowheadEnd: function(data2) {
          var closestView = data2.closestView;
          var closestMagnet = data2.closestMagnet;
          if (closestView && closestMagnet) {
            closestView.unhighlight(data2.magnetProxy, {
              connecting: true,
              snapping: true
            });
            data2.magnetUnderPointer = closestView.findMagnet(closestMagnet);
          }
          data2.closestView = data2.closestMagnet = null;
        },
        _connectArrowhead: function(target, x, y, data2) {
          const {
            paper,
            model
          } = this;
          if (data2.eventTarget !== target) {
            if (data2.magnetProxy) {
              data2.viewUnderPointer.unhighlight(data2.magnetProxy, {
                connecting: true
              });
            }
            const viewUnderPointer = data2.viewUnderPointer = paper.findView(target);
            if (viewUnderPointer) {
              const magnetUnderPointer = data2.magnetUnderPointer = viewUnderPointer.findMagnet(target);
              const magnetProxy = data2.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, "highlighter");
              if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data2.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {
                if (magnetProxy) {
                  viewUnderPointer.highlight(magnetProxy, {
                    connecting: true
                  });
                }
              } else {
                data2.magnetUnderPointer = null;
                data2.magnetProxy = null;
              }
            } else {
              data2.magnetUnderPointer = null;
              data2.magnetProxy = null;
            }
          }
          data2.eventTarget = target;
          model.set(data2.arrowhead, {
            x,
            y
          }, {
            ui: true
          });
        },
        _connectArrowheadEnd: function(data2 = {}, x, y) {
          const {
            model
          } = this;
          const {
            viewUnderPointer,
            magnetUnderPointer,
            magnetProxy,
            arrowhead
          } = data2;
          if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;
          viewUnderPointer.unhighlight(magnetProxy, {
            connecting: true
          });
          const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);
          model.set(arrowhead, end, {
            ui: true
          });
        },
        _beforeArrowheadMove: function(data2) {
          data2.z = this.model.get("z");
          this.model.toFront();
          var style = this.el.style;
          data2.pointerEvents = style.pointerEvents;
          style.pointerEvents = "none";
          if (this.paper.options.markAvailable) {
            this._markAvailableMagnets(data2);
          }
        },
        _afterArrowheadMove: function(data2) {
          if (data2.z !== null) {
            this.model.set("z", data2.z, {
              ui: true
            });
            data2.z = null;
          }
          this.el.style.pointerEvents = data2.pointerEvents;
          if (this.paper.options.markAvailable) {
            this._unmarkAvailableMagnets(data2);
          }
        },
        _createValidateConnectionArgs: function(arrowhead) {
          var args = [];
          args[4] = arrowhead;
          args[5] = this;
          var oppositeArrowhead;
          var i = 0;
          var j = 0;
          if (arrowhead === "source") {
            i = 2;
            oppositeArrowhead = "target";
          } else {
            j = 2;
            oppositeArrowhead = "source";
          }
          var end = this.model.get(oppositeArrowhead);
          if (end.id) {
            var view = args[i] = this.paper.findViewByModel(end.id);
            var magnet = view.getMagnetFromLinkEnd(end);
            if (magnet === view.el) magnet = void 0;
            args[i + 1] = magnet;
          }
          function validateConnectionArgs(cellView, magnet2) {
            args[j] = cellView;
            args[j + 1] = cellView.el === magnet2 ? void 0 : magnet2;
            return args;
          }
          return validateConnectionArgs;
        },
        _markAvailableMagnets: function(data2) {
          function isMagnetAvailable(view2, magnet) {
            var paper2 = view2.paper;
            var validate = paper2.options.validateConnection;
            return validate.apply(paper2, this.validateConnectionArgs(view2, magnet));
          }
          var paper = this.paper;
          var elements = paper.model.getCells();
          data2.marked = {};
          for (var i = 0, n = elements.length; i < n; i++) {
            var view = elements[i].findView(paper);
            if (!view) {
              continue;
            }
            var magnets = Array.prototype.slice.call(view.el.querySelectorAll("[magnet]"));
            if (view.el.getAttribute("magnet") !== "false") {
              magnets.push(view.el);
            }
            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data2, view));
            if (availableMagnets.length > 0) {
              for (var j = 0, m = availableMagnets.length; j < m; j++) {
                view.highlight(availableMagnets[j], {
                  magnetAvailability: true
                });
              }
              view.highlight(null, {
                elementAvailability: true
              });
              data2.marked[view.model.id] = availableMagnets;
            }
          }
        },
        _unmarkAvailableMagnets: function(data2) {
          var markedKeys = Object.keys(data2.marked);
          var id2;
          var markedMagnets;
          for (var i = 0, n = markedKeys.length; i < n; i++) {
            id2 = markedKeys[i];
            markedMagnets = data2.marked[id2];
            var view = this.paper.findViewByModel(id2);
            if (view) {
              for (var j = 0, m = markedMagnets.length; j < m; j++) {
                view.unhighlight(markedMagnets[j], {
                  magnetAvailability: true
                });
              }
              view.unhighlight(null, {
                elementAvailability: true
              });
            }
          }
          data2.marked = null;
        },
        startArrowheadMove: function(end, opt) {
          opt || (opt = {});
          var data2 = {
            action: "arrowhead-move",
            arrowhead: end,
            whenNotAllowed: opt.whenNotAllowed || "revert",
            initialMagnet: this[end + "Magnet"] || (this[end + "View"] ? this[end + "View"].el : null),
            initialEnd: clone$1(this.model.get(end)),
            validateConnectionArgs: this._createValidateConnectionArgs(end)
          };
          this._beforeArrowheadMove(data2);
          if (opt.ignoreBackwardsCompatibility !== true) {
            this._dragData = data2;
          }
          return data2;
        },
        // Lifecycle methods
        onMount: function() {
          CellView.prototype.onMount.apply(this, arguments);
          this.mountLabels();
        },
        onDetach: function() {
          CellView.prototype.onDetach.apply(this, arguments);
          this.unmountLabels();
        },
        onRemove: function() {
          CellView.prototype.onRemove.apply(this, arguments);
          this.unmountLabels();
        }
      }, {
        Flags
      });
      Object.defineProperty(LinkView.prototype, "sourceView", {
        enumerable: true,
        get: function() {
          const source = this.model.attributes.source;
          if (source.id && this.paper) {
            return this.paper.findViewByModel(source.id);
          }
          return null;
        }
      });
      Object.defineProperty(LinkView.prototype, "targetView", {
        enumerable: true,
        get: function() {
          const target = this.model.attributes.target;
          if (target.id && this.paper) {
            return this.paper.findViewByModel(target.id);
          }
          return null;
        }
      });
      Object.defineProperty(LinkView.prototype, "sourceMagnet", {
        enumerable: true,
        get: function() {
          const sourceView = this.sourceView;
          if (!sourceView) return null;
          let sourceMagnet = null;
          const cachedSourceMagnet = this._sourceMagnet;
          if (cachedSourceMagnet && sourceView.el.contains(cachedSourceMagnet)) {
            sourceMagnet = cachedSourceMagnet;
          } else {
            sourceMagnet = sourceView.getMagnetFromLinkEnd(this.model.attributes.source);
          }
          this._sourceMagnet = sourceMagnet;
          if (sourceMagnet === sourceView.el) {
            return null;
          }
          return sourceMagnet;
        }
      });
      Object.defineProperty(LinkView.prototype, "targetMagnet", {
        enumerable: true,
        get: function() {
          const targetView = this.targetView;
          if (!targetView) return null;
          let targetMagnet = null;
          const cachedTargetMagnet = this._targetMagnet;
          if (cachedTargetMagnet && targetView.el.contains(cachedTargetMagnet)) {
            targetMagnet = cachedTargetMagnet;
          } else {
            targetMagnet = targetView.getMagnetFromLinkEnd(this.model.attributes.target);
          }
          this._targetMagnet = targetMagnet;
          if (targetMagnet === targetView.el) {
            return null;
          }
          return targetMagnet;
        }
      });
      Object.defineProperty(LinkView.prototype, "sourceBBox", {
        enumerable: true,
        get: function() {
          var sourceView = this.sourceView;
          if (!sourceView) {
            var sourceDef = this.model.source();
            return new Rect(sourceDef.x, sourceDef.y);
          }
          var sourceMagnet = this.sourceMagnet;
          if (sourceView.isNodeConnection(sourceMagnet)) {
            return new Rect(this.sourceAnchor);
          }
          return sourceView.getNodeBBox(sourceMagnet || sourceView.el);
        }
      });
      Object.defineProperty(LinkView.prototype, "targetBBox", {
        enumerable: true,
        get: function() {
          var targetView = this.targetView;
          if (!targetView) {
            var targetDef = this.model.target();
            return new Rect(targetDef.x, targetDef.y);
          }
          var targetMagnet = this.targetMagnet;
          if (targetView.isNodeConnection(targetMagnet)) {
            return new Rect(this.targetAnchor);
          }
          return targetView.getNodeBBox(targetMagnet || targetView.el);
        }
      });
      const LayerView = View.extend({
        tagName: "g",
        svgElement: true,
        pivotNodes: null,
        defaultTheme: null,
        UPDATE_PRIORITY: 4,
        options: {
          id: ""
        },
        paper: null,
        init: function() {
          this.pivotNodes = {};
          this.id = this.options.id || this.cid;
        },
        setPaperReference: function(paper) {
          this.paper = paper;
          this.afterPaperReferenceSet(paper);
        },
        unsetPaperReference: function() {
          if (!this.paper) return;
          this.beforePaperReferenceUnset(this.paper);
          this.paper = null;
        },
        assertPaperReference() {
          if (!this.paper) {
            throw new Error("LayerView: paper reference is not set.");
          }
        },
        afterPaperReferenceSet: function() {
        },
        beforePaperReferenceUnset: function() {
        },
        // prevents id to be set on the DOM element
        _setAttributes: function(attrs) {
          const newAttrs = clone$1(attrs);
          delete newAttrs.id;
          View.prototype._setAttributes.call(this, newAttrs);
        },
        className: function() {
          const {
            id: id2
          } = this.options;
          return addClassNamePrefix(`${id2}-layer`);
        },
        insertSortedNode: function(node, z) {
          this.el.insertBefore(node, this.insertPivot(z));
        },
        insertNode: function(node) {
          const {
            el
          } = this;
          if (node.parentNode !== el) {
            el.appendChild(node);
          }
        },
        insertPivot: function(z) {
          const {
            el,
            pivotNodes
          } = this;
          z = +z;
          z || (z = 0);
          let pivotNode = pivotNodes[z];
          if (pivotNode) return pivotNode;
          pivotNode = pivotNodes[z] = document.createComment("z-index:" + (z + 1));
          let neighborZ = -Infinity;
          for (let currentZ in pivotNodes) {
            currentZ = +currentZ;
            if (currentZ < z && currentZ > neighborZ) {
              neighborZ = currentZ;
              if (neighborZ === z - 1) continue;
            }
          }
          if (neighborZ !== -Infinity) {
            const neighborPivot = pivotNodes[neighborZ];
            el.insertBefore(pivotNode, neighborPivot.nextSibling);
          } else {
            el.insertBefore(pivotNode, el.firstChild);
          }
          return pivotNode;
        },
        removePivots: function() {
          const {
            el,
            pivotNodes
          } = this;
          for (let z in pivotNodes) el.removeChild(pivotNodes[z]);
          this.pivotNodes = {};
        },
        isEmpty: function() {
          return this.el.children.length === 0;
        },
        reset: function() {
          this.removePivots();
        }
      });
      Object.defineProperty(LayerView.prototype, LAYER_VIEW_MARKER, {
        value: true
      });
      const GraphLayerView = LayerView.extend({
        SORT_DELAYING_BATCHES: ["add", "to-front", "to-back"],
        style: {
          webkitUserSelect: "none",
          userSelect: "none"
        },
        graph: null,
        init() {
          LayerView.prototype.init.apply(this, arguments);
          this.graph = this.model.graph;
        },
        className: function() {
          const {
            id: id2
          } = this.options;
          return [addClassNamePrefix(`${id2}-layer`), addClassNamePrefix("cells")].join(" ");
        },
        afterPaperReferenceSet(paper) {
          this.listenTo(this.model, "sort", this.onCellCollectionSort);
          this.listenTo(this.model, "change", this.onCellChange);
          this.listenTo(this.model, "move", this.onCellMove);
          this.listenTo(this.graph, "batch:stop", this.onGraphBatchStop);
        },
        beforePaperReferenceUnset() {
          this.stopListening(this.model);
          this.stopListening(this.graph);
        },
        onCellCollectionSort() {
          if (this.graph.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;
          this.sort();
        },
        onCellMove(cell, opt = {}) {
          this.paper.requestCellViewInsertion(cell, opt);
        },
        onCellChange(cell, opt) {
          if (!cell.hasChanged("z")) return;
          if (this.paper.options.sorting === sortingTypes.APPROX) {
            this.paper.requestCellViewInsertion(cell, opt);
          }
        },
        onGraphBatchStop(data2) {
          const name = data2 && data2.batchName;
          const sortDelayingBatches = this.SORT_DELAYING_BATCHES;
          if (sortDelayingBatches.includes(name) && !this.graph.hasActiveBatch(sortDelayingBatches)) {
            this.sort();
          }
        },
        sort() {
          this.assertPaperReference();
          const {
            paper
          } = this;
          if (!paper.isExactSorting()) {
            return;
          }
          if (paper.isFrozen()) {
            paper._updates.sort = true;
            return;
          }
          this.sortExact();
        },
        sortExact() {
          const cellNodes = Array.from(this.el.children).filter((node) => node.getAttribute("model-id"));
          const cellCollection = this.model.cellCollection;
          sortElements(cellNodes, function(a, b) {
            const cellA = cellCollection.get(a.getAttribute("model-id"));
            const cellB = cellCollection.get(b.getAttribute("model-id"));
            const zA = cellA.attributes.z || 0;
            const zB = cellB.attributes.z || 0;
            return zA === zB ? 0 : zA < zB ? -1 : 1;
          });
        },
        insertCellView(cellView) {
          this.assertPaperReference();
          const {
            paper
          } = this;
          const {
            el,
            model
          } = cellView;
          switch (paper.options.sorting) {
            case sortingTypes.APPROX:
              this.insertSortedNode(el, model.get("z"));
              break;
            case sortingTypes.EXACT:
            default:
              this.insertNode(el);
              break;
          }
        }
      });
      Object.defineProperty(GraphLayerView.prototype, GRAPH_LAYER_VIEW_MARKER, {
        value: true
      });
      const LegacyGraphLayerView = GraphLayerView.extend({
        className: function() {
          const className2 = GraphLayerView.prototype.className.apply(this, arguments);
          return className2 + " " + addClassNamePrefix("viewport");
        }
      });
      class Deque {
        constructor() {
          this.head = null;
          this.tail = null;
          this.map = /* @__PURE__ */ new Map();
        }
        // Return an array of keys in the deque
        keys() {
          let current = this.head;
          const keys2 = [];
          while (current) {
            keys2.push(current.key);
            current = current.next;
          }
          return keys2;
        }
        // Return the first node and remove it from the deque
        popHead() {
          if (!this.head) return null;
          const node = this.head;
          this.map.delete(node.key);
          this.head = node.next;
          if (this.head) {
            this.head.prev = null;
          } else {
            this.tail = null;
          }
          return node;
        }
        // Add a new node to the back of the deque
        pushTail(key, value) {
          if (this.map.has(key)) {
            throw new Error(`Key "${key}" already exists in the deque.`);
          }
          const node = {
            key,
            value,
            prev: null,
            next: null
          };
          this.map.set(key, node);
          if (!this.tail) {
            this.head = this.tail = node;
          } else {
            this.tail.next = node;
            node.prev = this.tail;
            this.tail = node;
          }
        }
        // Move a node from the deque to the head
        moveToHead(key) {
          const node = this.map.get(key);
          if (!node) return;
          if (node === this.head) return;
          if (node.prev) node.prev.next = node.next;
          if (node.next) node.next.prev = node.prev;
          if (node === this.tail) this.tail = node.prev;
          if (node === this.head) this.head = node.next;
          node.prev = null;
          node.next = this.head;
          if (this.head) {
            this.head.prev = node;
          }
          this.head = node;
          if (!this.tail) {
            this.tail = node;
          }
        }
        // Return the first node without removing it
        peekHead() {
          return this.head || null;
        }
        // Move the head node to the back of the deque
        rotate() {
          if (!this.head || !this.head.next) return;
          this.tail.next = this.head;
          this.head.prev = this.tail;
          this.tail = this.head;
          this.head = this.head.next;
          this.tail.next = null;
          this.head.prev = null;
        }
        // Remove a node from the deque
        delete(key) {
          const node = this.map.get(key);
          if (!node) return;
          if (node.prev) node.prev.next = node.next;
          else this.head = node.next;
          if (node.next) node.next.prev = node.prev;
          else this.tail = node.prev;
          this.map.delete(key);
        }
        // Does the deque contain a node with the given key?
        has(key) {
          return this.map.has(key);
        }
        // Get the node with the given key
        get(key) {
          return this.map.get(key) || null;
        }
        // Number of nodes in the deque
        get length() {
          return this.map.size;
        }
      }
      const GridLayerView = LayerView.extend({
        style: {
          "pointer-events": "none"
        },
        _gridCache: null,
        _gridSettings: null,
        init() {
          LayerView.prototype.init.apply(this, arguments);
          this.paper = this.options.paper;
          this._gridCache = null;
          this._gridSettings = [];
        },
        afterPaperReferenceSet(paper) {
          this.listenTo(paper, "transform resize", this.updateGrid);
        },
        beforePaperReferenceUnset(paper) {
          this.stopListening(paper);
        },
        setGrid(drawGrid) {
          this._gridSettings = this.getGridSettings(drawGrid);
          this.renderGrid();
        },
        getGridSettings(drawGrid) {
          const gridSettings = [];
          if (drawGrid) {
            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];
            optionsList.forEach((item) => {
              gridSettings.push(...this._resolveDrawGridOption(item));
            });
          }
          return gridSettings;
        },
        removeGrid() {
          const {
            _gridCache: grid
          } = this;
          if (!grid) return;
          grid.root.remove();
          this._gridCache = null;
        },
        renderGrid() {
          const {
            paper
          } = this;
          const {
            _gridSettings: gridSettings
          } = this;
          this.removeGrid();
          if (gridSettings.length === 0) return;
          const gridSize = paper.options.drawGridSize || paper.options.gridSize;
          if (gridSize <= 1) {
            return;
          }
          const refs = this._getGridRefs();
          gridSettings.forEach((gridLayerSetting, index2) => {
            const id2 = this._getPatternId(index2);
            const options = merge({}, gridLayerSetting);
            const {
              scaleFactor = 1
            } = options;
            options.width = gridSize * scaleFactor || 1;
            options.height = gridSize * scaleFactor || 1;
            let vPattern;
            if (!refs.exist(id2)) {
              vPattern = V2("pattern", {
                id: id2,
                patternUnits: "userSpaceOnUse"
              }, V2(options.markup));
              refs.add(id2, vPattern);
            } else {
              vPattern = refs.get(id2);
            }
            if (isFunction(options.render)) {
              options.render(vPattern.node.firstChild, options, paper);
            }
            vPattern.attr({
              width: options.width,
              height: options.height
            });
          });
          refs.root.appendTo(this.el);
          this.updateGrid();
        },
        updateGrid() {
          const {
            _gridCache: grid,
            _gridSettings: gridSettings,
            paper
          } = this;
          if (!grid) return;
          const {
            root: vSvg,
            patterns
          } = grid;
          const {
            x,
            y,
            width: width2,
            height: height2
          } = paper.getArea();
          vSvg.attr({
            x,
            y,
            width: width2,
            height: height2
          });
          for (const patternId in patterns) {
            const vPattern = patterns[patternId];
            vPattern.attr({
              x: -x,
              y: -y
            });
          }
          gridSettings.forEach((options, index2) => {
            if (isFunction(options.update)) {
              const vPattern = patterns[this._getPatternId(index2)];
              options.update(vPattern.node.firstChild, options, paper);
            }
          });
        },
        _getPatternId(index2) {
          return `pattern_${this.paper.cid}_${index2}`;
        },
        _getGridRefs() {
          let {
            _gridCache: grid
          } = this;
          if (grid) return grid;
          const defsVEl = V2("defs");
          const svgVEl = V2("svg", {
            width: "100%",
            height: "100%"
          }, [defsVEl]);
          grid = this._gridCache = {
            root: svgVEl,
            patterns: {},
            add: function(id2, patternVEl) {
              const rectVEl = V2("rect", {
                width: "100%",
                height: "100%",
                fill: `url(#${id2})`
              });
              defsVEl.append(patternVEl);
              svgVEl.append(rectVEl);
              this.patterns[id2] = patternVEl;
            },
            get: function(id2) {
              return this.patterns[id2];
            },
            exist: function(id2) {
              return this.patterns[id2] !== void 0;
            }
          };
          return grid;
        },
        _resolveDrawGridOption(opt) {
          const namespace = this.options.patterns;
          if (isString(opt) && Array.isArray(namespace[opt])) {
            return namespace[opt].map(function(item) {
              return assign({}, item);
            });
          }
          const options = opt || {
            args: [{}]
          };
          const isArray2 = Array.isArray(options);
          let name = options.name;
          if (!isArray2 && !name && !options.markup) {
            name = "dot";
          }
          if (name && Array.isArray(namespace[name])) {
            const pattern = namespace[name].map(function(item) {
              return assign({}, item);
            });
            const args = Array.isArray(options.args) ? options.args : [options.args || {}];
            defaults(args[0], omit(opt, "args"));
            for (let i = 0; i < args.length; i++) {
              if (pattern[i]) {
                assign(pattern[i], args[i]);
              }
            }
            return pattern;
          }
          return isArray2 ? options : [options];
        },
        isEmpty() {
          const {
            _gridCache: grid
          } = this;
          return this.el.children.length === (grid ? 1 : 0);
        }
      });
      const paperLayers = {
        GRID: "grid",
        BACK: "back",
        /** @deprecated */
        CELLS: "cells",
        FRONT: "front",
        TOOLS: "tools",
        LABELS: "labels"
      };
      const sortingTypes = {
        NONE: "sorting-none",
        APPROX: "sorting-approximate",
        EXACT: "sorting-exact"
      };
      const WHEEL_CAP = 50;
      const WHEEL_WAIT_MS = 20;
      const MOUNT_BATCH_SIZE = 1e3;
      const UPDATE_BATCH_SIZE = Infinity;
      const MIN_PRIORITY = 9007199254740991;
      const HighlightingTypes = CellView.Highlighting;
      const defaultHighlighting = {
        [HighlightingTypes.DEFAULT]: {
          name: "stroke",
          options: {
            padding: 3
          }
        },
        [HighlightingTypes.MAGNET_AVAILABILITY]: {
          name: "addClass",
          options: {
            className: "available-magnet"
          }
        },
        [HighlightingTypes.ELEMENT_AVAILABILITY]: {
          name: "addClass",
          options: {
            className: "available-cell"
          }
        }
      };
      const gridPatterns = {
        dot: [{
          color: "#AAAAAA",
          thickness: 1,
          markup: "rect",
          render: function(el, opt) {
            V2(el).attr({
              width: opt.thickness,
              height: opt.thickness,
              fill: opt.color
            });
          }
        }],
        fixedDot: [{
          color: "#AAAAAA",
          thickness: 1,
          markup: "rect",
          render: function(el, opt) {
            V2(el).attr({
              fill: opt.color
            });
          },
          update: function(el, opt, paper) {
            const {
              sx,
              sy
            } = paper.scale();
            const width2 = sx <= 1 ? opt.thickness : opt.thickness / sx;
            const height2 = sy <= 1 ? opt.thickness : opt.thickness / sy;
            V2(el).attr({
              width: width2,
              height: height2
            });
          }
        }],
        mesh: [{
          color: "#AAAAAA",
          thickness: 1,
          markup: "path",
          render: function(el, opt) {
            var d;
            var width2 = opt.width;
            var height2 = opt.height;
            var thickness = opt.thickness;
            if (width2 - thickness >= 0 && height2 - thickness >= 0) {
              d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
            } else {
              d = "M 0 0 0 0";
            }
            V2(el).attr({
              "d": d,
              stroke: opt.color,
              "stroke-width": opt.thickness
            });
          }
        }],
        doubleMesh: [{
          color: "#AAAAAA",
          thickness: 1,
          markup: "path",
          render: function(el, opt) {
            var d;
            var width2 = opt.width;
            var height2 = opt.height;
            var thickness = opt.thickness;
            if (width2 - thickness >= 0 && height2 - thickness >= 0) {
              d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
            } else {
              d = "M 0 0 0 0";
            }
            V2(el).attr({
              "d": d,
              stroke: opt.color,
              "stroke-width": opt.thickness
            });
          }
        }, {
          color: "#000000",
          thickness: 3,
          scaleFactor: 4,
          markup: "path",
          render: function(el, opt) {
            var d;
            var width2 = opt.width;
            var height2 = opt.height;
            var thickness = opt.thickness;
            if (width2 - thickness >= 0 && height2 - thickness >= 0) {
              d = ["M", width2, 0, "H0 M0 0 V0", height2].join(" ");
            } else {
              d = "M 0 0 0 0";
            }
            V2(el).attr({
              "d": d,
              stroke: opt.color,
              "stroke-width": opt.thickness
            });
          }
        }]
      };
      const backgroundPatterns = {
        flipXy: function(img) {
          var canvas = document.createElement("canvas");
          var imgWidth = img.width;
          var imgHeight = img.height;
          canvas.width = 2 * imgWidth;
          canvas.height = 2 * imgHeight;
          var ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          ctx.setTransform(1, 0, 0, -1, 0, canvas.height);
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          return canvas;
        },
        flipX: function(img) {
          var canvas = document.createElement("canvas");
          var imgWidth = img.width;
          var imgHeight = img.height;
          canvas.width = imgWidth * 2;
          canvas.height = imgHeight;
          var ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          ctx.translate(2 * imgWidth, 0);
          ctx.scale(-1, 1);
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          return canvas;
        },
        flipY: function(img) {
          var canvas = document.createElement("canvas");
          var imgWidth = img.width;
          var imgHeight = img.height;
          canvas.width = imgWidth;
          canvas.height = imgHeight * 2;
          var ctx = canvas.getContext("2d");
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          ctx.translate(0, 2 * imgHeight);
          ctx.scale(1, -1);
          ctx.drawImage(img, 0, 0, imgWidth, imgHeight);
          return canvas;
        },
        watermark: function(img, opt) {
          opt = opt || {};
          var imgWidth = img.width;
          var imgHeight = img.height;
          var canvas = document.createElement("canvas");
          canvas.width = imgWidth * 3;
          canvas.height = imgHeight * 3;
          var ctx = canvas.getContext("2d");
          var angle = isNumber(opt.watermarkAngle) ? -opt.watermarkAngle : -20;
          var radians2 = toRad(angle);
          var stepX = canvas.width / 4;
          var stepY = canvas.height / 4;
          for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
              if ((i + j) % 2 > 0) {
                ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);
                ctx.rotate(radians2);
                ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);
              }
            }
          }
          return canvas;
        }
      };
      const implicitLayers = [{
        id: paperLayers.GRID,
        type: "GridLayerView",
        patterns: gridPatterns
      }, {
        id: paperLayers.BACK
      }, {
        id: paperLayers.LABELS
      }, {
        id: paperLayers.FRONT
      }, {
        id: paperLayers.TOOLS
      }];
      const CELL_VIEW_PLACEHOLDER_MARKER = Symbol("joint.cellViewPlaceholderMarker");
      const Paper = View.extend({
        className: "paper",
        options: {
          width: 800,
          height: 600,
          gridSize: 1,
          // Whether or not to draw the grid lines on the paper's DOM element.
          // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }
          drawGrid: false,
          // If not set, the size of the visual grid is the same as the `gridSize`.
          drawGridSize: null,
          // Whether or not to draw the background on the paper's DOM element.
          // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }
          background: false,
          elementView: ElementView,
          linkView: LinkView,
          snapLabels: false,
          // false, true
          snapLinks: false,
          // false, true, { radius: value }
          snapLinksSelf: false,
          // false, true, { radius: value }
          // Should the link labels be rendered into its own layer?
          // `false` - the labels are part of the links
          // `true` - the labels are appended to LayersName.LABELS
          // [LayersName] - the labels are appended to the layer specified
          labelsLayer: false,
          // When set to FALSE, an element may not have more than 1 link with the same source and target element.
          multiLinks: true,
          // For adding custom guard logic.
          guard: function(evt, view) {
            return false;
          },
          highlighting: defaultHighlighting,
          // Prevent the default context menu from being displayed.
          preventContextMenu: true,
          // Prevent the default action for blank:pointer<action>.
          preventDefaultBlankAction: true,
          // Prevent the default action for cell:pointer<action>.
          preventDefaultViewAction: true,
          // Restrict the translation of elements by given bounding box.
          // Option accepts a boolean:
          //  true - the translation is restricted to the paper area
          //  false - no restrictions
          // A method:
          // restrictTranslate: function(elementView) {
          //     var parentId = elementView.model.get('parent');
          //     return parentId && this.model.getCell(parentId).getBBox();
          // },
          // Or a bounding box:
          // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }
          restrictTranslate: false,
          // Marks all available magnets with 'available-magnet' class name and all available cells with
          // 'available-cell' class name. Marks them when dragging a link is started and unmark
          // when the dragging is stopped.
          markAvailable: false,
          // Defines what link model is added to the graph after an user clicks on an active magnet.
          // Value could be the mvc.model or a function returning the mvc.model
          // defaultLink: (elementView, magnet) => {
          //   return condition ? new customLink1() : new customLink2()
          // }
          defaultLink: function() {
            const {
              cellNamespace
            } = this.model.layerCollection;
            const ctor = getByPath(cellNamespace, ["standard", "Link"]);
            if (!ctor) throw new Error("dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.");
            return new ctor();
          },
          // A connector that is used by links with no connector defined on the model.
          // e.g. { name: 'rounded', args: { radius: 5 }} or a function
          defaultConnector: {
            name: "normal"
          },
          // A router that is used by links with no router defined on the model.
          // e.g. { name: 'oneSide', args: { padding: 10 }} or a function
          defaultRouter: {
            name: "normal"
          },
          defaultAnchor: {
            name: "center"
          },
          defaultLinkAnchor: {
            name: "connectionRatio"
          },
          defaultConnectionPoint: {
            name: "boundary"
          },
          /* CONNECTING */
          connectionStrategy: null,
          // Check whether to add a new link to the graph when user clicks on an a magnet.
          validateMagnet: function(_cellView, magnet, _evt) {
            return magnet.getAttribute("magnet") !== "passive";
          },
          // Check whether to allow or disallow the link connection while an arrowhead end (source/target)
          // being changed.
          validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {
            return (end === "target" ? cellViewT : cellViewS) instanceof ElementView;
          },
          /* EMBEDDING */
          // Enables embedding. Re-parent the dragged element with elements under it and makes sure that
          // all links and elements are visible taken the level of embedding into account.
          embeddingMode: false,
          // Check whether to allow or disallow the element embedding while an element being translated.
          validateEmbedding: function(childView, parentView) {
            return true;
          },
          // Check whether to allow or disallow an embedded element to be unembedded / to become a root.
          validateUnembedding: function(childView) {
            return true;
          },
          // Determines the way how a cell finds a suitable parent when it's dragged over the paper.
          // The cell with the highest z-index (visually on the top) will be chosen.
          findParentBy: "bbox",
          // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'
          // If enabled only the element on the very front is taken into account for the embedding.
          // If disabled the elements under the dragged view are tested one by one
          // (from front to back) until a valid parent found.
          frontParentOnly: true,
          // Interactive flags. See online docs for the complete list of interactive flags.
          interactive: {
            labelMove: false
          },
          // When set to true the links can be pinned to the paper.
          // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };
          linkPinning: true,
          // Custom validation after an interaction with a link ends.
          // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)
          // (linkView, paper) => boolean
          allowLink: null,
          // Allowed number of mousemove events after which the pointerclick event will be still triggered.
          clickThreshold: 0,
          // Number of required mousemove events before the first pointermove event will be triggered.
          moveThreshold: 0,
          // Number of required mousemove events before a link is created out of the magnet.
          // Or string `onleave` so the link is created when the pointer leaves the magnet
          magnetThreshold: 0,
          // Rendering Options
          sorting: sortingTypes.APPROX,
          frozen: false,
          autoFreeze: false,
          viewManagement: false,
          // no docs yet
          onViewUpdate: function(view, flag, priority, opt, paper) {
            if (opt.mounting || opt.isolate) {
              return;
            }
            if (!(opt.replace && opt.add)) {
              if (flag & (paper.FLAG_INSERT | paper.FLAG_REMOVE)) {
                return;
              }
            }
            paper.requestConnectedLinksUpdate(view, priority, opt);
          },
          // no docs yet
          onViewPostponed: function(view, flag, paper) {
            return paper.forcePostponedViewUpdate(view, flag);
          },
          beforeRender: null,
          // function(opt, paper) { },
          afterRender: null,
          // function(stats, opt, paper) {
          viewport: null,
          // Default namespaces
          cellViewNamespace: null,
          layerViewNamespace: null,
          routerNamespace: null,
          connectorNamespace: null,
          highlighterNamespace: highlighters,
          anchorNamespace: anchors,
          linkAnchorNamespace: linkAnchors,
          connectionPointNamespace: connectionPoints,
          overflow: false
        },
        events: {
          "dblclick": "pointerdblclick",
          "dbltap": "pointerdblclick",
          "contextmenu": "contextmenu",
          "mousedown": "pointerdown",
          "touchstart": "pointerdown",
          "mouseover": "mouseover",
          "mouseout": "mouseout",
          "mouseenter": "mouseenter",
          "mouseleave": "mouseleave",
          "wheel": "mousewheel",
          "mouseenter .joint-cell": "mouseenter",
          "mouseleave .joint-cell": "mouseleave",
          "mouseenter .joint-tools": "mouseenter",
          "mouseleave .joint-tools": "mouseleave",
          "dblclick .joint-cell [magnet]": "magnetpointerdblclick",
          "contextmenu .joint-cell [magnet]": "magnetcontextmenu",
          "mousedown .joint-link .label": "onlabel",
          // interaction with link label
          "touchstart .joint-link .label": "onlabel",
          "dragstart .joint-cell image": "onImageDragStart"
          // firefox fix
        },
        documentEvents: {
          "mousemove": "pointermove",
          "touchmove": "pointermove",
          "mouseup": "pointerup",
          "touchend": "pointerup",
          "touchcancel": "pointerup"
        },
        /* CSS within the SVG document
        * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for
        *    elements that use the `scalable` group.
        */
        stylesheet: (
          /*css*/
          `
        .joint-element .scalable * {
            vector-effect: non-scaling-stroke;
        }
    `
        ),
        svg: null,
        defs: null,
        tools: null,
        layers: null,
        // deprecated, use layers element instead
        viewport: null,
        // For storing the current transformation matrix (CTM) of the paper's viewport.
        _viewportMatrix: null,
        // For verifying whether the CTM is up-to-date. The viewport transform attribute
        // could have been manipulated directly.
        _viewportTransformString: null,
        // Updates data (priorities, unmounted views etc.)
        _updates: null,
        // Paper Layers
        _layers: null,
        UPDATE_DELAYING_BATCHES: ["translate"],
        // If you interact with these elements,
        // the default interaction such as `element move` is prevented.
        FORM_CONTROL_TAG_NAMES: ["TEXTAREA", "INPUT", "BUTTON", "SELECT", "OPTION"],
        // If you interact with these elements, the events are not propagated to the paper
        // i.e. paper events such as `element:pointerdown` are not triggered.
        GUARDED_TAG_NAMES: [
          // Guard <select> for consistency. When you click on it:
          // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open
          // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).
          //          on close. However, if you open and then close by clicking elsewhere on the page,
          //           no other event is triggered.
          // Safari: when you open it, it triggers `pointerdown`. That's it.
          "SELECT"
        ],
        MIN_SCALE: 1e-6,
        // Default find buffer for the findViewsInArea and findViewsAtPoint methods.
        // The find buffer is used to extend the area of the search
        // to mitigate the differences between the model and view geometry.
        DEFAULT_FIND_BUFFER: 200,
        FLAG_INSERT: 1 << 30,
        FLAG_REMOVE: 1 << 29,
        FLAG_INIT: 1 << 28,
        // Layers that are always present on the paper (e.g. grid, back, front, tools)
        implicitLayers,
        // Reference layer for inserting new graph layers.
        graphLayerRefId: paperLayers.LABELS,
        init: function() {
          const {
            options
          } = this;
          if (!options.cellViewNamespace) {
            options.cellViewNamespace = typeof joint !== "undefined" && has(joint, "shapes") ? joint.shapes : null;
          }
          const defaultLayerViewNamespace = {
            LayerView,
            GraphLayerView,
            GridLayerView
          };
          this.layerViewNamespace = defaultsDeep({}, options.layerViewNamespace || {}, defaultLayerViewNamespace);
          const model = this.model = options.model || new Graph();
          this.legacyMode = !options.viewManagement;
          this._layers = {
            viewsMap: {},
            order: []
          };
          this._views = {};
          this._viewPlaceholders = {};
          this._idToCid = {};
          this.cloneOptions();
          this.render();
          this._setDimensions();
          this.startListening();
          this._mw_evt_buffer = {
            event: null,
            deltas: []
          };
          this.resetViews(model.getCells());
        },
        _resetUpdates: function() {
          if (this._updates && this._updates.id) cancelFrame(this._updates.id);
          return this._updates = {
            id: null,
            priorities: [{}, {}, {}],
            unmountedList: new Deque(),
            mountedList: new Deque(),
            count: 0,
            keyFrozen: false,
            freezeKey: null,
            sort: false,
            disabled: false,
            idle: false,
            freshAfterReset: true
          };
        },
        startListening: function() {
          var model = this.model;
          this.listenTo(model, "add", this.onCellAdded).listenTo(model, "remove", this.onCellRemoved).listenTo(model, "reset", this.onGraphReset).listenTo(model, "batch:stop", this.onGraphBatchStop);
          this.listenTo(model, "layer:add", this.onGraphLayerAdd).listenTo(model, "layer:remove", this.onGraphLayerRemove).listenTo(model, "layers:sort", this.onGraphLayerCollectionSort);
          this.on("cell:highlight", this.onCellHighlight).on("cell:unhighlight", this.onCellUnhighlight).on("transform", this.update);
        },
        onCellAdded: function(cell, _, opt) {
          var position2 = opt.position;
          if (this.isAsync() || !isNumber(position2)) {
            this.renderView(cell, opt);
          } else {
            if (opt.maxPosition === position2) this.freeze({
              key: "addCells"
            });
            this.renderView(cell, opt);
            if (position2 === 0) this.unfreeze({
              key: "addCells"
            });
          }
        },
        onCellRemoved: function(cell, _, opt) {
          const viewLike = this._getCellViewLike(cell);
          if (!viewLike) return;
          if (viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {
            this._updates.unmountedList.delete(viewLike.cid);
            this._unregisterCellViewPlaceholder(viewLike);
          } else {
            this.requestViewUpdate(viewLike, this.FLAG_REMOVE, viewLike.UPDATE_PRIORITY, opt);
          }
        },
        onGraphReset: function(_collection, opt) {
          this.renderGraphLayerViews();
          this.resetLayerViews();
          this.assertLayerViews();
          this.resetViews(this.model.getCells(), opt);
        },
        onGraphBatchStop: function(data2) {
          if (this.isFrozen() || this.isIdle()) return;
          var name = data2 && data2.batchName;
          var graph = this.model;
          if (!this.isAsync()) {
            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;
            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {
              this.updateViews(data2);
            }
          }
        },
        /**
        * @protected
        * @description When a new layer is added to the graph, we create a new layer view
        **/
        onGraphLayerAdd: function(layer, _, opt) {
          if (this.hasLayerView(layer.id)) return;
          const layerView = this.createLayerView({
            id: layer.id,
            model: layer
          });
          const layers = this.model.getLayers();
          let before;
          if (layers[layers.length - 1] === layer) {
            before = paperLayers.LABELS;
          } else {
            const index2 = layers.indexOf(layer);
            before = layers[index2 + 1].id;
          }
          this.addLayerView(layerView, {
            before
          });
        },
        /**
         * @protected
         * @description When a layer is removed from the graph, we remove the corresponding layer view
         **/
        onGraphLayerRemove: function(layer, _, opt) {
          if (!this.hasLayerView(layer)) return;
          this.requestLayerViewRemoval(layer);
        },
        /**
         * @protected
         * @description When the graph layer collection is sorted,
         * we reorder all graph layer views.
         **/
        onGraphLayerCollectionSort: function(layerCollection) {
          layerCollection.each((layer) => {
            if (!this.hasLayerView(layer)) return;
            this.moveLayerView(layer, {
              before: this.graphLayerRefId
            });
          });
        },
        /**
         * @protected
         * @description Resets all graph layer views.
         */
        renderGraphLayerViews: function() {
          this.getLayerViews().forEach((layerView) => {
            if (!layerView[GRAPH_LAYER_VIEW_MARKER]) return;
            this._removeLayerView(layerView);
          });
          this.model.getLayers().forEach((layer) => {
            const layerView = this.createLayerView({
              id: layer.id,
              model: layer
            });
            this.addLayerView(layerView, {
              before: this.graphLayerRefId
            });
          });
        },
        /**
         * @protected
         * @description Renders all implicit layer views.
         */
        renderImplicitLayerViews: function() {
          this.implicitLayers.forEach((layerInit) => {
            const layerView = this.createLayerView(layerInit);
            this.addLayerView(layerView);
          });
        },
        cloneOptions: function() {
          const {
            options
          } = this;
          const {
            defaultConnector,
            defaultRouter,
            defaultConnectionPoint,
            defaultAnchor,
            defaultLinkAnchor,
            highlighting,
            cellViewNamespace,
            interactive
          } = options;
          if (!cellViewNamespace && typeof joint !== "undefined" && has(joint, "shapes")) {
            options.cellViewNamespace = joint.shapes;
          }
          if (!isFunction(defaultConnector)) {
            options.defaultConnector = cloneDeep(defaultConnector);
          }
          if (!isFunction(defaultRouter)) {
            options.defaultRouter = cloneDeep(defaultRouter);
          }
          if (!isFunction(defaultConnectionPoint)) {
            options.defaultConnectionPoint = cloneDeep(defaultConnectionPoint);
          }
          if (!isFunction(defaultAnchor)) {
            options.defaultAnchor = cloneDeep(defaultAnchor);
          }
          if (!isFunction(defaultLinkAnchor)) {
            options.defaultLinkAnchor = cloneDeep(defaultLinkAnchor);
          }
          if (isPlainObject(interactive)) {
            options.interactive = assign({}, interactive);
          }
          if (isPlainObject(highlighting)) {
            options.highlighting = defaultsDeep({}, highlighting, defaultHighlighting);
          }
          options.viewManagement = defaults({}, options.viewManagement, {
            // Whether to lazy initialize the cell views.
            lazyInitialize: !!options.viewManagement,
            // default `true` if options.viewManagement provided
            // Whether to add initialized cell views into the unmounted queue.
            initializeUnmounted: false,
            // Whether to dispose the cell views that are not visible.
            disposeHidden: false
          });
        },
        children: function() {
          var ns2 = V2.namespace;
          return [{
            namespaceURI: ns2.xhtml,
            tagName: "div",
            className: addClassNamePrefix("paper-background"),
            selector: "background",
            style: {
              position: "absolute",
              inset: 0
            }
          }, {
            namespaceURI: ns2.svg,
            tagName: "svg",
            attributes: {
              "width": "100%",
              "height": "100%",
              "xmlns:xlink": ns2.xlink
            },
            selector: "svg",
            style: {
              position: "absolute",
              inset: 0
            },
            children: [{
              // Append `<defs>` element to the SVG document. This is useful for filters and gradients.
              // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).
              tagName: "defs",
              selector: "defs"
            }, {
              tagName: "g",
              className: addClassNamePrefix("layers"),
              selector: "layers"
            }]
          }];
        },
        /**
         * @public
         * @description Checks whether the layer view exists by the given layer id or layer model.
         * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
         * @return {boolean} True if the layer view exists, false otherwise.
         */
        hasLayerView(layerRef) {
          let layerId;
          if (isString(layerRef)) {
            layerId = layerRef;
          } else if (layerRef) {
            layerId = layerRef.id;
          } else {
            return false;
          }
          return layerId in this._layers.viewsMap;
        },
        /**
         * @public
         * @description Returns the layer view by the given layer id or layer model.
         * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
         * @return {dia.LayerView} The layer view.
         * @throws {Error} if the layer view is not found
         */
        getLayerView(layerRef) {
          let layerId;
          if (isString(layerRef)) {
            layerId = layerRef;
          } else if (layerRef) {
            layerId = layerRef.id;
          } else {
            throw new Error("dia.Paper: No layer provided.");
          }
          const layerView = this._layers.viewsMap[layerId];
          if (!layerView) {
            throw new Error(`dia.Paper: Unknown layer view "${layerId}".`);
          }
          return layerView;
        },
        /**
         * @deprecated use `getLayerView(layerId).el` instead
         */
        getLayerNode(layerId) {
          return this.getLayerView(layerId).el;
        },
        /**
         * @protected
         * @description Removes the given layer view from the paper.
         * It does not check whether the layer view is empty.
         * @param {dia.LayerView} layerView - The layer view to remove.
         */
        _removeLayerView(layerView) {
          this._unregisterLayerView(layerView);
          layerView.remove();
        },
        /**
         * @protected
         * @description Removes all layer views from the paper.
         * It does not check whether the layer views are empty.
         */
        _removeLayerViews: function() {
          Object.values(this._layers.viewsMap).forEach((layerView) => {
            this._removeLayerView(layerView);
          });
        },
        /**
         * @protected
         * @description Unregisters the given layer view from the paper.
         * @param {dia.LayerView} layerView - The layer view to unregister.
         */
        _unregisterLayerView(layerView) {
          const {
            _layers: {
              viewsMap,
              order
            }
          } = this;
          const layerId = layerView.id;
          const layerIndex = order.indexOf(layerId);
          if (layerIndex !== -1) {
            order.splice(layerIndex, 1);
          }
          layerView.unsetPaperReference();
          delete viewsMap[layerId];
        },
        /**
         * @protected
         * @description Registers the given layer view in the paper.
         * @param {dia.LayerView} layerView - The layer view to register.
         * @throws {Error} if the layer view is not an instance of dia.LayerView
         * @throws {Error} if the layer view already exists in the paper
         */
        _registerLayerView(layerView) {
          if (!layerView || !layerView[LAYER_VIEW_MARKER]) {
            throw new Error("dia.Paper: The layer view must be an instance of dia.LayerView.");
          }
          if (this.hasLayerView(layerView.id)) {
            throw new Error(`dia.Paper: The layer view "${layerView.id}" already exists.`);
          }
          layerView.setPaperReference(this);
          this._layers.viewsMap[layerView.id] = layerView;
        },
        /**
         * @public
         * @description Removes the layer view by the given layer id or layer model.
         * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
         * @throws {Error} if the layer view is not empty
         */
        removeLayerView(layerRef) {
          const layerView = this.getLayerView(layerRef);
          if (!layerView.isEmpty()) {
            throw new Error("dia.Paper: The layer view is not empty.");
          }
          this._removeLayerView(layerView);
        },
        /**
         * @protected
         * @description Schedules the layer view removal by the given layer id or layer model.
         * The actual removal will be performed during the paper update cycle.
         * @param {string|dia.GraphLayer} layerRef - Layer id or layer model.
         * @param {Object} [opt] - Update options.
         */
        requestLayerViewRemoval(layerRef, opt) {
          const layerView = this.getLayerView(layerRef);
          const {
            FLAG_REMOVE
          } = this;
          const {
            UPDATE_PRIORITY
          } = layerView;
          this.requestViewUpdate(layerView, FLAG_REMOVE, UPDATE_PRIORITY, opt);
        },
        /**
         * @public
         * @internal not documented
         * @description Schedules the cell view insertion into the appropriate layer view.
         * The actual insertion will be performed during the paper update cycle.
         * @param {dia.Cell} cell - The cell model whose view should be inserted.
         * @param {Object} [opt] - Update options.
         */
        requestCellViewInsertion(cell, opt) {
          const viewLike = this._getCellViewLike(cell);
          if (!viewLike) return;
          this.requestViewUpdate(viewLike, this.FLAG_INSERT, viewLike.UPDATE_PRIORITY, opt);
        },
        /**
         * @private
         * Helper method for addLayerView and moveLayerView methods
         */
        _getBeforeLayerViewFromOptions(layerView, options) {
          let {
            before = null,
            index: index2
          } = options;
          if (before && index2 !== void 0) {
            throw new Error('dia.Paper: Options "before" and "index" are mutually exclusive.');
          }
          let computedBefore;
          if (index2 !== void 0) {
            const {
              _layers: {
                order
              }
            } = this;
            if (index2 >= order.length) {
              computedBefore = null;
            } else if (index2 < 0) {
              computedBefore = order[0];
            } else {
              const originalIndex = order.indexOf(layerView.id);
              if (originalIndex !== -1 && index2 > originalIndex) {
                index2 += 1;
              }
              computedBefore = order[index2] || null;
            }
          } else {
            computedBefore = before;
          }
          return computedBefore ? this.getLayerView(computedBefore) : null;
        },
        /**
         * @public
         * @description Adds the layer view to the paper.
         * @param {dia.LayerView} layerView - The layer view to add.
         * @param {Object} [options] - Adding options.
         * @param {string|dia.GraphLayer} [options.before] - Layer id or layer model before
         */
        addLayerView(layerView, options = {}) {
          this._registerLayerView(layerView);
          const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);
          this.insertLayerView(layerView, beforeLayerView);
        },
        /**
         * @public
         * @description Moves the layer view.
         * @param {Paper.LayerRef} layerRef - The layer view reference to move.
         * @param {Object} [options] - Moving options.
         * @param {Paper.LayerRef} [options.before] - Layer id or layer model before
         * @param {number} [options.index] - Zero-based index to which to move the layer view.
         */
        moveLayerView(layerRef, options = {}) {
          const layerView = this.getLayerView(layerRef);
          const beforeLayerView = this._getBeforeLayerViewFromOptions(layerView, options);
          this.insertLayerView(layerView, beforeLayerView);
        },
        /**
         * @protected
         * @description Inserts the layer view into the paper.
         * If the layer view already exists in the paper, it is moved to the new position.
         * @param {dia.LayerView} layerView - The layer view to insert.
         * @param {dia.LayerView} [before] - Layer view before
         * which the layer view should be inserted.
         */
        insertLayerView(layerView, beforeLayerView) {
          const layerId = layerView.id;
          const {
            _layers: {
              order
            }
          } = this;
          const currentLayerIndex = order.indexOf(layerId);
          if (beforeLayerView) {
            const beforeLayerViewId = beforeLayerView.id;
            if (layerId === beforeLayerViewId) {
              return;
            }
            let beforeLayerPosition = order.indexOf(beforeLayerViewId);
            if (currentLayerIndex !== -1) {
              if (currentLayerIndex < beforeLayerPosition) {
                beforeLayerPosition -= 1;
              }
              order.splice(currentLayerIndex, 1);
            }
            order.splice(beforeLayerPosition, 0, layerId);
            this.layers.insertBefore(layerView.el, beforeLayerView.el);
            return;
          }
          if (currentLayerIndex !== -1) {
            order.splice(currentLayerIndex, 1);
          }
          order.push(layerId);
          this.layers.appendChild(layerView.el);
        },
        /**
         * @protected
         * @description Returns an array of layer view ids in the order they are rendered.
         * @returns {string[]} An array of layer view ids.
         */
        getLayerViewOrder() {
          return this._layers.order.slice();
        },
        /**
         * @public
         * @description Returns an array of layer views in the order they are rendered.
         * @returns {dia.LayerView[]} An array of layer views.
         */
        getLayerViews() {
          return this.getLayerViewOrder().map((id2) => this.getLayerView(id2));
        },
        /**
         * @public
         * @description Returns an array of graph layer views in the order they are rendered.
         * @returns {dia.GraphLayerView[]} An array of graph layer views.
         */
        getGraphLayerViews() {
          const {
            _layers: {
              viewsMap
            }
          } = this;
          return this.model.getLayers().map((layer) => viewsMap[layer.id]);
        },
        render: function() {
          this.renderChildren();
          const {
            el,
            childNodes,
            options,
            stylesheet
          } = this;
          const {
            svg: svg2,
            defs,
            layers
          } = childNodes;
          el.style.position = "relative";
          svg2.style.overflow = options.overflow ? "visible" : "hidden";
          this.svg = svg2;
          this.defs = defs;
          this.layers = layers;
          this.renderLayerViews();
          V2.ensureId(svg2);
          this.addStylesheet(stylesheet);
          if (options.background) {
            this.drawBackground(options.background);
          }
          if (options.drawGrid) {
            this.setGrid(options.drawGrid);
          }
          return this;
        },
        addStylesheet: function(css2) {
          if (!css2) return;
          V2(this.svg).prepend(V2.createSVGStyle(css2));
        },
        /**
         * @protected
         * @description Creates a layer view instance based on the provided options.
         * It finds the appropriate layer view constructor from the paper's
         * `layerViewNamespace` and instantiates it.
         * @param {*} options See `dia.LayerView` options.
         * @returns {dia.LayerView}
         */
        createLayerView(options) {
          if (options == null) {
            throw new Error("dia.Paper: Layer view options are required.");
          }
          if (options.id == null) {
            throw new Error("dia.Paper: Layer view id is required.");
          }
          const viewOptions2 = clone$1(options);
          let viewConstructor;
          if (viewOptions2.model) {
            const modelType = viewOptions2.model.get("type") || viewOptions2.model.constructor.name;
            const type = modelType + "View";
            if (this.model.legacyMode) {
              viewConstructor = LegacyGraphLayerView;
            } else {
              viewConstructor = this.layerViewNamespace[type] || LayerView;
            }
          } else {
            const type = viewOptions2.type;
            viewConstructor = this.layerViewNamespace[type] || LayerView;
          }
          return new viewConstructor(viewOptions2);
        },
        /**
         * @protected
         * @description Renders all paper layer views and graph layer views.
         */
        renderLayerViews: function() {
          this._removeLayerViews();
          this.renderImplicitLayerViews();
          this.renderGraphLayerViews();
          this.assertLayerViews();
        },
        /**
         * @protected
         * @description Ensures that essential layer views are present on the paper.
         * @throws {Error} if any of the essential layer views is missing
         */
        assertLayerViews: function() {
          const cellsLayerView = this.getLayerView(this.model.getDefaultLayer().id);
          const toolsLayerView = this.getLayerView(paperLayers.TOOLS);
          const labelsLayerView = this.getLayerView(paperLayers.LABELS);
          this.tools = toolsLayerView.el;
          this.cells = this.viewport = cellsLayerView.el;
          labelsLayerView.vel.addClass(addClassNamePrefix("viewport"));
          labelsLayerView.el.style.webkitUserSelect = "none";
          labelsLayerView.el.style.userSelect = "none";
        },
        /**
         * @protected
         * @description Resets all layer views.
         */
        resetLayerViews: function() {
          this.getLayerViews().forEach((layerView) => layerView.reset());
        },
        update: function() {
          if (this._background) {
            this.updateBackgroundImage(this._background);
          }
          return this;
        },
        scale: function(sx, sy, data2) {
          const ctm = this.matrix();
          if (sx === void 0) {
            return V2.matrixToScale(ctm);
          }
          if (sy === void 0) {
            sy = sx;
          }
          sx = Math.max(sx || 0, this.MIN_SCALE);
          sy = Math.max(sy || 0, this.MIN_SCALE);
          ctm.a = sx;
          ctm.d = sy;
          this.matrix(ctm, data2);
          return this;
        },
        scaleUniformAtPoint: function(scale2, point2, data2) {
          const {
            a: sx,
            d: sy,
            e: tx,
            f: ty
          } = this.matrix();
          scale2 = Math.max(scale2 || 0, this.MIN_SCALE);
          if (scale2 === sx && scale2 === sy) {
            return this;
          }
          const matrix = V2.createSVGMatrix().translate(tx - point2.x * (scale2 - sx), ty - point2.y * (scale2 - sy)).scale(scale2, scale2);
          this.matrix(matrix, data2);
          return this;
        },
        translate: function(tx, ty, data2) {
          const ctm = this.matrix();
          if (tx === void 0) {
            return V2.matrixToTranslate(ctm);
          }
          tx || (tx = 0);
          ty || (ty = 0);
          if (ctm.e === tx && ctm.f === ty) return this;
          ctm.e = tx;
          ctm.f = ty;
          this.matrix(ctm, data2);
          return this;
        },
        matrix: function(ctm, data2 = {}) {
          var viewport = this.layers;
          if (ctm === void 0) {
            var transformString = viewport.getAttribute("transform");
            if ((this._viewportTransformString || null) === transformString) {
              ctm = this._viewportMatrix;
            } else {
              ctm = viewport.getCTM();
              this._viewportMatrix = ctm;
              this._viewportTransformString = transformString;
            }
            return V2.createSVGMatrix(ctm);
          }
          const prev = this.matrix();
          const current = V2.createSVGMatrix(ctm);
          const currentTransformString = this._viewportTransformString;
          const ctmString = V2.matrixToTransformString(current);
          if (ctmString === currentTransformString) {
            return this;
          }
          if (!currentTransformString && V2.matrixToTransformString() === ctmString) {
            return this;
          }
          const {
            a,
            d,
            e,
            f: f2
          } = current;
          viewport.setAttribute("transform", ctmString);
          this._viewportMatrix = current;
          this._viewportTransformString = viewport.getAttribute("transform");
          if (a !== prev.a || d !== prev.d) {
            this.trigger("scale", a, d, data2);
          }
          if (e !== prev.e || f2 !== prev.f) {
            this.trigger("translate", e, f2, data2);
          }
          this.trigger("transform", current, data2);
          return this;
        },
        clientMatrix: function() {
          return V2.createSVGMatrix(this.layers.getScreenCTM());
        },
        requestConnectedLinksUpdate: function(view, priority, opt) {
          if (!view || !view[CELL_VIEW_MARKER]) return;
          const model = view.model;
          const links = this.model.getConnectedLinks(model);
          for (let j = 0, n = links.length; j < n; j++) {
            const link = links[j];
            const linkView = this._getCellViewLike(link);
            if (!linkView) continue;
            if (linkView[CELL_VIEW_PLACEHOLDER_MARKER]) continue;
            const flagLabels = [LinkView.Flags.UPDATE];
            if (link.getTargetCell() === model) flagLabels.push(LinkView.Flags.TARGET);
            if (link.getSourceCell() === model) flagLabels.push(LinkView.Flags.SOURCE);
            const nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);
            this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);
          }
        },
        forcePostponedViewUpdate: function(view, flag) {
          if (!view || !view[CELL_VIEW_MARKER]) return false;
          const model = view.model;
          if (model.isElement()) return false;
          const dumpOptions = {
            silent: true
          };
          let sourceFlag = 0;
          const sourceCell = model.getSourceCell();
          if (sourceCell && !this.isCellVisible(sourceCell)) {
            const sourceView = this.findViewByModel(sourceCell);
            sourceFlag = this.dumpView(sourceView, dumpOptions);
          }
          let targetFlag = 0;
          const targetCell = model.getTargetCell();
          if (targetCell && !this.isCellVisible(targetCell)) {
            const targetView = this.findViewByModel(targetCell);
            targetFlag = this.dumpView(targetView, dumpOptions);
          }
          if (sourceFlag === 0 && targetFlag === 0) {
            return !this.dumpView(view, dumpOptions);
          }
          return false;
        },
        requestViewUpdate: function(view, flag, priority, opt) {
          opt || (opt = {});
          this.scheduleViewUpdate(view, flag, priority, opt);
          var isAsync = this.isAsync();
          if (this.isFrozen() || isAsync && opt.async !== false) return;
          if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;
          var stats = this.updateViews(opt);
          if (isAsync) this.notifyAfterRender(stats, opt);
        },
        scheduleViewUpdate: function(view, type, priority, opt) {
          const {
            _updates: updates,
            options
          } = this;
          if (updates.idle && options.autoFreeze) {
            this.legacyMode ? this.unfreeze() : this.wakeUp();
          }
          const {
            FLAG_REMOVE,
            FLAG_INSERT
          } = this;
          const {
            UPDATE_PRIORITY,
            cid
          } = view;
          let priorityUpdates = updates.priorities[priority];
          if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};
          if (priority > UPDATE_PRIORITY) {
            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {
              const prevPriorityUpdates = updates.priorities[i];
              if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;
              priorityUpdates[cid] |= prevPriorityUpdates[cid];
              delete prevPriorityUpdates[cid];
            }
          }
          let currentType = priorityUpdates[cid] || 0;
          if ((currentType & type) === type) return;
          if (!currentType) updates.count++;
          if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {
            priorityUpdates[cid] ^= FLAG_INSERT;
          } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {
            priorityUpdates[cid] ^= FLAG_REMOVE;
          }
          priorityUpdates[cid] |= type;
          const viewUpdateFn = options.onViewUpdate;
          if (typeof viewUpdateFn === "function") viewUpdateFn.call(this, view, type, priority, opt || {}, this);
        },
        dumpViewUpdate: function(view) {
          if (!view) return 0;
          var updates = this._updates;
          var cid = view.cid;
          var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];
          var flag = this.registerMountedView(view) | priorityUpdates[cid];
          delete priorityUpdates[cid];
          return flag;
        },
        dumpView: function(view, opt = {}) {
          const flag = this.dumpViewUpdate(view);
          if (!flag) return 0;
          this.notifyBeforeRender(opt);
          const leftover = this.updateView(view, flag, opt);
          const stats = {
            updated: 1,
            priority: view.UPDATE_PRIORITY
          };
          this.notifyAfterRender(stats, opt);
          return leftover;
        },
        updateView: function(view, flag, opt) {
          if (!view) return 0;
          const {
            FLAG_REMOVE,
            FLAG_INSERT,
            FLAG_INIT
          } = this;
          const {
            model
          } = view;
          if (view[GRAPH_LAYER_VIEW_MARKER]) {
            if (flag & FLAG_REMOVE) {
              this.removeLayerView(view);
              return 0;
            }
          }
          if (view[CELL_VIEW_MARKER]) {
            if (flag & FLAG_REMOVE) {
              this.removeView(model);
              return 0;
            }
            if (flag & FLAG_INSERT) {
              const isInitialInsert = !!(flag & FLAG_INIT);
              if (isInitialInsert) {
                flag ^= FLAG_INIT;
              }
              this.insertView(view, isInitialInsert);
              flag ^= FLAG_INSERT;
            }
          }
          if (!flag) return 0;
          return view.confirmUpdate(flag, opt || {});
        },
        requireView: function(model, opt) {
          var view = this.findViewByModel(model);
          if (!view) return null;
          this.dumpView(view, opt);
          return view;
        },
        registerUnmountedView: function(view) {
          var cid = view.cid;
          var updates = this._updates;
          if (updates.unmountedList.has(cid)) return 0;
          const flag = this.FLAG_INSERT;
          updates.unmountedList.pushTail(cid, flag);
          updates.mountedList.delete(cid);
          return flag;
        },
        registerMountedView: function(view) {
          var cid = view.cid;
          var updates = this._updates;
          if (updates.mountedList.has(cid)) return 0;
          const unmountedItem = updates.unmountedList.get(cid);
          const flag = unmountedItem ? unmountedItem.value : 0;
          updates.unmountedList.delete(cid);
          updates.mountedList.pushTail(cid);
          return flag;
        },
        isCellVisible: function(cellOrId) {
          const cid = cellOrId && this._idToCid[cellOrId.id || cellOrId];
          if (!cid) return false;
          return this.isViewMounted(cid);
        },
        isViewMounted: function(viewOrCid) {
          if (!viewOrCid) return false;
          let cid;
          if (viewOrCid[CELL_VIEW_MARKER] || viewOrCid[CELL_VIEW_PLACEHOLDER_MARKER]) {
            cid = viewOrCid.cid;
          } else {
            cid = viewOrCid;
          }
          return this._updates.mountedList.has(cid);
        },
        /**
         * @deprecated use `updateCellsVisibility` instead.
         * `paper.updateCellsVisibility({ cellVisibility: () => true });`
         */
        dumpViews: function(opt) {
          const passingOpt = defaults({}, opt, {
            cellVisibility: null,
            viewport: null
          });
          this.updateCellsVisibility(passingOpt);
        },
        /**
         * Process all scheduled updates synchronously.
         */
        updateViews: function(opt = {}) {
          this.notifyBeforeRender(opt);
          const batchStats = this.updateViewsBatch({
            ...opt,
            batchSize: Infinity
          });
          const stats = {
            updated: batchStats.updated,
            priority: batchStats.priority,
            // For backward compatibility. Will be removed in the future.
            batches: Number.isFinite(opt.batchSize) ? Math.ceil(batchStats.updated / opt.batchSize) : 1
          };
          this.notifyAfterRender(stats, opt);
          return stats;
        },
        hasScheduledUpdates: function() {
          const updates = this._updates;
          const priorities = updates.priorities;
          const priorityIndexes = Object.keys(priorities);
          let i = priorityIndexes.length;
          while (i > 0 && i--) {
            for (let _key in priorities[priorityIndexes[i]]) return true;
          }
          return false;
        },
        updateViewsAsync: function(opt, data2) {
          opt || (opt = {});
          data2 || (data2 = {
            processed: 0,
            priority: MIN_PRIORITY,
            checkedUnmounted: 0,
            checkedMounted: 0
          });
          const {
            _updates: updates,
            options
          } = this;
          const {
            id: id2,
            mountedList,
            unmountedList,
            freshAfterReset
          } = updates;
          let runBatchUpdate = true;
          if (!id2) {
            runBatchUpdate = false;
          } else {
            cancelFrame(id2);
            if (freshAfterReset) {
              updates.freshAfterReset = false;
              if (!this.legacyMode && mountedList.length === 0 && unmountedList.length === 0) {
                this.updateViews();
                runBatchUpdate = false;
              }
            }
          }
          if (runBatchUpdate) {
            if (data2.processed === 0 && this.hasScheduledUpdates()) {
              this.notifyBeforeRender(opt);
            }
            const stats = this.updateViewsBatch(opt);
            const passingOpt = defaults({}, opt, {
              mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,
              unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted
            });
            const checkStats = this.scheduleCellsVisibilityUpdate(passingOpt);
            const unmountCount = checkStats.unmounted;
            const mountCount = checkStats.mounted;
            let processed = data2.processed;
            const total = updates.count;
            if (stats.updated > 0) {
              processed += stats.updated + stats.unmounted;
              stats.processed = processed;
              data2.priority = Math.min(stats.priority, data2.priority);
              if (stats.empty && mountCount === 0) {
                stats.unmounted += unmountCount;
                stats.mounted += mountCount;
                stats.priority = data2.priority;
                this.notifyAfterRender(stats, opt);
                data2.processed = 0;
                data2.priority = MIN_PRIORITY;
                updates.count = 0;
              } else {
                data2.processed = processed;
              }
              data2.checkedUnmounted = 0;
              data2.checkedMounted = 0;
            } else {
              data2.checkedUnmounted += Math.max(passingOpt.mountBatchSize, 0);
              data2.checkedMounted += Math.max(passingOpt.unmountBatchSize, 0);
              if (options.autoFreeze && !this.hasScheduledUpdates()) {
                if (data2.checkedUnmounted >= unmountedList.length && data2.checkedMounted >= mountedList.length) {
                  this.freeze();
                  updates.idle = {
                    wakeUpOptions: opt
                  };
                  this.trigger("render:idle", opt);
                }
              }
            }
            const progressFn = opt.progress;
            if (total && typeof progressFn === "function") {
              progressFn.call(this, stats.empty, processed, total, stats, this);
            }
            if (updates.id !== id2) return;
          }
          if (updates.disabled) {
            throw new Error("dia.Paper: can not unfreeze the paper after it was removed");
          }
          updates.id = nextFrame(this.updateViewsAsync, this, opt, data2);
        },
        notifyBeforeRender: function(opt = {}) {
          if (opt.silent) return;
          let beforeFn = opt.beforeRender;
          if (typeof beforeFn !== "function") {
            beforeFn = this.options.beforeRender;
            if (typeof beforeFn !== "function") return;
          }
          beforeFn.call(this, opt, this);
        },
        notifyAfterRender: function(stats, opt = {}) {
          if (opt.silent) return;
          let afterFn = opt.afterRender;
          if (typeof afterFn !== "function") {
            afterFn = this.options.afterRender;
          }
          if (typeof afterFn === "function") {
            afterFn.call(this, stats, opt, this);
          }
          this.trigger("render:done", stats, opt);
        },
        prioritizeCellViewMount: function(cellOrId) {
          if (!cellOrId) return false;
          const cid = this._idToCid[cellOrId.id || cellOrId];
          if (!cid) return false;
          const {
            unmountedList
          } = this._updates;
          if (!unmountedList.has(cid)) return false;
          unmountedList.moveToHead(cid);
          return true;
        },
        prioritizeCellViewUnmount: function(cellOrId) {
          if (!cellOrId) return false;
          const cid = this._idToCid[cellOrId.id || cellOrId];
          if (!cid) return false;
          const {
            mountedList
          } = this._updates;
          if (!mountedList.has(cid)) return false;
          mountedList.moveToHead(cid);
          return true;
        },
        _evalCellVisibility: function(viewLike, isMounted, visibilityCallback) {
          if (!visibilityCallback || !viewLike.DETACHABLE) return true;
          if (this.legacyMode) {
            return visibilityCallback.call(this, viewLike, isMounted, this);
          }
          if (!viewLike[CELL_VIEW_MARKER] && !viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) return true;
          if (viewLike.model.graph !== this.model) {
            return isMounted;
          }
          return visibilityCallback.call(this, viewLike.model, isMounted, this);
        },
        _getCellVisibilityCallback: function(opt) {
          const {
            options
          } = this;
          if (this.legacyMode) {
            const viewportFn = "viewport" in opt ? opt.viewport : options.viewport;
            if (typeof viewportFn === "function") return viewportFn;
          } else {
            const isVisibleFn = "cellVisibility" in opt ? opt.cellVisibility : options.cellVisibility;
            if (typeof isVisibleFn === "function") return isVisibleFn;
          }
          return null;
        },
        updateViewsBatch: function(opt) {
          opt || (opt = {});
          var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;
          var updates = this._updates;
          var updateCount = 0;
          var postponeCount = 0;
          var unmountCount = 0;
          var mountCount = 0;
          var maxPriority = MIN_PRIORITY;
          var empty2 = true;
          var options = this.options;
          var priorities = updates.priorities;
          const visibilityCb = this._getCellVisibilityCallback(opt);
          var postponeViewFn = options.onViewPostponed;
          if (typeof postponeViewFn !== "function") postponeViewFn = null;
          var priorityIndexes = Object.keys(priorities);
          main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {
            var priority = +priorityIndexes[i];
            var priorityUpdates = priorities[priority];
            for (var cid in priorityUpdates) {
              if (updateCount >= batchSize) {
                empty2 = false;
                break main;
              }
              var view = views[cid];
              if (!view) {
                view = this._viewPlaceholders[cid];
                if (!view) {
                  delete priorityUpdates[cid];
                  continue;
                }
              }
              var currentFlag = priorityUpdates[cid];
              if ((currentFlag & this.FLAG_REMOVE) === 0) {
                const isMounted = !updates.unmountedList.has(cid);
                if (!this._evalCellVisibility(view, isMounted, visibilityCb)) {
                  if (isMounted) {
                    this.registerUnmountedView(view);
                    this._hideView(view);
                  } else {
                    this._mergeUnmountedViewScheduledUpdates(cid, currentFlag);
                  }
                  delete priorityUpdates[cid];
                  unmountCount++;
                  continue;
                }
                if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {
                  view = this._resolveCellViewPlaceholder(view);
                  currentFlag |= this.getCellViewInitFlag(view);
                }
                if (!isMounted) {
                  currentFlag |= this.FLAG_INSERT;
                  mountCount++;
                }
                currentFlag |= this.registerMountedView(view);
              } else if (view[CELL_VIEW_PLACEHOLDER_MARKER]) {
                continue;
              }
              var leftoverFlag = this.updateView(view, currentFlag, opt);
              if (leftoverFlag > 0) {
                priorityUpdates[cid] = leftoverFlag;
                if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {
                  postponeCount++;
                  empty2 = false;
                  continue;
                }
              }
              if (maxPriority > priority) maxPriority = priority;
              updateCount++;
              delete priorityUpdates[cid];
            }
          }
          return {
            priority: maxPriority,
            updated: updateCount,
            postponed: postponeCount,
            unmounted: unmountCount,
            mounted: mountCount,
            empty: empty2
          };
        },
        getCellViewInitFlag: function(cellView) {
          return this.FLAG_INIT | cellView.getFlag(result(cellView, "initFlag"));
        },
        /**
         * @ignore This method returns an array of cellViewLike objects and therefore
         * is meant for internal/test use only.
         * The view placeholders are not exposed via public API.
        */
        getUnmountedViews: function() {
          const updates = this._updates;
          const unmountedViews = new Array(updates.unmountedList.length);
          const unmountedCids = updates.unmountedList.keys();
          let i = 0;
          for (const cid of unmountedCids) {
            unmountedViews[i++] = views[cid] || this._viewPlaceholders[cid];
          }
          return unmountedViews;
        },
        /**
         * @ignore This method returns an array of cellViewLike objects and therefore
         * is meant for internal/test use only.
         * The view placeholders are not exposed via public API.
         */
        getMountedViews: function() {
          const updates = this._updates;
          const mountedViews = new Array(updates.mountedList.length);
          const mountedCids = updates.mountedList.keys();
          let i = 0;
          for (const cid of mountedCids) {
            mountedViews[i++] = views[cid] || this._viewPlaceholders[cid];
          }
          return mountedViews;
        },
        checkUnmountedViews: function(visibilityCb, opt) {
          opt || (opt = {});
          var mountCount = 0;
          if (typeof visibilityCb !== "function") visibilityCb = null;
          var batchSize = "mountBatchSize" in opt ? opt.mountBatchSize : Infinity;
          var updates = this._updates;
          var unmountedList = updates.unmountedList;
          for (var i = 0, n = Math.min(unmountedList.length, batchSize); i < n; i++) {
            const {
              key: cid
            } = unmountedList.peekHead();
            let view = views[cid] || this._viewPlaceholders[cid];
            if (!view) {
              unmountedList.popHead();
              continue;
            }
            if (!this._evalCellVisibility(view, false, visibilityCb)) {
              unmountedList.rotate();
              continue;
            }
            const {
              value: prevFlag
            } = unmountedList.popHead();
            mountCount++;
            const flag = this.registerMountedView(view) | prevFlag;
            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, {
              mounting: true
            });
          }
          return mountCount;
        },
        checkMountedViews: function(visibilityCb, opt) {
          opt || (opt = {});
          var unmountCount = 0;
          if (typeof visibilityCb !== "function") return unmountCount;
          var batchSize = "unmountBatchSize" in opt ? opt.unmountBatchSize : Infinity;
          var updates = this._updates;
          const mountedList = updates.mountedList;
          for (var i = 0, n = Math.min(mountedList.length, batchSize); i < n; i++) {
            const {
              key: cid
            } = mountedList.peekHead();
            const view = views[cid];
            if (!view) {
              mountedList.popHead();
              continue;
            }
            if (this._evalCellVisibility(view, true, visibilityCb)) {
              mountedList.rotate();
              continue;
            }
            mountedList.popHead();
            unmountCount++;
            var flag = this.registerUnmountedView(view);
            if (flag) {
              this._hideView(view);
            }
          }
          return unmountCount;
        },
        checkViewVisibility: function(cellView, opt = {}) {
          const visibilityCb = this._getCellVisibilityCallback(opt);
          const updates = this._updates;
          const {
            mountedList,
            unmountedList
          } = updates;
          const visible = this._evalCellVisibility(cellView, false, visibilityCb);
          let isUnmounted = false;
          let isMounted = false;
          if (mountedList.has(cellView.cid) && !visible) {
            const flag = this.registerUnmountedView(cellView);
            if (flag) this._hideView(cellView);
            mountedList.delete(cellView.cid);
            isUnmounted = true;
          }
          if (!isUnmounted && unmountedList.has(cellView.cid) && visible) {
            const unmountedItem = unmountedList.get(cellView.cid);
            unmountedList.delete(cellView.cid);
            const flag = unmountedItem.value | this.registerMountedView(cellView);
            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
              mounting: true
            });
            isMounted = true;
          }
          return {
            mounted: isMounted ? 1 : 0,
            unmounted: isUnmounted ? 1 : 0
          };
        },
        /**
         * @public
         * Update the visibility of a single cell.
         */
        updateCellVisibility: function(cell, opt = {}) {
          const cellViewLike = this._getCellViewLike(cell);
          if (!cellViewLike) return;
          const stats = this.checkViewVisibility(cellViewLike, opt);
          if (stats.mounted > 0) {
            this.requireView(cell, opt);
          }
        },
        /**
         * @public
         * Update the visibility of all cells.
         */
        updateCellsVisibility: function(opt = {}) {
          this.scheduleCellsVisibilityUpdate(opt);
          const keepCurrentVisibility = (_, isVisible) => isVisible;
          this.updateViews({
            ...opt,
            cellVisibility: keepCurrentVisibility
          });
        },
        /**
         * @protected
         * Run visibility checks for all cells and schedule their updates.
         */
        scheduleCellsVisibilityUpdate(opt) {
          const passingOpt = defaults({}, opt, {
            mountBatchSize: Infinity,
            unmountBatchSize: Infinity
          });
          const visibilityCb = this._getCellVisibilityCallback(passingOpt);
          const unmountedCount = this.checkMountedViews(visibilityCb, passingOpt);
          if (unmountedCount > 0) {
            var unmountedList = this._updates.unmountedList;
            passingOpt.mountBatchSize = Math.min(unmountedList.length - unmountedCount, passingOpt.mountBatchSize);
          }
          const mountedCount = this.checkUnmountedViews(visibilityCb, passingOpt);
          return {
            mounted: mountedCount,
            unmounted: unmountedCount
          };
        },
        /**
         * @deprecated use `updateCellsVisibility` instead
         * This method will be renamed and made private in the future.
         */
        checkViewport: function(opt) {
          return this.scheduleCellsVisibilityUpdate(opt);
        },
        freeze: function(opt) {
          opt || (opt = {});
          var updates = this._updates;
          var key = opt.key;
          var isFrozen = this.options.frozen;
          var freezeKey = updates.freezeKey;
          if (key && key !== freezeKey) {
            if (isFrozen && freezeKey) return;
            updates.freezeKey = key;
            updates.keyFrozen = isFrozen;
          }
          this.options.frozen = true;
          var id2 = updates.id;
          updates.id = null;
          if (!this.legacyMode) {
            updates.idle = false;
          }
          if (this.isAsync() && id2) cancelFrame(id2);
        },
        unfreeze: function(opt) {
          opt || (opt = {});
          var updates = this._updates;
          var key = opt.key;
          var freezeKey = updates.freezeKey;
          if (key && freezeKey && key !== freezeKey) return;
          updates.freezeKey = null;
          if (key && key === freezeKey && updates.keyFrozen) return;
          updates.idle = false;
          if (this.isAsync()) {
            this.freeze();
            this.updateViewsAsync(opt);
          } else {
            this.updateViews(opt);
          }
          this.options.frozen = updates.keyFrozen = false;
          if (updates.sort) {
            this.sortLayerViews();
            updates.sort = false;
          }
        },
        wakeUp: function() {
          if (!this.isIdle()) return;
          this.unfreeze(this._updates.idle.wakeUpOptions);
        },
        isAsync: function() {
          return !!this.options.async;
        },
        isFrozen: function() {
          return !!this.options.frozen && !this.isIdle();
        },
        isIdle: function() {
          if (this.legacyMode) {
            return false;
          }
          return !!(this._updates && this._updates.idle);
        },
        isExactSorting: function() {
          return this.options.sorting === sortingTypes.EXACT;
        },
        onRemove: function() {
          this.freeze();
          this._updates.disabled = true;
          this.removeViews();
          this._removeLayerViews();
        },
        getComputedSize: function() {
          var options = this.options;
          var w = options.width;
          var h = options.height;
          if (!isNumber(w)) w = this.el.clientWidth;
          if (!isNumber(h)) h = this.el.clientHeight;
          return {
            width: w,
            height: h
          };
        },
        setDimensions: function(width2, height2, data2 = {}) {
          const {
            options
          } = this;
          const {
            width: currentWidth,
            height: currentHeight
          } = options;
          let w = width2 === void 0 ? currentWidth : width2;
          let h = height2 === void 0 ? currentHeight : height2;
          if (currentWidth === w && currentHeight === h) return;
          options.width = w;
          options.height = h;
          this._setDimensions();
          const computedSize = this.getComputedSize();
          this.trigger("resize", computedSize.width, computedSize.height, data2);
        },
        _setDimensions: function() {
          const {
            options
          } = this;
          let w = options.width;
          let h = options.height;
          if (isNumber(w)) w = `${Math.round(w)}px`;
          if (isNumber(h)) h = `${Math.round(h)}px`;
          this.$el.css({
            width: w === null ? "" : w,
            height: h === null ? "" : h
          });
        },
        // Expand/shrink the paper to fit the content.
        // Alternatively signature function(opt)
        fitToContent: function(gridWidth, gridHeight, padding, opt) {
          if (isObject(gridWidth)) {
            opt = gridWidth;
          } else {
            opt = assign({
              gridWidth,
              gridHeight,
              padding
            }, opt);
          }
          const {
            x,
            y,
            width: width2,
            height: height2
          } = this.getFitToContentArea(opt);
          const {
            sx,
            sy
          } = this.scale();
          this.translate(-x * sx, -y * sy, opt);
          this.setDimensions(width2 * sx, height2 * sy, opt);
          return new Rect(x, y, width2, height2);
        },
        getFitToContentArea: function(opt = {}) {
          const gridWidth = opt.gridWidth || 1;
          const gridHeight = opt.gridHeight || 1;
          const padding = normalizeSides(opt.padding || 0);
          const minWidth = Math.max(opt.minWidth || 0, gridWidth);
          const minHeight = Math.max(opt.minHeight || 0, gridHeight);
          const maxWidth = opt.maxWidth || Number.MAX_VALUE;
          const maxHeight = opt.maxHeight || Number.MAX_VALUE;
          const newOrigin = opt.allowNewOrigin;
          const area = "contentArea" in opt ? new Rect(opt.contentArea) : this.getContentArea(opt);
          const {
            sx,
            sy
          } = this.scale();
          area.x *= sx;
          area.y *= sy;
          area.width *= sx;
          area.height *= sy;
          let calcWidth = Math.ceil((area.width + area.x) / gridWidth);
          let calcHeight = Math.ceil((area.height + area.y) / gridHeight);
          if (!opt.allowNegativeBottomRight) {
            calcWidth = Math.max(calcWidth, 1);
            calcHeight = Math.max(calcHeight, 1);
          }
          calcWidth *= gridWidth;
          calcHeight *= gridHeight;
          let tx = 0;
          if (newOrigin === "negative" && area.x < 0 || newOrigin === "positive" && area.x >= 0 || newOrigin === "any") {
            tx = Math.ceil(-area.x / gridWidth) * gridWidth;
            tx += padding.left;
            calcWidth += tx;
          }
          let ty = 0;
          if (newOrigin === "negative" && area.y < 0 || newOrigin === "positive" && area.y >= 0 || newOrigin === "any") {
            ty = Math.ceil(-area.y / gridHeight) * gridHeight;
            ty += padding.top;
            calcHeight += ty;
          }
          calcWidth += padding.right;
          calcHeight += padding.bottom;
          calcWidth = Math.max(calcWidth, minWidth);
          calcHeight = Math.max(calcHeight, minHeight);
          calcWidth = Math.min(calcWidth, maxWidth);
          calcHeight = Math.min(calcHeight, maxHeight);
          return new Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);
        },
        transformToFitContent: function(opt) {
          opt || (opt = {});
          let contentBBox, contentLocalOrigin;
          if ("contentArea" in opt) {
            const contentArea = opt.contentArea;
            contentBBox = this.localToPaperRect(contentArea);
            contentLocalOrigin = new Point(contentArea);
          } else {
            contentBBox = this.getContentBBox(opt);
            contentLocalOrigin = this.paperToLocalPoint(contentBBox);
          }
          if (!contentBBox.width || !contentBBox.height) return;
          defaults(opt, {
            padding: 0,
            preserveAspectRatio: true,
            scaleGrid: null,
            minScale: 0,
            maxScale: Number.MAX_VALUE,
            verticalAlign: "top",
            horizontalAlign: "left"
            //minScaleX
            //minScaleY
            //maxScaleX
            //maxScaleY
            //fittingBBox
          });
          const padding = normalizeSides(opt.padding);
          const minScaleX = opt.minScaleX || opt.minScale;
          const maxScaleX = opt.maxScaleX || opt.maxScale;
          const minScaleY = opt.minScaleY || opt.minScale;
          const maxScaleY = opt.maxScaleY || opt.maxScale;
          let fittingBBox;
          if (opt.fittingBBox) {
            fittingBBox = opt.fittingBBox;
          } else {
            const currentTranslate = this.translate();
            const computedSize = this.getComputedSize();
            fittingBBox = {
              x: currentTranslate.tx,
              y: currentTranslate.ty,
              width: computedSize.width,
              height: computedSize.height
            };
          }
          fittingBBox = new Rect(fittingBBox).moveAndExpand({
            x: padding.left,
            y: padding.top,
            width: -padding.left - padding.right,
            height: -padding.top - padding.bottom
          });
          const ctm = this.matrix();
          const {
            a: sx,
            d: sy,
            e: tx,
            f: ty
          } = ctm;
          let newSx = fittingBBox.width / contentBBox.width * sx;
          let newSy = fittingBBox.height / contentBBox.height * sy;
          if (opt.preserveAspectRatio) {
            newSx = newSy = Math.min(newSx, newSy);
          }
          if (opt.scaleGrid) {
            const gridSize = opt.scaleGrid;
            newSx = gridSize * Math.floor(newSx / gridSize);
            newSy = gridSize * Math.floor(newSy / gridSize);
          }
          newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));
          newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));
          const scaleDiff = {
            x: newSx / sx,
            y: newSy / sy
          };
          let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;
          let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;
          switch (opt.verticalAlign) {
            case "middle":
              newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;
              break;
            case "bottom":
              newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);
              break;
            case "top":
            default:
              break;
          }
          switch (opt.horizontalAlign) {
            case "middle":
              newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;
              break;
            case "right":
              newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);
              break;
            case "left":
            default:
              break;
          }
          ctm.a = newSx;
          ctm.d = newSy;
          ctm.e = newOx;
          ctm.f = newOy;
          this.matrix(ctm, opt);
        },
        scaleContentToFit: function(opt) {
          this.transformToFitContent(opt);
        },
        // Return the dimensions of the content area in local units (without transformations).
        getContentArea: function(opt) {
          if (opt && opt.useModelGeometry) {
            return this.model.getBBox() || new Rect();
          }
          const graphLayerViews = this.getGraphLayerViews();
          if (graphLayerViews.length === 0) {
            return new Rect();
          }
          const bbox2 = Rect.fromRectUnion(...graphLayerViews.map((view) => view.vel.getBBox()));
          return bbox2;
        },
        // Return the dimensions of the content bbox in the paper units (as it appears on screen).
        getContentBBox: function(opt) {
          return this.localToPaperRect(this.getContentArea(opt));
        },
        // Returns a geometry rectangle representing the entire
        // paper area (coordinates from the left paper border to the right one
        // and the top border to the bottom one).
        getArea: function() {
          return this.paperToLocalRect(this.getComputedSize());
        },
        getRestrictedArea: function(...args) {
          const {
            restrictTranslate
          } = this.options;
          let restrictedArea;
          if (isFunction(restrictTranslate)) {
            restrictedArea = restrictTranslate.apply(this, args);
          } else if (restrictTranslate === true) {
            restrictedArea = this.getArea();
          } else if (!restrictTranslate) {
            restrictedArea = null;
          } else {
            restrictedArea = new Rect(restrictTranslate);
          }
          return restrictedArea;
        },
        _resolveCellViewPlaceholder: function(placeholder) {
          const {
            model,
            viewClass,
            cid
          } = placeholder;
          const view = this._initializeCellView(viewClass, model, cid);
          this._registerCellView(view);
          this._unregisterCellViewPlaceholder(placeholder);
          return view;
        },
        _registerCellViewPlaceholder: function(cell, cid = uniqueId("view")) {
          const ViewClass = this._resolveCellViewClass(cell);
          const placeholder = {
            // A tag to identify the placeholder from a CellView.
            [CELL_VIEW_PLACEHOLDER_MARKER]: true,
            cid,
            model: cell,
            DETACHABLE: true,
            viewClass: ViewClass,
            UPDATE_PRIORITY: ViewClass.prototype.UPDATE_PRIORITY
          };
          this._viewPlaceholders[cid] = placeholder;
          return placeholder;
        },
        _registerCellView: function(cellView) {
          cellView.paper = this;
          this._views[cellView.model.id] = cellView;
        },
        _unregisterCellViewPlaceholder: function(placeholder) {
          delete this._viewPlaceholders[placeholder.cid];
        },
        _initializeCellView: function(ViewClass, cell, cid) {
          const {
            options
          } = this;
          const {
            interactive,
            labelsLayer
          } = options;
          return new ViewClass({
            cid,
            model: cell,
            interactive,
            labelsLayer: labelsLayer === true ? paperLayers.LABELS : labelsLayer
          });
        },
        _resolveCellViewClass: function(cell) {
          const {
            options
          } = this;
          const {
            cellViewNamespace
          } = options;
          const type = cell.get("type") + "View";
          const namespaceViewClass = getByPath(cellViewNamespace, type, ".");
          let optionalViewClass;
          let defaultViewClass;
          if (cell.isLink()) {
            optionalViewClass = options.linkView;
            defaultViewClass = LinkView;
          } else {
            optionalViewClass = options.elementView;
            defaultViewClass = ElementView;
          }
          return optionalViewClass.prototype instanceof ViewBase ? namespaceViewClass || optionalViewClass : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;
        },
        // Returns a CellView instance or its placeholder for the given cell.
        _getCellViewLike: function(cell) {
          let id2;
          if (isString(cell) || isNumber(cell)) {
            id2 = cell;
          } else if (cell) {
            id2 = cell.id;
          } else {
            return null;
          }
          const view = this._views[id2];
          if (view) return view;
          const cid = this._idToCid[id2];
          if (cid) {
            return this._viewPlaceholders[cid];
          }
          return null;
        },
        createViewForModel: function(cell, cid) {
          return this._initializeCellView(this._resolveCellViewClass(cell), cell, cid);
        },
        removeView: function(cell) {
          const {
            id: id2
          } = cell;
          const {
            _views,
            _updates
          } = this;
          const view = _views[id2];
          if (view) {
            var {
              cid
            } = view;
            const {
              mountedList,
              unmountedList
            } = _updates;
            view.remove();
            delete _views[id2];
            delete this._idToCid[id2];
            mountedList.delete(cid);
            unmountedList.delete(cid);
          }
          return view;
        },
        renderView: function(cell, opt) {
          const {
            id: id2
          } = cell;
          const views2 = this._views;
          let view, flag;
          let create = true;
          if (id2 in views2) {
            view = views2[id2];
            if (view.model === cell) {
              flag = this.FLAG_INSERT;
              create = false;
            } else {
              this.removeView(cell);
            }
          }
          if (create) {
            const {
              viewManagement
            } = this.options;
            const cid = uniqueId("view");
            this._idToCid[cell.id] = cid;
            if (viewManagement.lazyInitialize) {
              view = this._registerCellViewPlaceholder(cell, cid);
              flag = this.registerUnmountedView(view);
            } else {
              view = this.createViewForModel(cell, cid);
              this._registerCellView(view);
              flag = this.registerUnmountedView(view);
              flag |= this.getCellViewInitFlag(view);
            }
            if (viewManagement.initializeUnmounted) {
              this._mergeUnmountedViewScheduledUpdates(cid, flag);
              return view;
            }
          }
          this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);
          return view;
        },
        // Update the view flags in the `unmountedList` using the bitwise OR operation
        _mergeUnmountedViewScheduledUpdates: function(cid, flag) {
          const {
            unmountedList
          } = this._updates;
          const unmountedItem = unmountedList.get(cid);
          if (unmountedItem) {
            unmountedItem.value |= flag;
          }
        },
        onImageDragStart: function() {
          return false;
        },
        resetViews: function(cells, opt) {
          opt || (opt = {});
          cells || (cells = []);
          const key = (this.legacyMode ? this.options.autoFreeze : this.isIdle()) ? null : "reset";
          this._resetUpdates();
          this.removeViews();
          this.freeze({
            key
          });
          for (var i = 0, n = cells.length; i < n; i++) {
            this.renderView(cells[i], opt);
          }
          this.unfreeze({
            key
          });
          this.sortLayerViews();
        },
        removeViews: function() {
          for (const id2 in this._views) {
            const view = this._views[id2];
            if (view) {
              view.remove();
            }
          }
          this._views = {};
          this._viewPlaceholders = {};
          this._idToCid = {};
        },
        sortLayerViews: function() {
          if (!this.isExactSorting()) {
            return;
          }
          if (this.isFrozen() || this.isIdle()) {
            this._updates.sort = true;
            return;
          }
          this.sortLayerViewsExact();
        },
        sortLayerViewsExact: function() {
          this.getGraphLayerViews().forEach((view) => view.sortExact());
        },
        insertView: function(view, isInitialInsert) {
          const layerId = this.model.getCellLayerId(view.model);
          const layerView = this.getLayerView(layerId);
          layerView.insertCellView(view);
          view.onMount(isInitialInsert);
        },
        _hideView: function(viewLike) {
          if (!viewLike || viewLike[CELL_VIEW_PLACEHOLDER_MARKER]) {
            return;
          }
          if (viewLike[CELL_VIEW_MARKER]) {
            this._hideCellView(viewLike);
          } else {
            viewLike.unmount();
          }
        },
        // If `cellVisibility` returns `false`, the view will be hidden using this method.
        _hideCellView: function(cellView) {
          if (this.options.viewManagement.disposeHidden) {
            if (this._disposeCellView(cellView)) return;
          }
          this._detachCellView(cellView);
        },
        _disposeCellView: function(cellView) {
          if (HighlighterView.has(cellView) || cellView.hasTools()) {
            return false;
          }
          const cell = cellView.model;
          cellView.remove();
          delete this._views[cell.id];
          this._registerCellViewPlaceholder(cell, cellView.cid);
          return true;
        },
        // Dispose (release resources) all hidden views.
        disposeHiddenCellViews: function() {
          if (this.legacyMode) return;
          const unmountedCids = this._updates.unmountedList.keys();
          for (const cid of unmountedCids) {
            const cellView = views[cid];
            cellView && this._disposeCellView(cellView);
          }
        },
        // Detach a view from the paper, but keep it in memory.
        _detachCellView(cellView) {
          cellView.unmount();
          cellView.onDetach();
        },
        // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also
        // be a selector or a jQuery object.
        findView: function($el) {
          var el = isString($el) ? this.layers.querySelector($el) : $el instanceof $ ? $el[0] : $el;
          var id2 = this.findAttribute("model-id", el);
          if (id2) return this._views[id2];
          return void 0;
        },
        // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.
        findViewByModel: function(cellOrId) {
          const cellViewLike = this._getCellViewLike(cellOrId);
          if (!cellViewLike) return void 0;
          if (cellViewLike[CELL_VIEW_MARKER]) {
            return cellViewLike;
          }
          const cellView = this._resolveCellViewPlaceholder(cellViewLike);
          const flag = this.getCellViewInitFlag(cellView);
          if (this.isViewMounted(cellView)) {
            this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, {
              // It's important to run in isolation to avoid triggering the update of
              // connected links
              isolate: true
            });
          } else {
            this._mergeUnmountedViewScheduledUpdates(cellView.cid, flag);
          }
          return cellView;
        },
        // Find all views at given point
        findViewsFromPoint: function(p) {
          p = new Point(p);
          var views2 = this.model.getElements().map(this.findViewByModel, this);
          return views2.filter(function(view) {
            return view && view.vel.getBBox({
              target: this.layers
            }).containsPoint(p);
          }, this);
        },
        // Find all views in given area
        findViewsInArea: function(rect2, opt) {
          opt = defaults(opt || {}, {
            strict: false
          });
          rect2 = new Rect(rect2);
          var views2 = this.model.getElements().map(this.findViewByModel, this);
          var method = opt.strict ? "containsRect" : "intersect";
          return views2.filter(function(view) {
            return view && rect2[method](view.vel.getBBox({
              target: this.layers
            }));
          }, this);
        },
        findElementViewsInArea(plainArea, opt) {
          return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt), opt);
        },
        findLinkViewsInArea: function(plainArea, opt) {
          return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt), opt);
        },
        findCellViewsInArea: function(plainArea, opt) {
          return this._filterViewsInArea(plainArea, (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt), opt);
        },
        findElementViewsAtPoint: function(plainPoint, opt) {
          return this._filterViewsAtPoint(plainPoint, (extArea) => this.model.findElementsInArea(extArea), opt);
        },
        findLinkViewsAtPoint: function(plainPoint, opt) {
          return this._filterViewsAtPoint(plainPoint, (extArea) => this.model.findLinksInArea(extArea), opt);
        },
        findCellViewsAtPoint: function(plainPoint, opt) {
          return this._filterViewsAtPoint(
            plainPoint,
            // Note: we do not want to pass `opt` to `findCellsInArea`
            // because the `strict` option works differently for querying at a point
            (extArea) => this.model.findCellsInArea(extArea),
            opt
          );
        },
        findClosestMagnetToPoint: function(point2, options = {}) {
          let minDistance = Number.MAX_SAFE_INTEGER;
          let bestPriority = -Infinity;
          const pointer = new Point(point2);
          const radius = options.radius || Number.MAX_SAFE_INTEGER;
          const viewsInArea = this.findCellViewsInArea({
            x: pointer.x - radius,
            y: pointer.y - radius,
            width: 2 * radius,
            height: 2 * radius
          }, options.findInAreaOptions);
          const filterFn = typeof options.filter === "function" ? options.filter : null;
          let closestView = null;
          let closestMagnet = null;
          viewsInArea.forEach((view) => {
            const candidates = [];
            const {
              model
            } = view;
            if (view.el.getAttribute("magnet") !== "false") {
              if (model.isLink()) {
                const connection = view.getConnection();
                candidates.push({
                  // find distance from the closest point of a link to pointer coordinates
                  priority: 0,
                  distance: connection.closestPoint(pointer).squaredDistance(pointer),
                  magnet: view.el
                });
              } else {
                candidates.push({
                  // Set the priority to the level of nested elements of the model
                  // To ensure that the embedded cells get priority over the parent cells
                  priority: model.getAncestors().length,
                  // find distance from the center of the model to pointer coordinates
                  distance: model.getBBox().center().squaredDistance(pointer),
                  magnet: view.el
                });
              }
            }
            view.$("[magnet]").toArray().forEach((magnet) => {
              const magnetBBox = view.getNodeBBox(magnet);
              let magnetDistance = magnetBBox.pointNearestToPoint(pointer).squaredDistance(pointer);
              if (magnetBBox.containsPoint(pointer)) {
                magnetDistance = -Number.MAX_SAFE_INTEGER + magnetDistance;
              }
              if (magnetDistance <= radius * radius) {
                candidates.push({
                  // Give magnets priority over other candidates.
                  priority: Number.MAX_SAFE_INTEGER,
                  distance: magnetDistance,
                  magnet
                });
              }
            });
            candidates.forEach((candidate) => {
              const {
                magnet,
                distance,
                priority
              } = candidate;
              const isBetterCandidate = priority > bestPriority || priority === bestPriority && distance < minDistance;
              if (isBetterCandidate && (!filterFn || filterFn(view, magnet))) {
                bestPriority = priority;
                minDistance = distance;
                closestView = view;
                closestMagnet = magnet;
              }
            });
          });
          return closestView ? {
            view: closestView,
            magnet: closestMagnet
          } : null;
        },
        _findInExtendedArea: function(area, findCellsFn, opt = {}) {
          const {
            buffer = this.DEFAULT_FIND_BUFFER
          } = opt;
          const extendedArea = new Rect(area).inflate(buffer);
          const cellsInExtendedArea = findCellsFn(extendedArea, opt);
          return cellsInExtendedArea.map((element) => this.findViewByModel(element));
        },
        _filterViewsInArea: function(plainArea, findCells, opt = {}) {
          const area = new Rect(plainArea);
          const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
          const viewsInArea = viewsInExtendedArea.filter((view) => {
            if (!view) return false;
            return view.isInArea(area, opt);
          });
          return viewsInArea;
        },
        _filterViewsAtPoint: function(plainPoint, findCells, opt = {}) {
          const area = new Rect(plainPoint);
          const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);
          const viewsAtPoint = viewsInExtendedArea.filter((view) => {
            if (!view) return false;
            return view.isAtPoint(plainPoint, opt);
          });
          return viewsAtPoint;
        },
        removeTools: function() {
          this.dispatchToolsEvent("remove");
          return this;
        },
        hideTools: function() {
          this.dispatchToolsEvent("hide");
          return this;
        },
        showTools: function() {
          this.dispatchToolsEvent("show");
          return this;
        },
        dispatchToolsEvent: function(event, ...args) {
          if (typeof event !== "string") return;
          this.trigger("tools:event", event, ...args);
        },
        getModelById: function(id2) {
          return this.model.getCell(id2);
        },
        snapToGrid: function(x, y) {
          return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);
        },
        localToPaperPoint: function(x, y) {
          var localPoint = new Point(x, y);
          var paperPoint = V2.transformPoint(localPoint, this.matrix());
          return paperPoint;
        },
        localToPaperRect: function(x, y, width2, height2) {
          var localRect = new Rect(x, y, width2, height2);
          var paperRect = V2.transformRect(localRect, this.matrix());
          return paperRect;
        },
        paperToLocalPoint: function(x, y) {
          var paperPoint = new Point(x, y);
          var localPoint = V2.transformPoint(paperPoint, this.matrix().inverse());
          return localPoint;
        },
        paperToLocalRect: function(x, y, width2, height2) {
          var paperRect = new Rect(x, y, width2, height2);
          var localRect = V2.transformRect(paperRect, this.matrix().inverse());
          return localRect;
        },
        localToClientPoint: function(x, y) {
          var localPoint = new Point(x, y);
          var clientPoint = V2.transformPoint(localPoint, this.clientMatrix());
          return clientPoint;
        },
        localToClientRect: function(x, y, width2, height2) {
          var localRect = new Rect(x, y, width2, height2);
          var clientRect = V2.transformRect(localRect, this.clientMatrix());
          return clientRect;
        },
        // Transform client coordinates to the paper local coordinates.
        // Useful when you have a mouse event object and you'd like to get coordinates
        // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.
        // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });
        clientToLocalPoint: function(x, y) {
          var clientPoint = new Point(x, y);
          var localPoint = V2.transformPoint(clientPoint, this.clientMatrix().inverse());
          return localPoint;
        },
        clientToLocalRect: function(x, y, width2, height2) {
          var clientRect = new Rect(x, y, width2, height2);
          var localRect = V2.transformRect(clientRect, this.clientMatrix().inverse());
          return localRect;
        },
        localToPagePoint: function(x, y) {
          return this.localToPaperPoint(x, y).offset(this.pageOffset());
        },
        localToPageRect: function(x, y, width2, height2) {
          return this.localToPaperRect(x, y, width2, height2).offset(this.pageOffset());
        },
        pageToLocalPoint: function(x, y) {
          var pagePoint = new Point(x, y);
          var paperPoint = pagePoint.difference(this.pageOffset());
          return this.paperToLocalPoint(paperPoint);
        },
        pageToLocalRect: function(x, y, width2, height2) {
          var pageOffset = this.pageOffset();
          var paperRect = new Rect(x, y, width2, height2);
          paperRect.x -= pageOffset.x;
          paperRect.y -= pageOffset.y;
          return this.paperToLocalRect(paperRect);
        },
        clientOffset: function() {
          var clientRect = this.svg.getBoundingClientRect();
          return new Point(clientRect.left, clientRect.top);
        },
        pageOffset: function() {
          return this.clientOffset().offset(window.scrollX, window.scrollY);
        },
        linkAllowed: function(linkView) {
          if (!(linkView instanceof LinkView)) {
            throw new Error("Must provide a linkView.");
          }
          var link = linkView.model;
          var paperOptions = this.options;
          var graph = this.model;
          var ns2 = graph.constructor.validations;
          if (!paperOptions.multiLinks) {
            if (!ns2.multiLinks.call(this, graph, link)) return false;
          }
          if (!paperOptions.linkPinning) {
            if (!ns2.linkPinning.call(this, graph, link)) return false;
          }
          if (typeof paperOptions.allowLink === "function") {
            if (!paperOptions.allowLink.call(this, linkView, this)) return false;
          }
          return true;
        },
        getDefaultLink: function(cellView, magnet) {
          return isFunction(this.options.defaultLink) ? this.options.defaultLink.call(this, cellView, magnet) : this.options.defaultLink.clone();
        },
        // Cell highlighting.
        // ------------------
        resolveHighlighter: function(opt = {}) {
          let {
            highlighter: highlighterDef,
            type
          } = opt;
          const {
            highlighting,
            highlighterNamespace
          } = this.options;
          if (highlighterDef === void 0) {
            if (!highlighting) return false;
            if (type) {
              highlighterDef = highlighting[type];
              if (highlighterDef === false) return false;
            }
            if (!highlighterDef) {
              highlighterDef = highlighting["default"];
            }
          }
          if (!highlighterDef) return false;
          if (isString(highlighterDef)) {
            highlighterDef = {
              name: highlighterDef
            };
          }
          const name = highlighterDef.name;
          const highlighter = highlighterNamespace[name];
          if (!highlighter) {
            throw new Error('Unknown highlighter ("' + name + '")');
          }
          if (typeof highlighter.highlight !== "function") {
            throw new Error('Highlighter ("' + name + '") is missing required highlight() method');
          }
          if (typeof highlighter.unhighlight !== "function") {
            throw new Error('Highlighter ("' + name + '") is missing required unhighlight() method');
          }
          return {
            highlighter,
            options: highlighterDef.options || {},
            name
          };
        },
        onCellHighlight: function(cellView, magnetEl, opt) {
          const highlighterDescriptor = this.resolveHighlighter(opt);
          if (!highlighterDescriptor) return;
          const {
            highlighter,
            options
          } = highlighterDescriptor;
          highlighter.highlight(cellView, magnetEl, options);
        },
        onCellUnhighlight: function(cellView, magnetEl, opt) {
          const highlighterDescriptor = this.resolveHighlighter(opt);
          if (!highlighterDescriptor) return;
          const {
            highlighter,
            options
          } = highlighterDescriptor;
          highlighter.unhighlight(cellView, magnetEl, options);
        },
        // Interaction.
        // ------------
        pointerdblclick: function(evt) {
          evt.preventDefault();
          evt = normalizeEvent(evt);
          var view = this.findView(evt.target);
          if (this.guard(evt, view)) return;
          var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
          if (view) {
            view.pointerdblclick(evt, localPoint.x, localPoint.y);
          } else {
            this.trigger("blank:pointerdblclick", evt, localPoint.x, localPoint.y);
          }
        },
        pointerclick: function(evt) {
          var data2 = this.eventData(evt);
          if (data2.mousemoved <= this.options.clickThreshold) {
            evt = normalizeEvent(evt);
            var view = this.findView(evt.target);
            if (this.guard(evt, view)) return;
            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) {
              view.pointerclick(evt, localPoint.x, localPoint.y);
            } else {
              this.trigger("blank:pointerclick", evt, localPoint.x, localPoint.y);
            }
          }
        },
        contextmenu: function(evt) {
          if (this.options.preventContextMenu) evt.preventDefault();
          if (this.contextMenuFired) {
            this.contextMenuFired = false;
            return;
          }
          evt = normalizeEvent(evt);
          this.contextMenuTrigger(evt);
        },
        contextMenuTrigger: function(evt) {
          var view = this.findView(evt.target);
          if (this.guard(evt, view)) return;
          var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
          if (view) {
            view.contextmenu(evt, localPoint.x, localPoint.y);
          } else {
            this.trigger("blank:contextmenu", evt, localPoint.x, localPoint.y);
          }
        },
        pointerdown: function(evt) {
          evt = normalizeEvent(evt);
          const {
            target,
            button
          } = evt;
          const view = this.findView(target);
          const isContextMenu = button === 2;
          if (view) {
            if (!isContextMenu && this.guard(evt, view)) return;
            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);
            if (this.options.preventDefaultViewAction && !isTargetFormNode) {
              evt.preventDefault();
            }
            if (isTargetFormNode) {
              view.preventDefaultInteraction(evt);
            }
            const eventEvt = this.customEventTrigger(evt, view);
            if (eventEvt) {
              if (eventEvt.isPropagationStopped()) return;
              evt.data = eventEvt.data;
            }
            const magnetNode = target.closest("[magnet]");
            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {
              const magnetEvt = normalizeEvent(new $.Event(evt.originalEvent, {
                data: evt.data,
                // Originally the event listener was attached to the magnet element.
                currentTarget: magnetNode
              }));
              this.onmagnet(magnetEvt);
              if (magnetEvt.isDefaultPrevented()) {
                evt.preventDefault();
              }
              if (magnetEvt.isPropagationStopped()) {
                if (isContextMenu) return;
                this.delegateDragEvents(view, magnetEvt.data);
                return;
              }
              evt.data = magnetEvt.data;
            }
          }
          if (isContextMenu) {
            this.contextMenuFired = true;
            const contextmenuEvt = new $.Event(evt.originalEvent, {
              type: "contextmenu",
              data: evt.data
            });
            this.contextMenuTrigger(contextmenuEvt);
          } else {
            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);
            if (view) {
              view.pointerdown(evt, localPoint.x, localPoint.y);
            } else {
              if (this.options.preventDefaultBlankAction) {
                evt.preventDefault();
              }
              this.trigger("blank:pointerdown", evt, localPoint.x, localPoint.y);
            }
            this.delegateDragEvents(view, evt.data);
          }
        },
        pointermove: function(evt) {
          var data2 = this.eventData(evt);
          if (!data2.mousemoved) {
            data2.mousemoved = 0;
            this.undelegateEvents();
          }
          var mousemoved = ++data2.mousemoved;
          if (mousemoved <= this.options.moveThreshold) return;
          evt = normalizeEvent(evt);
          var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
          let view = data2.sourceView;
          if (view) {
            view = this.findViewByModel(view.model);
            view.pointermove(evt, localPoint.x, localPoint.y);
          } else {
            this.trigger("blank:pointermove", evt, localPoint.x, localPoint.y);
          }
          this.eventData(evt, data2);
        },
        pointerup: function(evt) {
          this.undelegateDocumentEvents();
          var normalizedEvt = normalizeEvent(evt);
          var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
          let view = this.eventData(evt).sourceView;
          if (view) {
            view = this.findViewByModel(view.model);
            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);
          } else {
            this.trigger("blank:pointerup", normalizedEvt, localPoint.x, localPoint.y);
          }
          if (!normalizedEvt.isPropagationStopped()) {
            this.pointerclick(new $.Event(evt.originalEvent, {
              type: "click",
              data: evt.data
            }));
          }
          this.delegateEvents();
        },
        mouseover: function(evt) {
          evt = normalizeEvent(evt);
          var view = this.findView(evt.target);
          if (this.guard(evt, view)) return;
          if (view) {
            view.mouseover(evt);
          } else {
            if (this.el === evt.target) return;
            this.trigger("blank:mouseover", evt);
          }
        },
        mouseout: function(evt) {
          evt = normalizeEvent(evt);
          var view = this.findView(evt.target);
          if (this.guard(evt, view)) return;
          if (view) {
            view.mouseout(evt);
          } else {
            if (this.el === evt.target) return;
            this.trigger("blank:mouseout", evt);
          }
        },
        mouseenter: function(evt) {
          evt = normalizeEvent(evt);
          const {
            target,
            // The EventTarget the pointing device entered to
            relatedTarget,
            // The EventTarget the pointing device exited from
            currentTarget
            // The EventTarget on which the event listener was registered
          } = evt;
          const view = this.findView(target);
          if (this.guard(evt, view)) return;
          const relatedView = this.findView(relatedTarget);
          if (view) {
            if (relatedView === view) {
              return;
            }
            view.mouseenter(evt);
            if (this.el.contains(relatedTarget)) {
              return;
            }
          }
          if (relatedView) {
            return;
          }
          if (currentTarget === this.el) {
            this.trigger("paper:mouseenter", evt);
          }
        },
        mouseleave: function(evt) {
          evt = normalizeEvent(evt);
          const {
            target,
            // The EventTarget the pointing device exited from
            relatedTarget,
            // The EventTarget the pointing device entered to
            currentTarget
            // The EventTarget on which the event listener was registered
          } = evt;
          const view = this.findView(target);
          if (this.guard(evt, view)) return;
          const relatedView = this.findView(relatedTarget);
          if (view) {
            if (relatedView === view) {
              return;
            }
            view.mouseleave(evt);
            if (this.el.contains(relatedTarget)) {
              return;
            }
          }
          if (relatedView) {
            return;
          }
          if (currentTarget === this.el) {
            this.trigger("paper:mouseleave", evt);
          }
        },
        _processMouseWheelEvtBuf: debounce(function() {
          const {
            event,
            deltas
          } = this._mw_evt_buffer;
          const deltaY = deltas.reduce((acc, deltaY2) => acc + cap(deltaY2, WHEEL_CAP), 0);
          const scale2 = Math.pow(0.995, deltaY);
          const {
            x,
            y
          } = this.clientToLocalPoint(event.clientX, event.clientY);
          this.trigger("paper:pinch", event, x, y, scale2);
          this._mw_evt_buffer = {
            event: null,
            deltas: []
          };
        }, WHEEL_WAIT_MS, {
          maxWait: WHEEL_WAIT_MS
        }),
        mousewheel: function(evt) {
          evt = normalizeEvent(evt);
          const view = this.findView(evt.target);
          if (this.guard(evt, view)) return;
          const originalEvent = evt.originalEvent;
          const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);
          const {
            deltaX,
            deltaY
          } = normalizeWheel(originalEvent);
          const pinchHandlers = this._events["paper:pinch"];
          if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {
            originalEvent.preventDefault();
            this._mw_evt_buffer.event = evt;
            this._mw_evt_buffer.deltas.push(deltaY);
            this._processMouseWheelEvtBuf();
          } else {
            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));
            if (view) {
              view.mousewheel(evt, localPoint.x, localPoint.y, delta);
            } else {
              this.trigger("blank:mousewheel", evt, localPoint.x, localPoint.y, delta);
            }
            this.trigger("paper:pan", evt, deltaX, deltaY);
          }
        },
        onevent: function(evt) {
          var eventNode = evt.currentTarget;
          var eventName = eventNode.getAttribute("event");
          if (eventName) {
            var view = this.findView(eventNode);
            if (view) {
              evt = normalizeEvent(evt);
              if (this.guard(evt, view)) return;
              var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
              view.onevent(evt, eventName, localPoint.x, localPoint.y);
            }
          }
        },
        magnetEvent: function(evt, handler) {
          var magnetNode = evt.currentTarget;
          var magnetValue = magnetNode.getAttribute("magnet");
          if (magnetValue) {
            var view = this.findView(magnetNode);
            if (view) {
              evt = normalizeEvent(evt);
              if (this.guard(evt, view)) return;
              var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
              handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);
            }
          }
        },
        onmagnet: function(evt) {
          if (evt.button === 2) {
            this.contextMenuFired = true;
            this.magnetContextMenuFired = true;
            const contextmenuEvt = new $.Event(evt.originalEvent, {
              type: "contextmenu",
              data: evt.data,
              currentTarget: evt.currentTarget
            });
            this.magnetContextMenuTrigger(contextmenuEvt);
            if (contextmenuEvt.isPropagationStopped()) {
              evt.stopPropagation();
            }
          } else {
            this.magnetEvent(evt, function(view, evt2, _, x, y) {
              view.onmagnet(evt2, x, y);
            });
          }
        },
        magnetpointerdblclick: function(evt) {
          this.magnetEvent(evt, function(view, evt2, magnet, x, y) {
            view.magnetpointerdblclick(evt2, magnet, x, y);
          });
        },
        magnetcontextmenu: function(evt) {
          if (this.options.preventContextMenu) evt.preventDefault();
          if (this.magnetContextMenuFired) {
            this.magnetContextMenuFired = false;
            return;
          }
          this.magnetContextMenuTrigger(evt);
        },
        magnetContextMenuTrigger: function(evt) {
          this.magnetEvent(evt, function(view, evt2, magnet, x, y) {
            view.magnetcontextmenu(evt2, magnet, x, y);
          });
        },
        onlabel: function(evt) {
          var labelNode = evt.currentTarget;
          var view = this.findView(labelNode);
          if (!view) return;
          evt = normalizeEvent(evt);
          if (this.guard(evt, view)) return;
          const eventEvt = this.customEventTrigger(evt, view, labelNode);
          if (eventEvt) {
            if (eventEvt.isPropagationStopped()) return;
            evt.data = eventEvt.data;
          }
          var localPoint = this.snapToGrid(evt.clientX, evt.clientY);
          view.onlabel(evt, localPoint.x, localPoint.y);
        },
        getPointerArgs(evt) {
          const normalizedEvt = normalizeEvent(evt);
          const {
            x,
            y
          } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);
          return [normalizedEvt, x, y];
        },
        delegateDragEvents: function(view, data2) {
          data2 || (data2 = {});
          this.eventData({
            data: data2
          }, {
            sourceView: view || null,
            mousemoved: 0
          });
          this.delegateDocumentEvents(null, data2);
        },
        // Guard the specified event. If the event should be ignored, guard returns `true`.
        // Otherwise, it returns `false`.
        guard: function(evt, view) {
          if (evt.type === "mousedown" && evt.button === 2) {
            return true;
          }
          if (this.options.guard && this.options.guard(evt, view)) {
            return true;
          }
          if (evt.data && evt.data.guarded !== void 0) {
            return evt.data.guarded;
          }
          const {
            target
          } = evt;
          if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {
            return true;
          }
          if (view && view.model && view.model[CELL_MARKER]) {
            return false;
          }
          if (this.el === target || this.svg.contains(target)) {
            return false;
          }
          return true;
        },
        setGridSize: function(gridSize) {
          const {
            options
          } = this;
          options.gridSize = gridSize;
          if (options.drawGrid && !options.drawGridSize) {
            this.getLayerView(paperLayers.GRID).renderGrid();
          }
          return this;
        },
        setGrid: function(drawGrid) {
          this.getLayerView(paperLayers.GRID).setGrid(drawGrid);
          return this;
        },
        updateBackgroundImage: function(opt) {
          opt = opt || {};
          var backgroundPosition = opt.position || "center";
          var backgroundSize = opt.size || "auto auto";
          var currentScale = this.scale();
          var currentTranslate = this.translate();
          if (isObject(backgroundPosition)) {
            var x = currentTranslate.tx + currentScale.sx * (backgroundPosition.x || 0);
            var y = currentTranslate.ty + currentScale.sy * (backgroundPosition.y || 0);
            backgroundPosition = x + "px " + y + "px";
          }
          if (isObject(backgroundSize)) {
            backgroundSize = new Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);
            backgroundSize = backgroundSize.width + "px " + backgroundSize.height + "px";
          }
          const {
            background
          } = this.childNodes;
          background.style.backgroundSize = backgroundSize;
          background.style.backgroundPosition = backgroundPosition;
        },
        drawBackgroundImage: function(img, opt) {
          if (!(img instanceof HTMLImageElement)) {
            this.childNodes.background.style.backgroundImage = "";
            return;
          }
          if (!this._background || this._background.id !== opt.id) {
            return;
          }
          opt = opt || {};
          var backgroundImage;
          var backgroundSize = opt.size;
          var backgroundRepeat = opt.repeat || "no-repeat";
          var backgroundOpacity = opt.opacity || 1;
          var backgroundQuality = Math.abs(opt.quality) || 1;
          var backgroundPattern = this.constructor.backgroundPatterns[camelCase(backgroundRepeat)];
          if (isFunction(backgroundPattern)) {
            img.width *= backgroundQuality;
            img.height *= backgroundQuality;
            var canvas = backgroundPattern(img, opt);
            if (!(canvas instanceof HTMLCanvasElement)) {
              throw new Error("dia.Paper: background pattern must return an HTML Canvas instance");
            }
            backgroundImage = canvas.toDataURL("image/png");
            backgroundRepeat = "repeat";
            if (isObject(backgroundSize)) {
              backgroundSize.width *= canvas.width / img.width;
              backgroundSize.height *= canvas.height / img.height;
            } else if (backgroundSize === void 0) {
              opt.size = {
                width: canvas.width / backgroundQuality,
                height: canvas.height / backgroundQuality
              };
            }
          } else {
            backgroundImage = img.src;
            if (backgroundSize === void 0) {
              opt.size = {
                width: img.width,
                height: img.height
              };
            }
          }
          this.childNodes.background.style.opacity = backgroundOpacity;
          this.childNodes.background.style.backgroundRepeat = backgroundRepeat;
          this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;
          this.updateBackgroundImage(opt);
        },
        updateBackgroundColor: function(color) {
          this.$el.css("backgroundColor", color || "");
        },
        drawBackground: function(opt) {
          opt = opt || {};
          this.updateBackgroundColor(opt.color);
          if (opt.image) {
            opt = this._background = cloneDeep(opt);
            guid(opt);
            var img = document.createElement("img");
            img.onload = this.drawBackgroundImage.bind(this, img, opt);
            img.src = opt.image;
          } else {
            this.drawBackgroundImage(null);
            this._background = null;
          }
          return this;
        },
        setInteractivity: function(value) {
          this.options.interactive = value;
          invoke(this._views, "setInteractivity", value);
        },
        // Paper definitions.
        // ------------------
        isDefined: function(defId) {
          return !!this.svg.getElementById(defId);
        },
        defineFilter: function(filter$1) {
          if (!isObject(filter$1)) {
            throw new TypeError("dia.Paper: defineFilter() requires 1. argument to be an object.");
          }
          var filterId = filter$1.id;
          var name = filter$1.name;
          if (!filterId) {
            filterId = name + this.svg.id + hashCode(JSON.stringify(filter$1));
          }
          if (!this.isDefined(filterId)) {
            var namespace = filter;
            var filterSVGString = namespace[name] && namespace[name](filter$1.args || {});
            if (!filterSVGString) {
              throw new Error("Non-existing filter " + name);
            }
            var filterAttrs = assign({
              filterUnits: "userSpaceOnUse"
            }, filter$1.attrs, {
              id: filterId
            });
            V2(filterSVGString, filterAttrs).appendTo(this.defs);
          }
          return filterId;
        },
        defineGradient: function(gradient) {
          if (!isObject(gradient)) {
            throw new TypeError("dia.Paper: defineGradient() requires 1. argument to be an object.");
          }
          const {
            svg: svg2,
            defs
          } = this;
          const {
            type,
            // Generate a hash code from the stringified filter definition. This gives us
            // a unique filter ID for different definitions.
            id: id2 = type + svg2.id + hashCode(JSON.stringify(gradient)),
            stops,
            attrs = {}
          } = gradient;
          if (this.isDefined(id2)) return id2;
          const stopVEls = toArray$1(stops).map(({
            offset: offset2,
            color,
            opacity: opacity2
          }) => {
            return V2("stop").attr({
              "offset": offset2,
              "stop-color": color,
              "stop-opacity": Number.isFinite(opacity2) ? opacity2 : 1
            });
          });
          const gradientVEl = V2(type, attrs, stopVEls);
          gradientVEl.id = id2;
          gradientVEl.appendTo(defs);
          return id2;
        },
        definePattern: function(pattern) {
          if (!isObject(pattern)) {
            throw new TypeError("dia.Paper: definePattern() requires 1. argument to be an object.");
          }
          const {
            svg: svg2,
            defs
          } = this;
          const {
            // Generate a hash code from the stringified filter definition. This gives us
            // a unique filter ID for different definitions.
            id: id2 = svg2.id + hashCode(JSON.stringify(pattern)),
            markup,
            attrs = {}
          } = pattern;
          if (!markup) {
            throw new TypeError("dia.Paper: definePattern() requires markup.");
          }
          if (this.isDefined(id2)) return id2;
          const patternVEl = V2("pattern", {
            patternUnits: "userSpaceOnUse"
          });
          patternVEl.id = id2;
          patternVEl.attr(attrs);
          if (typeof markup === "string") {
            patternVEl.append(V2(markup));
          } else {
            const {
              fragment
            } = parseDOMJSON(markup);
            patternVEl.append(fragment);
          }
          patternVEl.appendTo(defs);
          return id2;
        },
        defineMarker: function(marker) {
          if (!isObject(marker)) {
            throw new TypeError("dia.Paper: defineMarker() requires the first argument to be an object.");
          }
          const {
            svg: svg2,
            defs
          } = this;
          const {
            // Generate a hash code from the stringified filter definition. This gives us
            // a unique filter ID for different definitions.
            id: id2 = svg2.id + hashCode(JSON.stringify(marker)),
            // user-provided markup
            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)
            markup,
            // user-provided attributes
            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)
            // note: `transform` attrs are ignored by browsers
            attrs = {},
            // deprecated - use `attrs/markerUnits` instead (which has higher priority)
            markerUnits = "userSpaceOnUse"
          } = marker;
          if (this.isDefined(id2)) return id2;
          const markerVEl = V2("marker", {
            orient: "auto",
            overflow: "visible",
            markerUnits
          });
          markerVEl.id = id2;
          markerVEl.attr(attrs);
          let markerContentVEl;
          if (markup) {
            let markupVEl;
            if (typeof markup === "string") {
              markupVEl = V2(markup);
              markupVEl = Array.isArray(markupVEl) ? markupVEl : [markupVEl];
            } else {
              const {
                fragment
              } = parseDOMJSON(markup);
              markupVEl = V2(fragment).children();
            }
            if (markupVEl.length > 1) {
              markerContentVEl = V2("g").append(markupVEl);
            } else {
              markerContentVEl = markupVEl[0];
            }
          } else {
            const {
              type = "path"
            } = marker;
            markerContentVEl = V2(type);
          }
          const markerAttrs = omit(marker, "type", "id", "markup", "attrs", "markerUnits");
          const markerAttrsKeys = Object.keys(markerAttrs);
          markerAttrsKeys.forEach((key) => {
            const value = markerAttrs[key];
            const markupValue = markerContentVEl.attr(key);
            if (markupValue == null) {
              markerContentVEl.attr(key, value);
            } else {
              switch (key) {
                case "transform":
                  markerContentVEl.attr(key, value + " " + markupValue);
                  break;
              }
            }
          });
          markerContentVEl.appendTo(markerVEl);
          markerVEl.appendTo(defs);
          return id2;
        },
        customEventTrigger: function(evt, view, rootNode = view.el) {
          const eventNode = evt.target.closest("[event]");
          if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {
            const eventEvt = normalizeEvent(new $.Event(evt.originalEvent, {
              data: evt.data,
              // Originally the event listener was attached to the event element.
              currentTarget: eventNode
            }));
            this.onevent(eventEvt);
            if (eventEvt.isDefaultPrevented()) {
              evt.preventDefault();
            }
            return eventEvt;
          }
          return null;
        }
      }, {
        sorting: sortingTypes,
        Layers: paperLayers,
        backgroundPatterns,
        gridPatterns
      });
      const ToolView = View.extend({
        name: null,
        tagName: "g",
        className: "tool",
        svgElement: true,
        _visible: true,
        _visibleExplicit: true,
        init: function() {
          var name = this.name;
          if (name) this.vel.attr("data-tool-name", name);
        },
        configure: function(view, toolsView) {
          this.relatedView = view;
          this.paper = view.paper;
          this.parentView = toolsView;
          this.simulateRelatedView(this.el);
          this.delegateEvents();
          return this;
        },
        simulateRelatedView: function(el) {
          if (el) el.setAttribute("model-id", this.relatedView.model.id);
        },
        getName: function() {
          return this.name;
        },
        // Evaluate the visibility of the tool and update the `display` CSS property
        updateVisibility: function() {
          const isVisible = this.computeVisibility();
          this.el.style.display = isVisible ? "" : "none";
          this._visible = isVisible;
        },
        // Evaluate the visibility of the tool. The method returns `true` if the tool
        // should be visible in the DOM.
        computeVisibility() {
          if (!this.isExplicitlyVisible()) return false;
          const {
            visibility
          } = this.options;
          if (typeof visibility !== "function") return true;
          return !!visibility.call(this, this.relatedView, this);
        },
        show: function() {
          this._visibleExplicit = true;
          this.updateVisibility();
        },
        hide: function() {
          this._visibleExplicit = false;
          this.updateVisibility();
        },
        // The method returns `false` if the `hide()` method was called on the tool.
        isExplicitlyVisible: function() {
          return !!this._visibleExplicit;
        },
        // The method returns `false` if the tool is not visible (it has `display: none`).
        // This can happen if the `hide()` method was called or the tool is not visible
        // because of the `visibility` option was evaluated to `false`.
        isVisible: function() {
          return !!this._visible;
        },
        isOverlay: function() {
          return !!this.parentView && this.parentView.hasLayer();
        },
        focus: function() {
          var opacity2 = this.options.focusOpacity;
          if (isFinite(opacity2)) this.el.style.opacity = opacity2;
          this.parentView.focusTool(this);
        },
        blur: function() {
          this.el.style.opacity = "";
          this.parentView.blurTool(this);
        },
        update: function() {
        },
        guard: function(evt) {
          const {
            paper,
            relatedView
          } = this;
          if (!paper || !relatedView) return true;
          return paper.guard(evt, relatedView);
        }
      });
      const ToolsView = View.extend({
        tagName: "g",
        className: "tools",
        svgElement: true,
        tools: null,
        isRendered: false,
        options: {
          tools: null,
          relatedView: null,
          name: null
          // layer?: Paper.Layers.TOOLS
          // z?: number
        },
        configure: function(options) {
          options = assign(this.options, options);
          var tools = options.tools;
          if (!Array.isArray(tools)) return this;
          var relatedView = options.relatedView;
          if (!(relatedView instanceof CellView)) return this;
          var views2 = this.tools = [];
          for (var i = 0, n = tools.length; i < n; i++) {
            var tool = tools[i];
            if (!(tool instanceof ToolView)) continue;
            tool.configure(relatedView, this);
            this.vel.append(tool.el);
            views2.push(tool);
          }
          this.isRendered = false;
          relatedView.requestUpdate(relatedView.getFlag("TOOLS"));
          return this;
        },
        getName: function() {
          return this.options.name;
        },
        update: function(opt) {
          opt || (opt = {});
          const tools = this.tools;
          if (!tools) return this;
          const n = tools.length;
          const wasRendered = this.isRendered;
          for (let i = 0; i < n; i++) {
            const tool = tools[i];
            tool.updateVisibility();
            if (!tool.isVisible()) continue;
            if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {
              tool.update();
            }
          }
          if (!this.isRendered && n > 0) {
            return this;
          }
          if (!this.isMounted()) {
            this.mount();
          }
          if (!wasRendered) {
            this.blurTool();
          }
          return this;
        },
        ensureToolRendered(tools, i) {
          if (!this.isRendered) {
            this.isRendered = Array(tools.length).fill(false);
          }
          if (!this.isRendered[i]) {
            tools[i].render();
            this.isRendered[i] = true;
            return false;
          }
          return true;
        },
        focusTool: function(focusedTool) {
          var tools = this.tools;
          if (!tools) return this;
          for (var i = 0, n = tools.length; i < n; i++) {
            var tool = tools[i];
            if (focusedTool === tool) {
              tool.show();
            } else {
              tool.hide();
            }
          }
          return this;
        },
        blurTool: function(blurredTool) {
          var tools = this.tools;
          if (!tools) return this;
          for (var i = 0, n = tools.length; i < n; i++) {
            var tool = tools[i];
            if (tool !== blurredTool && !tool.isExplicitlyVisible()) {
              tool.show();
              if (tool.isVisible()) {
                this.ensureToolRendered(tools, i) && tool.update();
              }
            }
          }
          return this;
        },
        hide: function() {
          return this.focusTool(null);
        },
        show: function() {
          this.blurTool(null);
          if (!this.isMounted()) {
            this.mount();
          }
          return this;
        },
        onRemove: function() {
          var tools = this.tools;
          if (!tools) return this;
          for (var i = 0, n = tools.length; i < n; i++) {
            tools[i].remove();
          }
          this.tools = null;
        },
        getLayer() {
          const {
            layer = Paper.Layers.TOOLS
          } = this.options;
          return layer;
        },
        hasLayer() {
          return !!this.getLayer();
        },
        mount: function() {
          const {
            options,
            el
          } = this;
          const {
            relatedView,
            z
          } = options;
          if (relatedView) {
            if (this.hasLayer()) {
              relatedView.paper.getLayerView(this.getLayer()).insertSortedNode(el, z);
            } else {
              relatedView.el.appendChild(el);
            }
          }
          return this;
        }
      });
      var index$2 = {
        __proto__: null,
        Cell,
        CellCollection,
        CellView,
        DEFAULT_GRAPH_LAYER_TYPE,
        Element: Element$1,
        ElementView,
        Graph,
        GraphLayer,
        GraphLayerCollection,
        GraphLayerView,
        GridLayerView,
        HighlighterView,
        LayerView,
        Link: Link$1,
        LinkView,
        Paper,
        ToolView,
        ToolsView,
        attributes,
        sortingTypes
      };
      var VertexHandle = View.extend({
        tagName: "circle",
        svgElement: true,
        className: "marker-vertex",
        events: {
          mousedown: "onPointerDown",
          touchstart: "onPointerDown",
          dblclick: "onDoubleClick",
          dbltap: "onDoubleClick"
        },
        documentEvents: {
          mousemove: "onPointerMove",
          touchmove: "onPointerMove",
          mouseup: "onPointerUp",
          touchend: "onPointerUp",
          touchcancel: "onPointerUp"
        },
        attributes: {
          "r": 6,
          "fill": "#33334F",
          "stroke": "#FFFFFF",
          "stroke-width": 2,
          "cursor": "move"
        },
        position: function(x, y) {
          const {
            vel,
            options
          } = this;
          const {
            scale: scale2
          } = options;
          let matrix = V2.createSVGMatrix().translate(x, y);
          if (scale2) matrix = matrix.scale(scale2);
          vel.transform(matrix, {
            absolute: true
          });
        },
        onPointerDown: function(evt) {
          if (this.options.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          this.options.paper.undelegateEvents();
          this.delegateDocumentEvents(null, evt.data);
          this.trigger("will-change", this, evt);
        },
        onPointerMove: function(evt) {
          this.trigger("changing", this, evt);
        },
        onDoubleClick: function(evt) {
          this.trigger("remove", this, evt);
        },
        onPointerUp: function(evt) {
          this.trigger("changed", this, evt);
          this.undelegateDocumentEvents();
          this.options.paper.delegateEvents();
        }
      });
      const Vertices = ToolView.extend({
        name: "vertices",
        options: {
          handleClass: VertexHandle,
          snapRadius: 20,
          redundancyRemoval: true,
          vertexAdding: true,
          // vertexRemoving: true,
          // vertexMoving: true,
          stopPropagation: true,
          scale: null
        },
        children: [{
          tagName: "path",
          selector: "connection",
          className: "joint-vertices-path",
          attributes: {
            "fill": "none",
            "stroke": "transparent",
            "stroke-width": 10,
            "cursor": "cell"
          }
        }],
        handles: null,
        interactiveLinkNode: null,
        events: {
          "mousedown .joint-vertices-path": "onPathPointerDown",
          "touchstart .joint-vertices-path": "onPathPointerDown"
        },
        linkEvents: {
          mousedown: "onLinkPointerDown",
          touchstart: "onLinkPointerDown"
        },
        onRender: function() {
          const {
            vertexAdding
          } = this.options;
          if (vertexAdding) {
            const {
              interactiveLinkNode = null
            } = vertexAdding;
            if (interactiveLinkNode) {
              this.delegateLinkEvents(interactiveLinkNode);
            } else {
              this.renderChildren();
              this.updatePath();
            }
          }
          this.resetHandles();
          this.renderHandles();
          return this;
        },
        delegateLinkEvents: function(selector) {
          this.undelegateLinkEvents();
          const el = this.relatedView.findNode(selector);
          if (!el) {
            console.warn(`Interactive link node "${selector}" not found.`);
            return;
          }
          el.classList.add("joint-vertices-path");
          this.interactiveLinkNode = el;
          this.delegateElementEvents(el, this.linkEvents);
        },
        undelegateLinkEvents: function() {
          const el = this.interactiveLinkNode;
          if (!el) return;
          this.undelegateElementEvents(el);
          el.classList.remove("joint-vertices-path");
          this.interactiveLinkNode = null;
        },
        update: function() {
          var relatedView = this.relatedView;
          var vertices = relatedView.model.vertices();
          if (vertices.length === this.handles.length) {
            this.updateHandles();
          } else {
            this.resetHandles();
            this.renderHandles();
          }
          if (this.options.vertexAdding) {
            this.updatePath();
          }
          return this;
        },
        resetHandles: function() {
          var handles = this.handles;
          this.handles = [];
          this.stopListening();
          if (!Array.isArray(handles)) return;
          for (var i = 0, n = handles.length; i < n; i++) {
            handles[i].remove();
          }
        },
        renderHandles: function() {
          var relatedView = this.relatedView;
          var vertices = relatedView.model.vertices();
          for (var i = 0, n = vertices.length; i < n; i++) {
            var vertex = vertices[i];
            var handle = new this.options.handleClass({
              index: i,
              paper: this.paper,
              scale: this.options.scale,
              guard: (evt) => this.guard(evt)
            });
            handle.render();
            handle.position(vertex.x, vertex.y);
            this.simulateRelatedView(handle.el);
            handle.vel.appendTo(this.el);
            this.handles.push(handle);
            this.startHandleListening(handle);
          }
        },
        updateHandles: function() {
          var relatedView = this.relatedView;
          var vertices = relatedView.model.vertices();
          for (var i = 0, n = vertices.length; i < n; i++) {
            var vertex = vertices[i];
            var handle = this.handles[i];
            if (!handle) return;
            handle.position(vertex.x, vertex.y);
          }
        },
        updatePath: function() {
          if (this.interactiveLinkNode) return;
          const connection = this.childNodes.connection;
          if (connection) connection.setAttribute("d", this.relatedView.getSerializedConnection());
        },
        startHandleListening: function(handle) {
          const {
            vertexRemoving = true,
            vertexMoving = true
          } = this.options;
          if (vertexMoving) {
            this.listenTo(handle, "will-change", this.onHandleWillChange);
            this.listenTo(handle, "changing", this.onHandleChanging);
            this.listenTo(handle, "changed", this.onHandleChanged);
          }
          if (vertexRemoving) {
            this.listenTo(handle, "remove", this.onHandleRemove);
          }
        },
        getNeighborPoints: function(index2) {
          var linkView = this.relatedView;
          var vertices = linkView.model.vertices();
          var prev = index2 > 0 ? vertices[index2 - 1] : linkView.sourceAnchor;
          var next = index2 < vertices.length - 1 ? vertices[index2 + 1] : linkView.targetAnchor;
          return {
            prev: new Point(prev),
            next: new Point(next)
          };
        },
        onHandleWillChange: function(_handle, evt) {
          this.focus();
          const {
            relatedView,
            options
          } = this;
          relatedView.model.startBatch("vertex-move", {
            ui: true,
            tool: this.cid
          });
          if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));
        },
        onHandleChanging: function(handle, evt) {
          const {
            options,
            relatedView: linkView
          } = this;
          var index2 = handle.options.index;
          var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);
          var vertex = {
            x,
            y
          };
          this.snapVertex(vertex, index2);
          linkView.model.vertex(index2, vertex, {
            ui: true,
            tool: this.cid
          });
          handle.position(vertex.x, vertex.y);
          if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);
        },
        onHandleChanged: function(_handle, evt) {
          const {
            options,
            relatedView: linkView
          } = this;
          if (options.vertexAdding) this.updatePath();
          if (options.redundancyRemoval) {
            const verticesRemoved = linkView.removeRedundantLinearVertices({
              ui: true,
              tool: this.cid
            });
            if (verticesRemoved) this.render();
          }
          this.blur();
          linkView.model.stopBatch("vertex-move", {
            ui: true,
            tool: this.cid
          });
          if (this.eventData(evt).vertexAdded) {
            linkView.model.stopBatch("vertex-add", {
              ui: true,
              tool: this.cid
            });
          }
          const [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);
          if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);
          linkView.checkMouseleave(normalizedEvt);
        },
        snapVertex: function(vertex, index2) {
          var snapRadius = this.options.snapRadius;
          if (snapRadius > 0) {
            var neighbors = this.getNeighborPoints(index2);
            var prev = neighbors.prev;
            var next = neighbors.next;
            if (Math.abs(vertex.x - prev.x) < snapRadius) {
              vertex.x = prev.x;
            } else if (Math.abs(vertex.x - next.x) < snapRadius) {
              vertex.x = next.x;
            }
            if (Math.abs(vertex.y - prev.y) < snapRadius) {
              vertex.y = neighbors.prev.y;
            } else if (Math.abs(vertex.y - next.y) < snapRadius) {
              vertex.y = next.y;
            }
          }
        },
        onHandleRemove: function(handle, evt) {
          var index2 = handle.options.index;
          var linkView = this.relatedView;
          linkView.model.removeVertex(index2, {
            ui: true
          });
          if (this.options.vertexAdding) this.updatePath();
          linkView.checkMouseleave(normalizeEvent(evt));
        },
        onPathPointerDown: function(evt) {
          if (this.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          var normalizedEvent = normalizeEvent(evt);
          var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();
          var relatedView = this.relatedView;
          relatedView.model.startBatch("vertex-add", {
            ui: true,
            tool: this.cid
          });
          var index2 = relatedView.getVertexIndex(vertex.x, vertex.y);
          this.snapVertex(vertex, index2);
          relatedView.model.insertVertex(index2, vertex, {
            ui: true,
            tool: this.cid
          });
          this.update();
          var handle = this.handles[index2];
          this.eventData(normalizedEvent, {
            vertexAdded: true
          });
          handle.onPointerDown(normalizedEvent);
        },
        onLinkPointerDown: function(evt) {
          this.relatedView.preventDefaultInteraction(evt);
          this.onPathPointerDown(evt);
        },
        onRemove: function() {
          this.resetHandles();
          this.undelegateLinkEvents();
        }
      }, {
        VertexHandle
        // keep as class property
      });
      function getViewBBox(view, {
        useModelGeometry = false,
        relative = false,
        el = view.el
      } = {}) {
        const {
          model
        } = view;
        let bbox2;
        if (useModelGeometry) {
          bbox2 = model.getBBox();
        } else if (model.isLink()) {
          bbox2 = view.getConnection().bbox();
        } else {
          bbox2 = view.getNodeUnrotatedBBox(el);
        }
        if (relative) {
          const position2 = model.position();
          bbox2.x -= position2.x;
          bbox2.y -= position2.y;
        }
        return bbox2;
      }
      function getToolOptions(toolView) {
        const relative = !toolView.isOverlay();
        const {
          useModelGeometry,
          rotate,
          ...otherOptions
        } = toolView.options;
        return {
          ...otherOptions,
          useModelGeometry: useModelGeometry || relative,
          rotate: rotate || relative,
          relative
        };
      }
      function getAnchor(coords, view, magnet) {
        var end = pinRelative.call(this.paper, {}, view, magnet, coords, this.model);
        return end.anchor;
      }
      function snapAnchor(coords, view, magnet, type, relatedView, toolView) {
        var snapRadius = toolView.options.snapRadius;
        var isSource = type === "source";
        var refIndex = isSource ? 0 : -1;
        var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? "target" : "source");
        if (ref) {
          if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;
          if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;
        }
        return coords;
      }
      var SegmentHandle = View.extend({
        tagName: "g",
        svgElement: true,
        className: "marker-segment",
        events: {
          mousedown: "onPointerDown",
          touchstart: "onPointerDown"
        },
        documentEvents: {
          mousemove: "onPointerMove",
          touchmove: "onPointerMove",
          mouseup: "onPointerUp",
          touchend: "onPointerUp",
          touchcancel: "onPointerUp"
        },
        children: [{
          tagName: "line",
          selector: "line",
          attributes: {
            "stroke": "#33334F",
            "stroke-width": 2,
            "fill": "none",
            "pointer-events": "none"
          }
        }, {
          tagName: "rect",
          selector: "handle",
          attributes: {
            "width": 20,
            "height": 8,
            "x": -10,
            "y": -4,
            "rx": 4,
            "ry": 4,
            "fill": "#33334F",
            "stroke": "#FFFFFF",
            "stroke-width": 2
          }
        }],
        onRender: function() {
          this.renderChildren();
        },
        position: function(x, y, angle, view) {
          const {
            scale: scale2
          } = this.options;
          let matrix = V2.createSVGMatrix().translate(x, y).rotate(angle);
          if (scale2) matrix = matrix.scale(scale2);
          var handle = this.childNodes.handle;
          handle.setAttribute("transform", V2.matrixToTransformString(matrix));
          handle.setAttribute("cursor", angle % 180 === 0 ? "row-resize" : "col-resize");
          var viewPoint = view.getClosestPoint(new Point(x, y));
          var line2 = this.childNodes.line;
          line2.setAttribute("x1", x);
          line2.setAttribute("y1", y);
          line2.setAttribute("x2", viewPoint.x);
          line2.setAttribute("y2", viewPoint.y);
        },
        onPointerDown: function(evt) {
          if (this.options.guard(evt)) return;
          this.trigger("change:start", this, evt);
          evt.stopPropagation();
          evt.preventDefault();
          this.options.paper.undelegateEvents();
          this.delegateDocumentEvents(null, evt.data);
        },
        onPointerMove: function(evt) {
          this.trigger("changing", this, evt);
        },
        onPointerUp: function(evt) {
          this.undelegateDocumentEvents();
          this.options.paper.delegateEvents();
          this.trigger("change:end", this, evt);
        },
        show: function() {
          this.el.style.display = "";
        },
        hide: function() {
          this.el.style.display = "none";
        }
      });
      const Segments = ToolView.extend({
        name: "segments",
        precision: 0.5,
        options: {
          handleClass: SegmentHandle,
          segmentLengthThreshold: 40,
          redundancyRemoval: true,
          anchor: getAnchor,
          snapRadius: 10,
          snapHandle: true,
          stopPropagation: true
        },
        handles: null,
        onRender: function() {
          this.resetHandles();
          var relatedView = this.relatedView;
          var vertices = relatedView.model.vertices();
          vertices.unshift(relatedView.sourcePoint);
          vertices.push(relatedView.targetPoint);
          for (var i = 0, n = vertices.length; i < n - 1; i++) {
            var vertex = vertices[i];
            var nextVertex = vertices[i + 1];
            var handle = this.renderHandle(vertex, nextVertex);
            this.simulateRelatedView(handle.el);
            this.handles.push(handle);
            handle.options.index = i;
          }
          return this;
        },
        renderHandle: function(vertex, nextVertex) {
          var handle = new this.options.handleClass({
            paper: this.paper,
            scale: this.options.scale,
            guard: (evt) => this.guard(evt)
          });
          handle.render();
          this.updateHandle(handle, vertex, nextVertex);
          handle.vel.appendTo(this.el);
          this.startHandleListening(handle);
          return handle;
        },
        update: function() {
          this.render();
          return this;
        },
        startHandleListening: function(handle) {
          this.listenTo(handle, "change:start", this.onHandleChangeStart);
          this.listenTo(handle, "changing", this.onHandleChanging);
          this.listenTo(handle, "change:end", this.onHandleChangeEnd);
        },
        resetHandles: function() {
          var handles = this.handles;
          this.handles = [];
          this.stopListening();
          if (!Array.isArray(handles)) return;
          for (var i = 0, n = handles.length; i < n; i++) {
            handles[i].remove();
          }
        },
        shiftHandleIndexes: function(value) {
          var handles = this.handles;
          for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;
        },
        resetAnchor: function(type, anchor2) {
          var relatedModel = this.relatedView.model;
          if (anchor2) {
            relatedModel.prop([type, "anchor"], anchor2, {
              rewrite: true,
              ui: true,
              tool: this.cid
            });
          } else {
            relatedModel.removeProp([type, "anchor"], {
              ui: true,
              tool: this.cid
            });
          }
        },
        snapHandle: function(handle, position2, data2) {
          var index2 = handle.options.index;
          var linkView = this.relatedView;
          var link = linkView.model;
          var vertices = link.vertices();
          var axis = handle.options.axis;
          var prev = vertices[index2 - 2] || data2.sourceAnchor;
          var next = vertices[index2 + 1] || data2.targetAnchor;
          var snapRadius = this.options.snapRadius;
          if (Math.abs(position2[axis] - prev[axis]) < snapRadius) {
            position2[axis] = prev[axis];
          } else if (Math.abs(position2[axis] - next[axis]) < snapRadius) {
            position2[axis] = next[axis];
          }
          return position2;
        },
        onHandleChanging: function(handle, evt) {
          const {
            options
          } = this;
          var data2 = this.eventData(evt);
          var relatedView = this.relatedView;
          var paper = relatedView.paper;
          var index2 = handle.options.index - 1;
          var normalizedEvent = normalizeEvent(evt);
          var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          var position2 = this.snapHandle(handle, coords.clone(), data2);
          var axis = handle.options.axis;
          var offset2 = this.options.snapHandle ? 0 : coords[axis] - position2[axis];
          var link = relatedView.model;
          var vertices = cloneDeep(link.vertices());
          var anchorFn = this.options.anchor;
          if (typeof anchorFn !== "function") anchorFn = null;
          const handleIndex = handle.options.index;
          const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];
          let indexOffset = 0;
          if (handleIndex - 1 >= 0) {
            const v1 = vertexPoints[handleIndex - 1];
            const v2 = vertexPoints[handleIndex];
            const theta = new Line(v1, v2).vector().theta();
            if (theta % 90 !== 0) {
              vertices.splice(handleIndex - 1, 0, data2.originalVertices[handleIndex - 1]);
              indexOffset++;
              this.shiftHandleIndexes(1);
            }
          }
          var vertex = vertices[index2 + indexOffset];
          var nextVertex = vertices[index2 + 1 + indexOffset];
          if (handleIndex + 2 < vertexPoints.length) {
            const v1 = vertexPoints[handleIndex + 1];
            const v2 = vertexPoints[handleIndex + 2];
            const theta = new Line(v1, v2).vector().theta();
            if (theta % 90 !== 0) {
              const isSingleVertex = data2.originalVertices.length === 1;
              const origVIndex = isSingleVertex ? 0 : handleIndex;
              const additionalOffset = data2.firstHandleShifted && !isSingleVertex ? 1 : 0;
              let nextVIndex = 1 + indexOffset;
              vertices.splice(handleIndex + nextVIndex, 0, data2.originalVertices[origVIndex - additionalOffset]);
            }
          }
          var sourceView = relatedView.sourceView;
          var sourceBBox = relatedView.sourceBBox;
          var changeSourceAnchor = false;
          var deleteSourceAnchor = false;
          if (!vertex) {
            vertex = relatedView.sourceAnchor.toJSON();
            vertex[axis] = position2[axis];
            if (sourceBBox.containsPoint(vertex)) {
              vertex[axis] = position2[axis];
              changeSourceAnchor = true;
            } else {
              vertices.unshift(vertex);
              this.shiftHandleIndexes(1);
              data2.firstHandleShifted = true;
              deleteSourceAnchor = true;
            }
          } else if (index2 === 0) {
            if (sourceBBox.containsPoint(vertex)) {
              vertices.shift();
              this.shiftHandleIndexes(-1);
              changeSourceAnchor = true;
            } else {
              vertex[axis] = position2[axis];
              deleteSourceAnchor = true;
            }
          } else {
            vertex[axis] = position2[axis];
          }
          if (anchorFn && sourceView) {
            if (changeSourceAnchor) {
              var sourceAnchorPosition = data2.sourceAnchor.clone();
              sourceAnchorPosition[axis] = position2[axis];
              var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, "source", relatedView);
              this.resetAnchor("source", sourceAnchor);
            }
            if (deleteSourceAnchor) {
              this.resetAnchor("source", data2.sourceAnchorDef);
            }
          }
          var targetView = relatedView.targetView;
          var targetBBox = relatedView.targetBBox;
          var changeTargetAnchor = false;
          var deleteTargetAnchor = false;
          if (!nextVertex) {
            nextVertex = relatedView.targetAnchor.toJSON();
            nextVertex[axis] = position2[axis];
            if (targetBBox.containsPoint(nextVertex)) {
              changeTargetAnchor = true;
            } else {
              vertices.push(nextVertex);
              deleteTargetAnchor = true;
            }
          } else if (index2 === vertices.length - 2) {
            if (targetBBox.containsPoint(nextVertex)) {
              vertices.pop();
              changeTargetAnchor = true;
            } else {
              nextVertex[axis] = position2[axis];
              deleteTargetAnchor = true;
            }
          } else {
            nextVertex[axis] = position2[axis];
          }
          if (anchorFn && targetView) {
            if (changeTargetAnchor) {
              var targetAnchorPosition = data2.targetAnchor.clone();
              targetAnchorPosition[axis] = position2[axis];
              var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, "target", relatedView);
              this.resetAnchor("target", targetAnchor);
            }
            if (deleteTargetAnchor) {
              this.resetAnchor("target", data2.targetAnchorDef);
            }
          }
          if (vertices.some((v) => !v)) {
            throw new Error("Segments: incompatible router in use");
          }
          link.vertices(vertices, {
            ui: true,
            tool: this.cid
          });
          this.updateHandle(handle, vertex, nextVertex, offset2);
          if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);
        },
        onHandleChangeStart: function(handle, evt) {
          const {
            options,
            handles,
            relatedView: linkView
          } = this;
          const {
            model,
            paper
          } = linkView;
          var index2 = handle.options.index;
          if (!Array.isArray(handles)) return;
          for (var i = 0, n = handles.length; i < n; i++) {
            if (i !== index2) handles[i].hide();
          }
          this.focus();
          this.eventData(evt, {
            sourceAnchor: linkView.sourceAnchor.clone(),
            targetAnchor: linkView.targetAnchor.clone(),
            sourceAnchorDef: clone$1(model.prop(["source", "anchor"])),
            targetAnchorDef: clone$1(model.prop(["target", "anchor"])),
            originalVertices: cloneDeep(model.vertices()),
            firstHandleShifted: false
          });
          model.startBatch("segment-move", {
            ui: true,
            tool: this.cid
          });
          if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));
        },
        onHandleChangeEnd: function(_handle, evt) {
          const {
            options,
            relatedView: linkView
          } = this;
          const {
            paper,
            model
          } = linkView;
          if (options.redundancyRemoval) {
            linkView.removeRedundantLinearVertices({
              ui: true,
              tool: this.cid
            });
          }
          const normalizedEvent = normalizeEvent(evt);
          const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          this.render();
          this.blur();
          model.stopBatch("segment-move", {
            ui: true,
            tool: this.cid
          });
          if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);
          linkView.checkMouseleave(normalizedEvent);
        },
        updateHandle: function(handle, vertex, nextVertex, offset2) {
          var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;
          var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;
          if (vertical || horizontal) {
            var segmentLine = new Line(vertex, nextVertex);
            var length2 = segmentLine.length();
            if (length2 < this.options.segmentLengthThreshold) {
              handle.hide();
            } else {
              var position2 = segmentLine.midpoint();
              var axis = vertical ? "x" : "y";
              position2[axis] += offset2 || 0;
              var angle = segmentLine.vector().vectorAngle(new Point(1, 0));
              handle.position(position2.x, position2.y, angle, this.relatedView);
              handle.show();
              handle.options.axis = axis;
            }
          } else {
            handle.hide();
          }
        },
        onRemove: function() {
          this.resetHandles();
        }
      }, {
        SegmentHandle
        // keep as class property
      });
      const Arrowhead = ToolView.extend({
        tagName: "path",
        xAxisVector: new Point(1, 0),
        events: {
          mousedown: "onPointerDown",
          touchstart: "onPointerDown"
        },
        documentEvents: {
          mousemove: "onPointerMove",
          touchmove: "onPointerMove",
          mouseup: "onPointerUp",
          touchend: "onPointerUp",
          touchcancel: "onPointerUp"
        },
        options: {
          scale: null
        },
        onRender: function() {
          this.update();
        },
        update: function() {
          var ratio = this.ratio;
          var view = this.relatedView;
          var tangent = view.getTangentAtRatio(ratio);
          var position2, angle;
          if (tangent) {
            position2 = tangent.start;
            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;
          } else {
            position2 = view.getPointAtRatio(ratio);
            angle = 0;
          }
          if (!position2) return this;
          var matrix = V2.createSVGMatrix().translate(position2.x, position2.y).rotate(angle);
          const {
            scale: scale2
          } = this.options;
          if (scale2) matrix = matrix.scale(scale2);
          this.vel.transform(matrix, {
            absolute: true
          });
          return this;
        },
        onPointerDown: function(evt) {
          if (this.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          var relatedView = this.relatedView;
          var paper = relatedView.paper;
          relatedView.model.startBatch("arrowhead-move", {
            ui: true,
            tool: this.cid
          });
          relatedView.startArrowheadMove(this.arrowheadType);
          const data2 = evt.data || (evt.data = {});
          this.delegateDocumentEvents(null, data2);
          paper.undelegateEvents();
          this.focus();
          this.el.style.pointerEvents = "none";
          relatedView.notifyPointerdown(...paper.getPointerArgs(evt));
        },
        onPointerMove: function(evt) {
          var normalizedEvent = normalizeEvent(evt);
          var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);
        },
        onPointerUp: function(evt) {
          this.undelegateDocumentEvents();
          var relatedView = this.relatedView;
          var paper = relatedView.paper;
          var normalizedEvent = normalizeEvent(evt);
          var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          relatedView.pointerup(normalizedEvent, coords.x, coords.y);
          paper.delegateEvents();
          this.blur();
          this.el.style.pointerEvents = "";
          relatedView.model.stopBatch("arrowhead-move", {
            ui: true,
            tool: this.cid
          });
        }
      });
      const TargetArrowhead = Arrowhead.extend({
        name: "target-arrowhead",
        ratio: 1,
        arrowheadType: "target",
        attributes: {
          "d": "M -10 -8 10 0 -10 8 Z",
          "fill": "#33334F",
          "stroke": "#FFFFFF",
          "stroke-width": 2,
          "cursor": "move",
          "class": "target-arrowhead"
        }
      });
      const SourceArrowhead = Arrowhead.extend({
        name: "source-arrowhead",
        ratio: 0,
        arrowheadType: "source",
        attributes: {
          "d": "M 10 -8 -10 0 10 8 Z",
          "fill": "#33334F",
          "stroke": "#FFFFFF",
          "stroke-width": 2,
          "cursor": "move",
          "class": "source-arrowhead"
        }
      });
      const Anchor = ToolView.extend({
        tagName: "g",
        type: null,
        children: [{
          tagName: "circle",
          selector: "anchor",
          attributes: {
            "cursor": "pointer"
          }
        }, {
          tagName: "rect",
          selector: "area",
          attributes: {
            "pointer-events": "none",
            "fill": "none",
            "stroke": "#33334F",
            "stroke-dasharray": "2,4",
            "rx": 5,
            "ry": 5
          }
        }],
        events: {
          mousedown: "onPointerDown",
          touchstart: "onPointerDown",
          dblclick: "onPointerDblClick",
          dbltap: "onPointerDblClick"
        },
        documentEvents: {
          mousemove: "onPointerMove",
          touchmove: "onPointerMove",
          mouseup: "onPointerUp",
          touchend: "onPointerUp",
          touchcancel: "onPointerUp"
        },
        options: {
          snap: snapAnchor,
          anchor: getAnchor,
          scale: null,
          resetAnchor: true,
          customAnchorAttributes: {
            "stroke-width": 4,
            "stroke": "#33334F",
            "fill": "#FFFFFF",
            "r": 5
          },
          defaultAnchorAttributes: {
            "stroke-width": 2,
            "stroke": "#FFFFFF",
            "fill": "#33334F",
            "r": 6
          },
          areaPadding: 6,
          snapRadius: 10,
          restrictArea: true,
          redundancyRemoval: true
        },
        onRender: function() {
          this.renderChildren();
          this.toggleArea(false);
          this.update();
        },
        update: function() {
          var type = this.type;
          var relatedView = this.relatedView;
          var view = relatedView.getEndView(type);
          if (view) {
            this.updateAnchor();
            this.updateArea();
            this.el.style.display = "";
          } else {
            this.el.style.display = "none";
          }
          return this;
        },
        updateAnchor: function() {
          var childNodes = this.childNodes;
          if (!childNodes) return;
          var anchorNode = childNodes.anchor;
          if (!anchorNode) return;
          var relatedView = this.relatedView;
          var type = this.type;
          var position2 = relatedView.getEndAnchor(type);
          var options = this.options;
          var customAnchor = relatedView.model.prop([type, "anchor"]);
          let transformString = `translate(${position2.x},${position2.y})`;
          if (options.scale) {
            transformString += ` scale(${options.scale})`;
          }
          anchorNode.setAttribute("transform", transformString);
          var anchorAttributes = customAnchor ? options.customAnchorAttributes : options.defaultAnchorAttributes;
          for (var attrName in anchorAttributes) {
            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);
          }
        },
        updateArea: function() {
          var childNodes = this.childNodes;
          if (!childNodes) return;
          var areaNode = childNodes.area;
          if (!areaNode) return;
          var relatedView = this.relatedView;
          var type = this.type;
          var view = relatedView.getEndView(type);
          var model = view.model;
          var magnet = relatedView.getEndMagnet(type);
          var padding = this.options.areaPadding;
          if (!isFinite(padding)) padding = 0;
          var bbox2, angle, center2;
          if (view.isNodeConnection(magnet)) {
            bbox2 = view.getNodeBBox(magnet);
            angle = 0;
            center2 = bbox2.center();
          } else {
            bbox2 = view.getNodeUnrotatedBBox(magnet);
            angle = model.angle();
            center2 = bbox2.center();
            if (angle) center2.rotate(model.getCenter(), -angle);
          }
          bbox2.inflate(padding);
          areaNode.setAttribute("x", -bbox2.width / 2);
          areaNode.setAttribute("y", -bbox2.height / 2);
          areaNode.setAttribute("width", bbox2.width);
          areaNode.setAttribute("height", bbox2.height);
          areaNode.setAttribute("transform", "translate(" + center2.x + "," + center2.y + ") rotate(" + angle + ")");
        },
        toggleArea: function(visible) {
          var childNodes = this.childNodes;
          if (!childNodes) return;
          var areaNode = childNodes.area;
          if (!areaNode) return;
          areaNode.style.display = visible ? "" : "none";
        },
        onPointerDown: function(evt) {
          if (this.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          this.paper.undelegateEvents();
          this.delegateDocumentEvents();
          this.focus();
          this.toggleArea(this.options.restrictArea);
          this.relatedView.model.startBatch("anchor-move", {
            ui: true,
            tool: this.cid
          });
        },
        resetAnchor: function(anchor2) {
          var type = this.type;
          var relatedModel = this.relatedView.model;
          if (anchor2) {
            relatedModel.prop([type, "anchor"], anchor2, {
              rewrite: true,
              ui: true,
              tool: this.cid
            });
          } else {
            relatedModel.removeProp([type, "anchor"], {
              ui: true,
              tool: this.cid
            });
          }
        },
        onPointerMove: function(evt) {
          var relatedView = this.relatedView;
          var type = this.type;
          var view = relatedView.getEndView(type);
          var model = view.model;
          var magnet = relatedView.getEndMagnet(type);
          var normalizedEvent = normalizeEvent(evt);
          var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);
          var snapFn = this.options.snap;
          if (typeof snapFn === "function") {
            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);
            coords = new Point(coords);
          }
          if (this.options.restrictArea) {
            if (view.isNodeConnection(magnet)) {
              var pointAtConnection = view.getClosestPoint(coords);
              if (pointAtConnection) coords = pointAtConnection;
            } else {
              var bbox2 = view.getNodeUnrotatedBBox(magnet);
              var angle = model.angle();
              var origin = model.getCenter();
              var rotatedCoords = coords.clone().rotate(origin, angle);
              if (!bbox2.containsPoint(rotatedCoords)) {
                coords = bbox2.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);
              }
            }
          }
          var anchor2;
          var anchorFn = this.options.anchor;
          if (typeof anchorFn === "function") {
            anchor2 = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);
          }
          this.resetAnchor(anchor2);
          this.update();
        },
        onPointerUp: function(evt) {
          const normalizedEvent = normalizeEvent(evt);
          this.paper.delegateEvents();
          this.undelegateDocumentEvents();
          this.blur();
          this.toggleArea(false);
          var linkView = this.relatedView;
          if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({
            ui: true,
            tool: this.cid
          });
          linkView.checkMouseleave(normalizedEvent);
          linkView.model.stopBatch("anchor-move", {
            ui: true,
            tool: this.cid
          });
        },
        onPointerDblClick: function() {
          var anchor2 = this.options.resetAnchor;
          if (anchor2 === false) return;
          if (anchor2 === true) anchor2 = null;
          this.resetAnchor(cloneDeep(anchor2));
          this.update();
        }
      });
      const SourceAnchor = Anchor.extend({
        name: "source-anchor",
        type: "source"
      });
      const TargetAnchor = Anchor.extend({
        name: "target-anchor",
        type: "target"
      });
      const Control = ToolView.extend({
        tagName: "g",
        children: [{
          tagName: "circle",
          selector: "handle",
          attributes: {
            "cursor": "pointer",
            "stroke-width": 2,
            "stroke": "#FFFFFF",
            "fill": "#33334F",
            "r": 6
          }
        }, {
          tagName: "rect",
          selector: "extras",
          attributes: {
            "pointer-events": "none",
            "fill": "none",
            "stroke": "#33334F",
            "stroke-dasharray": "2,4",
            "rx": 5,
            "ry": 5
          }
        }],
        events: {
          mousedown: "onPointerDown",
          touchstart: "onPointerDown",
          dblclick: "onPointerDblClick",
          dbltap: "onPointerDblClick"
        },
        documentEvents: {
          mousemove: "onPointerMove",
          touchmove: "onPointerMove",
          mouseup: "onPointerUp",
          touchend: "onPointerUp",
          touchcancel: "onPointerUp"
        },
        options: {
          handleAttributes: null,
          selector: "root",
          padding: 6,
          scale: null
        },
        getPosition: function() {
        },
        setPosition: function() {
        },
        resetPosition: function() {
        },
        onRender: function() {
          this.renderChildren();
          this.toggleExtras(false);
          this.update();
        },
        update: function() {
          const {
            handle,
            extras
          } = this.childNodes;
          if (handle) {
            this.updateHandle(handle);
          } else {
            throw new Error("Control: markup selector `handle` is required");
          }
          if (extras) {
            this.updateExtras(extras);
          }
          return this;
        },
        updateHandle: function(handleNode) {
          const {
            options: {
              handleAttributes
            }
          } = this;
          handleNode.setAttribute("transform", this.getHandleTransformString());
          if (handleAttributes) {
            for (let attrName in handleAttributes) {
              handleNode.setAttribute(attrName, handleAttributes[attrName]);
            }
          }
        },
        getHandleTransformString() {
          const {
            relatedView,
            options
          } = this;
          const {
            scale: scale2
          } = options;
          const {
            model
          } = relatedView;
          const relativePos = this.getPosition(relatedView, this);
          const translate = this.isOverlay() ? model.getAbsolutePointFromRelative(relativePos) : relativePos;
          let transformString = `translate(${translate.x},${translate.y})`;
          if (scale2) {
            transformString += ` scale(${scale2})`;
          }
          return transformString;
        },
        updateExtras: function(extrasNode) {
          const {
            relatedView,
            options
          } = this;
          const {
            selector,
            relative,
            useModelGeometry
          } = getToolOptions(this);
          if (!selector) {
            this.toggleExtras(false);
            return;
          }
          let bbox2;
          if (useModelGeometry) {
            if (selector !== "root") {
              console.warn("Control: selector will be ignored when `useModelGeometry` is used.");
            }
            bbox2 = getViewBBox(relatedView, {
              useModelGeometry,
              relative
            });
          } else {
            const el = relatedView.findNode(selector);
            if (!el) throw new Error("Control: invalid selector.");
            bbox2 = getViewBBox(relatedView, {
              el
            });
          }
          let padding = options.padding;
          if (!isFinite(padding)) padding = 0;
          const model = relatedView.model;
          const angle = relative ? 0 : model.angle();
          const center2 = bbox2.center();
          if (angle) center2.rotate(model.getCenter(), -angle);
          bbox2.inflate(padding);
          extrasNode.setAttribute("x", -bbox2.width / 2);
          extrasNode.setAttribute("y", -bbox2.height / 2);
          extrasNode.setAttribute("width", bbox2.width);
          extrasNode.setAttribute("height", bbox2.height);
          extrasNode.setAttribute("transform", `translate(${center2.x},${center2.y}) rotate(${angle})`);
        },
        toggleExtras: function(visible) {
          const {
            extras
          } = this.childNodes;
          if (!extras) return;
          extras.style.display = visible ? "" : "none";
        },
        onPointerDown: function(evt) {
          const {
            relatedView,
            paper
          } = this;
          if (this.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          paper.undelegateEvents();
          this.delegateDocumentEvents();
          this.focus();
          this.toggleExtras(true);
          relatedView.model.startBatch("control-move", {
            ui: true,
            tool: this.cid
          });
        },
        onPointerMove: function(evt) {
          const {
            relatedView,
            paper
          } = this;
          const {
            model
          } = relatedView;
          const {
            clientX,
            clientY
          } = normalizeEvent(evt);
          const coords = paper.clientToLocalPoint(clientX, clientY);
          const relativeCoords = model.getRelativePointFromAbsolute(coords);
          this.setPosition(relatedView, relativeCoords, evt);
          this.update();
        },
        onPointerUp: function(_evt) {
          const {
            relatedView,
            paper
          } = this;
          paper.delegateEvents();
          this.undelegateDocumentEvents();
          this.blur();
          this.toggleExtras(false);
          relatedView.model.stopBatch("control-move", {
            ui: true,
            tool: this.cid
          });
        },
        onPointerDblClick: function(evt) {
          const {
            relatedView
          } = this;
          this.resetPosition(relatedView, evt);
          this.update();
        }
      });
      const RotateLabel = Control.extend({
        xAxisVector: new Point(1, 0),
        children() {
          const {
            buttonColor = "#333",
            iconColor = "#fff",
            outlineColor = "#fff"
          } = this.options;
          return [{
            selector: "handle",
            tagName: "g",
            attributes: {
              cursor: "grab"
            },
            children: [{
              tagName: "circle",
              attributes: {
                r: 10,
                fill: buttonColor,
                stroke: outlineColor
              }
            }, {
              tagName: "path",
              attributes: {
                d: "M -5 0 A 5 5 0 1 1 0 5",
                fill: "transparent",
                stroke: iconColor,
                strokeWidth: 2,
                strokeLinecap: "round"
              }
            }, {
              tagName: "path",
              attributes: {
                d: "M -3 5 L 0 2.5 0 7.5 Z",
                fill: iconColor,
                stroke: iconColor,
                strokeWidth: 1,
                transform: "rotate(-5, -3, 5)"
              }
            }]
          }];
        },
        getPosition(view) {
          const {
            offset: offset2 = 0
          } = this.options;
          const {
            x = 0,
            y = 0
          } = typeof offset2 === "number" ? {
            x: 0,
            y: offset2
          } : offset2;
          const label = this.getLabel();
          const labelPosition = this.getLabelPosition(label);
          const coords = view.getLabelCoordinates(labelPosition);
          let {
            angle = 0,
            args = {}
          } = labelPosition;
          const keepGradient = args.keepGradient;
          if (keepGradient) {
            const tangent = view.getTangentAtRatio(view.getClosestPointRatio(coords));
            if (tangent) {
              angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;
            }
          }
          const matrix = new DOMMatrix().translate(coords.x, coords.y).rotate(angle).translate(x, y);
          return new Point(matrix.e, matrix.f);
        },
        // Override the default `computeVisibility` method to hide the tool if the label is not present.
        computeVisibility() {
          const visibility = Control.prototype.computeVisibility.apply(this, arguments);
          return visibility && !!this.getLabel();
        },
        setPosition(view, coordinates) {
          const model = view.model;
          const label = this.getLabel();
          if (!label) return;
          const labelPosition = this.getLabelPosition(label);
          const position2 = view.getLabelCoordinates(labelPosition);
          const angle = 90 - position2.theta(coordinates);
          const index2 = this.getLabelIndex();
          model.prop(["labels", index2, "position", "angle"], angle);
        },
        resetPosition(view) {
          const model = view.model;
          const index2 = this.getLabelIndex();
          model.prop(["labels", index2, "position", "angle"], 0);
        },
        getLabelIndex() {
          return this.options.labelIndex || 0;
        },
        getLabel() {
          return this.relatedView.model.label(this.getLabelIndex()) || null;
        },
        getLabelPosition(label) {
          const view = this.relatedView;
          const labelPosition = view._normalizeLabelPosition(label.position);
          return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());
        }
      });
      const Button = ToolView.extend({
        name: "button",
        events: {
          "mousedown": "onPointerDown",
          "touchstart": "onPointerDown"
        },
        options: {
          distance: 0,
          offset: 0,
          scale: null,
          rotate: false
        },
        onRender: function() {
          this.renderChildren(this.options.markup);
          this.update();
        },
        update: function() {
          this.position();
          return this;
        },
        position: function() {
          const {
            vel
          } = this;
          vel.transform(this.getCellMatrix(), {
            absolute: true
          });
        },
        getCellMatrix() {
          return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();
        },
        getElementMatrix() {
          const {
            relatedView: view
          } = this;
          let {
            x = 0,
            y = 0,
            offset: offset2 = {},
            useModelGeometry,
            rotate,
            scale: scale2,
            relative
          } = getToolOptions(this);
          let bbox2 = getViewBBox(view, {
            useModelGeometry,
            relative
          });
          const angle = view.model.angle();
          if (!rotate) bbox2 = bbox2.bbox(angle);
          const {
            x: offsetX = 0,
            y: offsetY = 0
          } = offset2;
          if (isPercentage(x)) {
            x = parseFloat(x) / 100 * bbox2.width;
          } else if (isCalcExpression(x)) {
            x = Number(evalCalcExpression(x, bbox2));
          }
          if (isPercentage(y)) {
            y = parseFloat(y) / 100 * bbox2.height;
          } else if (isCalcExpression(y)) {
            y = Number(evalCalcExpression(y, bbox2));
          }
          let matrix = V2.createSVGMatrix().translate(bbox2.x + bbox2.width / 2, bbox2.y + bbox2.height / 2);
          if (rotate && !relative) matrix = matrix.rotate(angle);
          matrix = matrix.translate(x + offsetX - bbox2.width / 2, y + offsetY - bbox2.height / 2);
          if (scale2) matrix = matrix.scale(scale2);
          return matrix;
        },
        getLinkMatrix() {
          const {
            relatedView: view,
            options
          } = this;
          const {
            offset: offset2 = 0,
            distance: distanceOpt = 0,
            rotate,
            scale: scale2
          } = options;
          const distance = typeof distanceOpt === "function" ? distanceOpt.call(this, view, this) : distanceOpt;
          let tangent, position2, angle;
          if (isPercentage(distance)) {
            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);
          } else {
            tangent = view.getTangentAtLength(distance);
          }
          if (tangent) {
            position2 = tangent.start;
            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
          } else {
            position2 = view.getConnection().start;
            angle = 0;
          }
          let matrix = V2.createSVGMatrix().translate(position2.x, position2.y).rotate(angle).translate(0, offset2);
          if (!rotate) matrix = matrix.rotate(-angle);
          if (scale2) matrix = matrix.scale(scale2);
          return matrix;
        },
        onPointerDown: function(evt) {
          if (this.guard(evt)) return;
          evt.stopPropagation();
          evt.preventDefault();
          var actionFn = this.options.action;
          if (typeof actionFn === "function") {
            actionFn.call(this.relatedView, evt, this.relatedView, this);
          }
        }
      });
      const Remove = Button.extend({
        name: "remove",
        children: [{
          tagName: "circle",
          selector: "button",
          attributes: {
            "r": 7,
            "fill": "#FF1D00",
            "cursor": "pointer"
          }
        }, {
          tagName: "path",
          selector: "icon",
          attributes: {
            "d": "M -3 -3 3 3 M -3 3 3 -3",
            "fill": "none",
            "stroke": "#FFFFFF",
            "stroke-width": 2,
            "pointer-events": "none"
          }
        }],
        options: {
          distance: 60,
          offset: 0,
          action: function(evt, view, tool) {
            view.model.remove({
              ui: true,
              tool: tool.cid
            });
          }
        }
      });
      const Boundary = ToolView.extend({
        name: "boundary",
        tagName: "rect",
        options: {
          padding: 10,
          useModelGeometry: false
        },
        attributes: {
          "fill": "none",
          "stroke": "#33334F",
          "stroke-width": 0.5,
          "stroke-dasharray": "5, 5",
          "pointer-events": "none"
        },
        onRender: function() {
          this.update();
        },
        update: function() {
          const {
            relatedView: view,
            vel
          } = this;
          const {
            useModelGeometry,
            rotate,
            relative,
            padding
          } = getToolOptions(this);
          const normalizedPadding = normalizeSides(padding);
          let bbox2 = getViewBBox(view, {
            useModelGeometry,
            relative
          }).moveAndExpand({
            x: -normalizedPadding.left,
            y: -normalizedPadding.top,
            width: normalizedPadding.left + normalizedPadding.right,
            height: normalizedPadding.top + normalizedPadding.bottom
          });
          const model = view.model;
          if (model.isElement() && !relative) {
            const angle = model.angle();
            if (angle) {
              if (rotate) {
                const origin = model.getCenter();
                vel.rotate(angle, origin.x, origin.y, {
                  absolute: true
                });
              } else {
                bbox2 = bbox2.bbox(angle);
              }
            }
          }
          vel.attr(bbox2.toJSON());
          return this;
        }
      });
      const Connect = Button.extend({
        name: "connect",
        documentEvents: {
          mousemove: "drag",
          touchmove: "drag",
          mouseup: "dragend",
          touchend: "dragend",
          touchcancel: "dragend"
        },
        children: [{
          tagName: "circle",
          selector: "button",
          attributes: {
            "r": 7,
            "fill": "#333333",
            "cursor": "pointer"
          }
        }, {
          tagName: "path",
          selector: "icon",
          attributes: {
            "d": "M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z",
            "fill": "#FFFFFF",
            "stroke": "none",
            "stroke-width": 2,
            "pointer-events": "none"
          }
        }],
        options: {
          distance: 80,
          offset: 0,
          magnet: (view) => view.el,
          action: (evt, _view, tool) => tool.dragstart(evt)
        },
        getMagnetNode: function() {
          const {
            options,
            relatedView
          } = this;
          const {
            magnet
          } = options;
          let magnetNode;
          switch (typeof magnet) {
            case "function": {
              magnetNode = magnet.call(this, relatedView, this);
              break;
            }
            case "string": {
              magnetNode = relatedView.findNode(magnet);
              break;
            }
            default: {
              magnetNode = magnet;
              break;
            }
          }
          if (!magnetNode) magnetNode = relatedView.el;
          if (magnetNode instanceof SVGElement) return magnetNode;
          throw new Error("Connect: magnet must be an SVGElement");
        },
        dragstart: function(evt) {
          const {
            paper,
            relatedView
          } = this;
          const normalizedEvent = normalizeEvent(evt);
          const {
            x,
            y
          } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);
          relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);
          paper.undelegateEvents();
          this.delegateDocumentEvents(null, normalizedEvent.data);
          this.focus();
        },
        drag: function(evt) {
          const {
            paper,
            relatedView
          } = this;
          const normalizedEvent = normalizeEvent(evt);
          const {
            x,
            y
          } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          relatedView.dragLink(normalizedEvent, x, y);
        },
        dragend: function(evt) {
          const {
            paper,
            relatedView
          } = this;
          const normalizedEvent = normalizeEvent(evt);
          const {
            x,
            y
          } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);
          relatedView.dragLinkEnd(normalizedEvent, x, y);
          this.undelegateDocumentEvents();
          paper.delegateEvents();
          this.blur();
          relatedView.checkMouseleave(normalizedEvent);
        }
      });
      const HoverConnect$1 = Connect.extend({
        name: "hover-connect",
        defaultMarkup: [{
          tagName: "circle",
          attributes: {
            "r": 7,
            "fill": "#333333",
            "cursor": "pointer"
          }
        }, {
          tagName: "path",
          attributes: {
            "d": "M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z",
            "fill": "#FFFFFF",
            "stroke": "none",
            "stroke-width": 2
          }
        }],
        children() {
          const {
            options,
            defaultMarkup
          } = this;
          return [{
            tagName: "path",
            selector: "track",
            attributes: {
              "fill": "none",
              "stroke": "transparent",
              "stroke-width": options.trackWidth || 15,
              "cursor": "pointer"
            }
          }, {
            tagName: "g",
            selector: "button",
            attributes: {
              "pointer-events": "none",
              "display": "none"
            },
            children: options.markup || defaultMarkup
          }];
        },
        events: Object.assign({
          mousemove: "onMousemove",
          mouseenter: "onMouseenter",
          mouseleave: "onMouseleave"
        }, Connect.prototype.events),
        onRender: function() {
          this.renderChildren();
          this.update();
        },
        trackPath: null,
        update() {
          const {
            childNodes
          } = this;
          this.trackPath = this.getTrackPath();
          Connect.prototype.update.apply(this, arguments);
          childNodes.track.setAttribute("d", this.trackPath.serialize());
        },
        position() {
          const {
            el,
            childNodes
          } = this;
          childNodes.button.setAttribute("transform", V2.matrixToTransformString(this.getButtonMatrix()));
          el.setAttribute("transform", V2.matrixToTransformString(this.getTrackMatrix()));
        },
        getButtonMatrix() {
          const {
            options,
            trackPath
          } = this;
          const {
            offset: offset2 = 0,
            distance = 0,
            rotate,
            scale: scale2
          } = options;
          let tangent, position2, angle;
          if (isPercentage(distance)) {
            tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);
          } else {
            tangent = trackPath.tangentAtLength(distance);
          }
          if (tangent) {
            position2 = tangent.start;
            angle = tangent.vector().vectorAngle(new Point(1, 0)) || 0;
          } else {
            position2 = trackPath.start;
            angle = 0;
          }
          let matrix = V2.createSVGMatrix().translate(position2.x, position2.y).rotate(angle).translate(0, offset2);
          if (!rotate) matrix = matrix.rotate(-angle);
          if (scale2) matrix = matrix.scale(scale2);
          return matrix;
        },
        getTrackPath() {
          return this.relatedView.getConnection();
        },
        getTrackMatrix() {
          return V2.createSVGMatrix();
        },
        getTrackMatrixAbsolute() {
          return this.getTrackMatrix();
        },
        getTrackRatioFromEvent(evt) {
          const {
            relatedView,
            trackPath
          } = this;
          const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);
          const trackPoint = V2.transformPoint(localPoint, this.getTrackMatrixAbsolute().inverse());
          return trackPath.closestPointLength(trackPoint);
        },
        canShowButton() {
          return $.event.has(this.paper.el);
        },
        showButton() {
          this.childNodes.button.style.display = "block";
        },
        hideButton() {
          this.childNodes.button.style.display = "";
        },
        onMousemove(evt) {
          const {
            trackPath
          } = this;
          if (!trackPath) return;
          const {
            options
          } = this;
          options.distance = this.getTrackRatioFromEvent(evt);
          this.position();
        },
        onMouseenter() {
          if (!this.canShowButton()) return;
          this.showButton();
        },
        onMouseleave() {
          this.hideButton();
        }
      });
      var index$1 = {
        __proto__: null,
        Boundary,
        Button,
        Connect,
        Control,
        HoverConnect: HoverConnect$1,
        Remove,
        RotateLabel,
        Segments,
        SourceAnchor,
        SourceArrowhead,
        TargetAnchor,
        TargetArrowhead,
        Vertices
      };
      const HoverConnect = HoverConnect$1.extend({
        getTrackPath() {
          const {
            relatedView: view
          } = this;
          let {
            useModelGeometry,
            relative,
            trackPath = "M 0 0 H calc(w) V calc(h) H 0 Z"
          } = getToolOptions(this);
          if (typeof trackPath === "function") {
            trackPath = trackPath.call(this, view);
          }
          if (isCalcExpression(trackPath)) {
            const bbox2 = getViewBBox(view, {
              useModelGeometry,
              relative
            });
            trackPath = evalCalcExpression(trackPath, bbox2);
          }
          return new Path$1(V2.normalizePathData(trackPath));
        },
        getTrackMatrix() {
          if (this.isOverlay()) return this.getTrackMatrixAbsolute();
          return V2.createSVGMatrix();
        },
        getTrackMatrixAbsolute() {
          const {
            relatedView: view
          } = this;
          let {
            useModelGeometry,
            rotate
          } = getToolOptions(this);
          let bbox2 = getViewBBox(view, {
            useModelGeometry
          });
          const angle = view.model.angle();
          if (!rotate) bbox2 = bbox2.bbox(angle);
          let matrix = V2.createSVGMatrix().translate(bbox2.x + bbox2.width / 2, bbox2.y + bbox2.height / 2);
          if (rotate) matrix = matrix.rotate(angle);
          matrix = matrix.translate(-bbox2.width / 2, -bbox2.height / 2);
          return matrix;
        }
      });
      var index = {
        __proto__: null,
        Boundary,
        Button,
        Connect,
        Control,
        HoverConnect,
        Remove
      };
      var version = "4.2.0";
      const Vectorizer2 = V2;
      const layout$1 = {
        PortLabel,
        Port
      };
      const setTheme = function(theme, opt) {
        opt = opt || {};
        invoke(views, "setTheme", theme, opt);
        View.prototype.defaultTheme = theme;
      };
      const layout = {
        PortLabel,
        Port
      };
      const format = {};
      const ui = {};
      exports2.V = V2;
      exports2.Vectorizer = Vectorizer2;
      exports2.anchors = anchors;
      exports2.config = config$3;
      exports2.connectionPoints = connectionPoints;
      exports2.connectionStrategies = index$3;
      exports2.connectors = connectors;
      exports2.dia = index$2;
      exports2.elementTools = index;
      exports2.env = env;
      exports2.format = format;
      exports2.g = g2;
      exports2.highlighters = highlighters;
      exports2.layout = layout;
      exports2.linkAnchors = linkAnchors;
      exports2.linkTools = index$1;
      exports2.mvc = index$4;
      exports2.routers = routers;
      exports2.setTheme = setTheme;
      exports2.shapes = index$5;
      exports2.ui = ui;
      exports2.util = index$6;
      exports2.version = version;
    }));
    if (typeof joint !== "undefined") {
      g = joint.g, V = joint.V, Vectorizer = joint.V;
    }
    var g;
    var V;
    var Vectorizer;
  }
});
export default require_joint();
//# sourceMappingURL=@joint_core.js.map
